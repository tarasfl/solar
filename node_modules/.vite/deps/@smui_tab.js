import "./chunk-5ANRWAN5.js";
import "./chunk-65CDV2K2.js";
import {
  MDCTabFoundation
} from "./chunk-RE7Q5LHZ.js";
import {
  MDCFadingTabIndicatorFoundation,
  MDCSlidingTabIndicatorFoundation
} from "./chunk-AXHAKLPO.js";
import {
  dist_default
} from "./chunk-CSCS7QPH.js";
import "./chunk-CTXZTH3U.js";
import {
  CommonIcon_default,
  CommonLabel_default,
  SmuiElement_default
} from "./chunk-MMI7NAQ6.js";
import "./chunk-W4OU4FMO.js";
import "./chunk-Y3XZ6UIT.js";
import "./chunk-7EMQ2XW3.js";
import "./chunk-HIFDM6WQ.js";
import "./chunk-OYKM6SV3.js";
import "./chunk-ZJSI6DXQ.js";
import "./chunk-2YJBFMWA.js";
import "./chunk-RJY55RCX.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-GGS237SP.js";
import "./chunk-X7HCJ7ZS.js";
import "./chunk-FBWM3HWJ.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  mount_component,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  space,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-NMMN3PC6.js";
import "./chunk-ZB6PEJPW.js";
import "./chunk-4DGM7FRE.js";
import "./chunk-7U33LM2Z.js";

// node_modules/@smui/tab-indicator/dist/TabIndicator.svelte
var file = "node_modules/@smui/tab-indicator/dist/TabIndicator.svelte";
function create_fragment(ctx) {
  let span1;
  let span0;
  let span0_class_value;
  let span0_style_value;
  let span0_aria_hidden_value;
  let useActions_action;
  let span1_class_value;
  let useActions_action_1;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[20],
    null
  );
  let span0_levels = [
    {
      class: span0_class_value = classMap({
        [
          /*content$class*/
          ctx[6]
        ]: true,
        "mdc-tab-indicator__content": true,
        "mdc-tab-indicator__content--underline": (
          /*type*/
          ctx[3] === "underline"
        ),
        "mdc-tab-indicator__content--icon": (
          /*type*/
          ctx[3] === "icon"
        )
      })
    },
    {
      style: span0_style_value = Object.entries(
        /*contentStyles*/
        ctx[10]
      ).map(func).join(" ")
    },
    {
      "aria-hidden": span0_aria_hidden_value = /*type*/
      ctx[3] === "icon" ? "true" : void 0
    },
    prefixFilter(
      /*$$restProps*/
      ctx[12],
      "content$"
    )
  ];
  let span_data = {};
  for (let i = 0; i < span0_levels.length; i += 1) {
    span_data = assign(span_data, span0_levels[i]);
  }
  let span1_levels = [
    {
      class: span1_class_value = classMap({
        [
          /*className*/
          ctx[2]
        ]: true,
        "mdc-tab-indicator": true,
        "mdc-tab-indicator--active": (
          /*active*/
          ctx[0]
        ),
        "mdc-tab-indicator--fade": (
          /*transition*/
          ctx[4] === "fade"
        ),
        .../*internalClasses*/
        ctx[9]
      })
    },
    exclude(
      /*$$restProps*/
      ctx[12],
      ["content$"]
    )
  ];
  let span_data_1 = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span_data_1 = assign(span_data_1, span1_levels[i]);
  }
  const block = {
    c: function create() {
      span1 = element("span");
      span0 = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span1 = claim_element(nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", {
        class: true,
        style: true,
        "aria-hidden": true
      });
      var span0_nodes = children(span0);
      if (default_slot)
        default_slot.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span0, span_data);
      add_location(span0, file, 13, 2, 316);
      set_attributes(span1, span_data_1);
      add_location(span1, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span1, anchor);
      append_hydration_dev(span1, span0);
      if (default_slot) {
        default_slot.m(span0, null);
      }
      ctx[22](span0);
      ctx[23](span1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span0,
            /*content$use*/
            ctx[5]
          )),
          action_destroyer(useActions_action_1 = useActions.call(
            null,
            span1,
            /*use*/
            ctx[1]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[11].call(null, span1))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1048576)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[20],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[20]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[20],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span0, span_data = get_spread_update(span0_levels, [
        (!current || dirty & /*content$class, type*/
        72 && span0_class_value !== (span0_class_value = classMap({
          [
            /*content$class*/
            ctx2[6]
          ]: true,
          "mdc-tab-indicator__content": true,
          "mdc-tab-indicator__content--underline": (
            /*type*/
            ctx2[3] === "underline"
          ),
          "mdc-tab-indicator__content--icon": (
            /*type*/
            ctx2[3] === "icon"
          )
        }))) && { class: span0_class_value },
        (!current || dirty & /*contentStyles*/
        1024 && span0_style_value !== (span0_style_value = Object.entries(
          /*contentStyles*/
          ctx2[10]
        ).map(func).join(" "))) && { style: span0_style_value },
        (!current || dirty & /*type*/
        8 && span0_aria_hidden_value !== (span0_aria_hidden_value = /*type*/
        ctx2[3] === "icon" ? "true" : void 0)) && { "aria-hidden": span0_aria_hidden_value },
        dirty & /*$$restProps*/
        4096 && prefixFilter(
          /*$$restProps*/
          ctx2[12],
          "content$"
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*content$use*/
      32)
        useActions_action.update.call(
          null,
          /*content$use*/
          ctx2[5]
        );
      set_attributes(span1, span_data_1 = get_spread_update(span1_levels, [
        (!current || dirty & /*className, active, transition, internalClasses*/
        533 && span1_class_value !== (span1_class_value = classMap({
          [
            /*className*/
            ctx2[2]
          ]: true,
          "mdc-tab-indicator": true,
          "mdc-tab-indicator--active": (
            /*active*/
            ctx2[0]
          ),
          "mdc-tab-indicator--fade": (
            /*transition*/
            ctx2[4] === "fade"
          ),
          .../*internalClasses*/
          ctx2[9]
        }))) && { class: span1_class_value },
        dirty & /*$$restProps*/
        4096 && exclude(
          /*$$restProps*/
          ctx2[12],
          ["content$"]
        )
      ]));
      if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/
      2)
        useActions_action_1.update.call(
          null,
          /*use*/
          ctx2[1]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span1);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "active",
    "type",
    "transition",
    "content$use",
    "content$class",
    "activate",
    "deactivate",
    "computeContentClientRect",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabIndicator", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { active = false } = $$props;
  let { type = "underline" } = $$props;
  let { transition = "slide" } = $$props;
  let { content$use = [] } = $$props;
  let { content$class = "" } = $$props;
  let element2;
  let instance;
  let content;
  let internalClasses = {};
  let contentStyles = {};
  let changeSets = [];
  let oldTransition = transition;
  onMount(() => {
    $$invalidate(17, instance = getInstance());
    instance.init();
    return () => {
      instance.destroy();
    };
  });
  function getInstance() {
    const Foundation = {
      fade: MDCFadingTabIndicatorFoundation,
      slide: MDCSlidingTabIndicatorFoundation
    }[transition] || MDCSlidingTabIndicatorFoundation;
    return new Foundation({
      addClass: (...props) => doChange(() => addClass(...props)),
      removeClass: (...props) => doChange(() => removeClass(...props)),
      computeContentClientRect,
      setContentStyleProperty: (...props) => doChange(() => addContentStyle(...props))
    });
  }
  function doChange(fn) {
    if (changeSets.length) {
      changeSets[changeSets.length - 1].push(fn);
    } else {
      fn();
    }
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(9, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(9, internalClasses[className2] = false, internalClasses);
    }
  }
  function addContentStyle(name, value) {
    if (contentStyles[name] != value) {
      if (value === "" || value == null) {
        delete contentStyles[name];
        $$invalidate(10, contentStyles), $$invalidate(19, oldTransition), $$invalidate(4, transition), $$invalidate(17, instance);
      } else {
        $$invalidate(10, contentStyles[name] = value, contentStyles);
      }
    }
  }
  function activate(previousIndicatorClientRect) {
    $$invalidate(0, active = true);
    instance.activate(previousIndicatorClientRect);
  }
  function deactivate() {
    $$invalidate(0, active = false);
    instance.deactivate();
  }
  function computeContentClientRect() {
    changeSets.push([]);
    $$invalidate(18, changeSets);
    return content.getBoundingClientRect();
  }
  function getElement() {
    return element2;
  }
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      content = $$value;
      $$invalidate(8, content);
    });
  }
  function span1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(1, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(2, className = $$new_props.class);
    if ("active" in $$new_props)
      $$invalidate(0, active = $$new_props.active);
    if ("type" in $$new_props)
      $$invalidate(3, type = $$new_props.type);
    if ("transition" in $$new_props)
      $$invalidate(4, transition = $$new_props.transition);
    if ("content$use" in $$new_props)
      $$invalidate(5, content$use = $$new_props.content$use);
    if ("content$class" in $$new_props)
      $$invalidate(6, content$class = $$new_props.content$class);
    if ("$$scope" in $$new_props)
      $$invalidate(20, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCFadingTabIndicatorFoundation,
    MDCSlidingTabIndicatorFoundation,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    forwardEvents,
    use,
    className,
    active,
    type,
    transition,
    content$use,
    content$class,
    element: element2,
    instance,
    content,
    internalClasses,
    contentStyles,
    changeSets,
    oldTransition,
    getInstance,
    doChange,
    addClass,
    removeClass,
    addContentStyle,
    activate,
    deactivate,
    computeContentClientRect,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(1, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(2, className = $$new_props.className);
    if ("active" in $$props)
      $$invalidate(0, active = $$new_props.active);
    if ("type" in $$props)
      $$invalidate(3, type = $$new_props.type);
    if ("transition" in $$props)
      $$invalidate(4, transition = $$new_props.transition);
    if ("content$use" in $$props)
      $$invalidate(5, content$use = $$new_props.content$use);
    if ("content$class" in $$props)
      $$invalidate(6, content$class = $$new_props.content$class);
    if ("element" in $$props)
      $$invalidate(7, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(17, instance = $$new_props.instance);
    if ("content" in $$props)
      $$invalidate(8, content = $$new_props.content);
    if ("internalClasses" in $$props)
      $$invalidate(9, internalClasses = $$new_props.internalClasses);
    if ("contentStyles" in $$props)
      $$invalidate(10, contentStyles = $$new_props.contentStyles);
    if ("changeSets" in $$props)
      $$invalidate(18, changeSets = $$new_props.changeSets);
    if ("oldTransition" in $$props)
      $$invalidate(19, oldTransition = $$new_props.oldTransition);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*oldTransition, transition, instance*/
    655376) {
      $:
        if (oldTransition !== transition) {
          $$invalidate(19, oldTransition = transition);
          instance && instance.destroy();
          $$invalidate(9, internalClasses = {});
          $$invalidate(10, contentStyles = {});
          $$invalidate(17, instance = getInstance());
          instance.init();
        }
    }
    if ($$self.$$.dirty & /*changeSets*/
    262144) {
      $:
        if (changeSets.length) {
          requestAnimationFrame(() => {
            var _a;
            const changeSet = (_a = changeSets.shift()) !== null && _a !== void 0 ? _a : [];
            $$invalidate(18, changeSets);
            for (const fn of changeSet) {
              fn();
            }
          });
        }
    }
  };
  return [
    active,
    use,
    className,
    type,
    transition,
    content$use,
    content$class,
    element2,
    content,
    internalClasses,
    contentStyles,
    forwardEvents,
    $$restProps,
    activate,
    deactivate,
    computeContentClientRect,
    getElement,
    instance,
    changeSets,
    oldTransition,
    $$scope,
    slots,
    span0_binding,
    span1_binding
  ];
}
var TabIndicator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment, safe_not_equal, {
      use: 1,
      class: 2,
      active: 0,
      type: 3,
      transition: 4,
      content$use: 5,
      content$class: 6,
      activate: 13,
      deactivate: 14,
      computeContentClientRect: 15,
      getElement: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabIndicator",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get type() {
    throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set type(value) {
    throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get transition() {
    throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set transition(value) {
    throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get content$use() {
    throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set content$use(value) {
    throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get content$class() {
    throw new Error("<TabIndicator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set content$class(value) {
    throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activate() {
    return this.$$.ctx[13];
  }
  set activate(value) {
    throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deactivate() {
    return this.$$.ctx[14];
  }
  set deactivate(value) {
    throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get computeContentClientRect() {
    return this.$$.ctx[15];
  }
  set computeContentClientRect(value) {
    throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[16];
  }
  set getElement(value) {
    throw new Error("<TabIndicator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabIndicator_default = TabIndicator;

// node_modules/@smui/tab-indicator/dist/index.js
var dist_default2 = TabIndicator_default;

// node_modules/@smui/tab/dist/Tab.svelte
var { Error: Error_1 } = globals;
var file2 = "node_modules/@smui/tab/dist/Tab.svelte";
var get_tab_indicator_slot_changes_1 = (dirty) => ({});
var get_tab_indicator_slot_context_1 = (ctx) => ({});
var get_tab_indicator_slot_changes = (dirty) => ({});
var get_tab_indicator_slot_context = (ctx) => ({});
function create_if_block_1(ctx) {
  let tabindicator;
  let current;
  const tabindicator_spread_levels = [
    { active: (
      /*active*/
      ctx[18]
    ) },
    prefixFilter(
      /*$$restProps*/
      ctx[25],
      "tabIndicator$"
    )
  ];
  let tabindicator_props = {
    $$slots: { default: [create_default_slot_2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < tabindicator_spread_levels.length; i += 1) {
    tabindicator_props = assign(tabindicator_props, tabindicator_spread_levels[i]);
  }
  tabindicator = new dist_default2({
    props: tabindicator_props,
    $$inline: true
  });
  ctx[33](tabindicator);
  const block = {
    c: function create() {
      create_component(tabindicator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabindicator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabindicator, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabindicator_changes = dirty[0] & /*active, $$restProps*/
      33816576 ? get_spread_update(tabindicator_spread_levels, [
        dirty[0] & /*active*/
        262144 && { active: (
          /*active*/
          ctx2[18]
        ) },
        dirty[0] & /*$$restProps*/
        33554432 && get_spread_object(prefixFilter(
          /*$$restProps*/
          ctx2[25],
          "tabIndicator$"
        ))
      ]) : {};
      if (dirty[1] & /*$$scope*/
      64) {
        tabindicator_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabindicator.$set(tabindicator_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabindicator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabindicator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[33](null);
      destroy_component(tabindicator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(49:4) {#if indicatorSpanOnlyContent}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let current;
  const tab_indicator_slot_template = (
    /*#slots*/
    ctx[32]["tab-indicator"]
  );
  const tab_indicator_slot = create_slot(
    tab_indicator_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    get_tab_indicator_slot_context
  );
  const block = {
    c: function create() {
      if (tab_indicator_slot)
        tab_indicator_slot.c();
    },
    l: function claim(nodes) {
      if (tab_indicator_slot)
        tab_indicator_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (tab_indicator_slot) {
        tab_indicator_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (tab_indicator_slot) {
        if (tab_indicator_slot.p && (!current || dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            tab_indicator_slot,
            tab_indicator_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              tab_indicator_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              get_tab_indicator_slot_changes
            ),
            get_tab_indicator_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tab_indicator_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tab_indicator_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (tab_indicator_slot)
        tab_indicator_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: "(50:6) <TabIndicator         bind:this={tabIndicator}         {active}         {...prefixFilter($$restProps, 'tabIndicator$')}         >",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let tabindicator;
  let current;
  const tabindicator_spread_levels = [
    { active: (
      /*active*/
      ctx[18]
    ) },
    prefixFilter(
      /*$$restProps*/
      ctx[25],
      "tabIndicator$"
    )
  ];
  let tabindicator_props = {
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  for (let i = 0; i < tabindicator_spread_levels.length; i += 1) {
    tabindicator_props = assign(tabindicator_props, tabindicator_spread_levels[i]);
  }
  tabindicator = new dist_default2({
    props: tabindicator_props,
    $$inline: true
  });
  ctx[35](tabindicator);
  const block = {
    c: function create() {
      create_component(tabindicator.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(tabindicator.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(tabindicator, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const tabindicator_changes = dirty[0] & /*active, $$restProps*/
      33816576 ? get_spread_update(tabindicator_spread_levels, [
        dirty[0] & /*active*/
        262144 && { active: (
          /*active*/
          ctx2[18]
        ) },
        dirty[0] & /*$$restProps*/
        33554432 && get_spread_object(prefixFilter(
          /*$$restProps*/
          ctx2[25],
          "tabIndicator$"
        ))
      ]) : {};
      if (dirty[1] & /*$$scope*/
      64) {
        tabindicator_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tabindicator.$set(tabindicator_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabindicator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabindicator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[35](null);
      destroy_component(tabindicator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(58:2) {#if !indicatorSpanOnlyContent}",
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let current;
  const tab_indicator_slot_template = (
    /*#slots*/
    ctx[32]["tab-indicator"]
  );
  const tab_indicator_slot = create_slot(
    tab_indicator_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    get_tab_indicator_slot_context_1
  );
  const block = {
    c: function create() {
      if (tab_indicator_slot)
        tab_indicator_slot.c();
    },
    l: function claim(nodes) {
      if (tab_indicator_slot)
        tab_indicator_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (tab_indicator_slot) {
        tab_indicator_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (tab_indicator_slot) {
        if (tab_indicator_slot.p && (!current || dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            tab_indicator_slot,
            tab_indicator_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              tab_indicator_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              get_tab_indicator_slot_changes_1
            ),
            get_tab_indicator_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tab_indicator_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tab_indicator_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (tab_indicator_slot)
        tab_indicator_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(59:4) <TabIndicator       bind:this={tabIndicator}       {active}       {...prefixFilter($$restProps, 'tabIndicator$')}       >",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let span0;
  let t0;
  let span0_class_value;
  let useActions_action;
  let t1;
  let t2;
  let span1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[32].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    null
  );
  let if_block0 = (
    /*indicatorSpanOnlyContent*/
    ctx[6] && create_if_block_1(ctx)
  );
  let span0_levels = [
    {
      class: span0_class_value = classMap({
        [
          /*content$class*/
          ctx[9]
        ]: true,
        "mdc-tab__content": true
      })
    },
    prefixFilter(
      /*$$restProps*/
      ctx[25],
      "content$"
    )
  ];
  let span_data_1 = {};
  for (let i = 0; i < span0_levels.length; i += 1) {
    span_data_1 = assign(span_data_1, span0_levels[i]);
  }
  let if_block1 = !/*indicatorSpanOnlyContent*/
  ctx[6] && create_if_block(ctx);
  const block = {
    c: function create() {
      span0 = element("span");
      if (default_slot)
        default_slot.c();
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      span1 = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span0 = claim_element(nodes, "SPAN", { class: true });
      var span0_nodes = children(span0);
      if (default_slot)
        default_slot.l(span0_nodes);
      t0 = claim_space(span0_nodes);
      if (if_block0)
        if_block0.l(span0_nodes);
      span0_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      if (if_block1)
        if_block1.l(nodes);
      t2 = claim_space(nodes);
      span1 = claim_element(nodes, "SPAN", { class: true });
      children(span1).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span0, span_data_1);
      add_location(span0, file2, 38, 2, 803);
      attr_dev(span1, "class", "mdc-tab__ripple");
      add_location(span1, file2, 65, 2, 1482);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span0, anchor);
      if (default_slot) {
        default_slot.m(span0, null);
      }
      append_hydration_dev(span0, t0);
      if (if_block0)
        if_block0.m(span0, null);
      ctx[34](span0);
      insert_hydration_dev(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert_hydration_dev(target, t2, anchor);
      insert_hydration_dev(target, span1, anchor);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(useActions_action = useActions.call(
          null,
          span0,
          /*content$use*/
          ctx[8]
        ));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*indicatorSpanOnlyContent*/
        ctx2[6]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*indicatorSpanOnlyContent*/
          64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(span0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      set_attributes(span0, span_data_1 = get_spread_update(span0_levels, [
        (!current || dirty[0] & /*content$class*/
        512 && span0_class_value !== (span0_class_value = classMap({
          [
            /*content$class*/
            ctx2[9]
          ]: true,
          "mdc-tab__content": true
        }))) && { class: span0_class_value },
        dirty[0] & /*$$restProps*/
        33554432 && prefixFilter(
          /*$$restProps*/
          ctx2[25],
          "content$"
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*content$use*/
      256)
        useActions_action.update.call(
          null,
          /*content$use*/
          ctx2[8]
        );
      if (!/*indicatorSpanOnlyContent*/
      ctx2[6]) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*indicatorSpanOnlyContent*/
          64) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(t2.parentNode, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span0);
        detach_dev(t1);
        detach_dev(t2);
        detach_dev(span1);
      }
      if (default_slot)
        default_slot.d(detaching);
      if (if_block0)
        if_block0.d();
      ctx[34](null);
      if (if_block1)
        if_block1.d(detaching);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <svelte:component   this={component}   {tag}   bind:this={element}   use={[     [       Ripple,       {         ripple,         unbounded: false,         addClass,         removeClass,         addStyle,       },     ],     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-tab': true,     'mdc-tab--active': active,     'mdc-tab--stacked': stacked,     'mdc-tab--min-width': minWidth,     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   role=\\\"tab\\\"   aria-selected={active ? 'true' : 'false'}   tabindex={active || forceAccessible ? '0' : '-1'}   {href}   on:click={handleClick}   {...internalAttrs}   {...exclude($$restProps, ['content$', 'tabIndicator$'])} >",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { tag: (
      /*tag*/
      ctx[11]
    ) },
    {
      use: [
        [
          dist_default,
          {
            ripple: (
              /*ripple*/
              ctx[3]
            ),
            unbounded: false,
            addClass: (
              /*addClass*/
              ctx[21]
            ),
            removeClass: (
              /*removeClass*/
              ctx[22]
            ),
            addStyle: (
              /*addStyle*/
              ctx[23]
            )
          }
        ],
        /*forwardEvents*/
        ctx[20],
        .../*use*/
        ctx[0]
      ]
    },
    {
      class: classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-tab": true,
        "mdc-tab--active": (
          /*active*/
          ctx[18]
        ),
        "mdc-tab--stacked": (
          /*stacked*/
          ctx[4]
        ),
        "mdc-tab--min-width": (
          /*minWidth*/
          ctx[5]
        ),
        .../*internalClasses*/
        ctx[15]
      })
    },
    {
      style: Object.entries(
        /*internalStyles*/
        ctx[16]
      ).map(func2).concat([
        /*style*/
        ctx[2]
      ]).join(" ")
    },
    { role: "tab" },
    {
      "aria-selected": (
        /*active*/
        ctx[18] ? "true" : "false"
      )
    },
    {
      tabindex: (
        /*active*/
        ctx[18] || /*forceAccessible*/
        ctx[19] ? "0" : "-1"
      )
    },
    { href: (
      /*href*/
      ctx[7]
    ) },
    /*internalAttrs*/
    ctx[17],
    exclude(
      /*$$restProps*/
      ctx[25],
      ["content$", "tabIndicator$"]
    )
  ];
  var switch_value = (
    /*component*/
    ctx[10]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty[0] & /*tag, ripple, addClass, removeClass, addStyle, forwardEvents, use, className, active, stacked, minWidth, internalClasses, internalStyles, style, forceAccessible, href, internalAttrs, $$restProps*/
    50301119) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*tag*/
        2048 && { tag: (
          /*tag*/
          ctx2[11]
        ) },
        dirty[0] & /*ripple, addClass, removeClass, addStyle, forwardEvents, use*/
        15728649 && {
          use: [
            [
              dist_default,
              {
                ripple: (
                  /*ripple*/
                  ctx2[3]
                ),
                unbounded: false,
                addClass: (
                  /*addClass*/
                  ctx2[21]
                ),
                removeClass: (
                  /*removeClass*/
                  ctx2[22]
                ),
                addStyle: (
                  /*addStyle*/
                  ctx2[23]
                )
              }
            ],
            /*forwardEvents*/
            ctx2[20],
            .../*use*/
            ctx2[0]
          ]
        },
        dirty[0] & /*className, active, stacked, minWidth, internalClasses*/
        294962 && {
          class: classMap({
            [
              /*className*/
              ctx2[1]
            ]: true,
            "mdc-tab": true,
            "mdc-tab--active": (
              /*active*/
              ctx2[18]
            ),
            "mdc-tab--stacked": (
              /*stacked*/
              ctx2[4]
            ),
            "mdc-tab--min-width": (
              /*minWidth*/
              ctx2[5]
            ),
            .../*internalClasses*/
            ctx2[15]
          })
        },
        dirty[0] & /*internalStyles, style*/
        65540 && {
          style: Object.entries(
            /*internalStyles*/
            ctx2[16]
          ).map(func2).concat([
            /*style*/
            ctx2[2]
          ]).join(" ")
        },
        switch_instance_spread_levels[4],
        dirty[0] & /*active*/
        262144 && {
          "aria-selected": (
            /*active*/
            ctx2[18] ? "true" : "false"
          )
        },
        dirty[0] & /*active, forceAccessible*/
        786432 && {
          tabindex: (
            /*active*/
            ctx2[18] || /*forceAccessible*/
            ctx2[19] ? "0" : "-1"
          )
        },
        dirty[0] & /*href*/
        128 && { href: (
          /*href*/
          ctx2[7]
        ) },
        dirty[0] & /*internalAttrs*/
        131072 && get_spread_object(
          /*internalAttrs*/
          ctx2[17]
        ),
        dirty[0] & /*$$restProps*/
        33554432 && get_spread_object(exclude(
          /*$$restProps*/
          ctx2[25],
          ["content$", "tabIndicator$"]
        ))
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[36](switch_instance);
    switch_instance.$on(
      "click",
      /*handleClick*/
      ctx[24]
    );
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*component*/
      1024 && switch_value !== (switch_value = /*component*/
      ctx2[10])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          ctx2[36](switch_instance);
          switch_instance.$on(
            "click",
            /*handleClick*/
            ctx2[24]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*tag, ripple, addClass, removeClass, addStyle, forwardEvents, use, className, active, stacked, minWidth, internalClasses, internalStyles, style, forceAccessible, href, internalAttrs, $$restProps*/
        50301119 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*tag*/
          2048 && { tag: (
            /*tag*/
            ctx2[11]
          ) },
          dirty[0] & /*ripple, addClass, removeClass, addStyle, forwardEvents, use*/
          15728649 && {
            use: [
              [
                dist_default,
                {
                  ripple: (
                    /*ripple*/
                    ctx2[3]
                  ),
                  unbounded: false,
                  addClass: (
                    /*addClass*/
                    ctx2[21]
                  ),
                  removeClass: (
                    /*removeClass*/
                    ctx2[22]
                  ),
                  addStyle: (
                    /*addStyle*/
                    ctx2[23]
                  )
                }
              ],
              /*forwardEvents*/
              ctx2[20],
              .../*use*/
              ctx2[0]
            ]
          },
          dirty[0] & /*className, active, stacked, minWidth, internalClasses*/
          294962 && {
            class: classMap({
              [
                /*className*/
                ctx2[1]
              ]: true,
              "mdc-tab": true,
              "mdc-tab--active": (
                /*active*/
                ctx2[18]
              ),
              "mdc-tab--stacked": (
                /*stacked*/
                ctx2[4]
              ),
              "mdc-tab--min-width": (
                /*minWidth*/
                ctx2[5]
              ),
              .../*internalClasses*/
              ctx2[15]
            })
          },
          dirty[0] & /*internalStyles, style*/
          65540 && {
            style: Object.entries(
              /*internalStyles*/
              ctx2[16]
            ).map(func2).concat([
              /*style*/
              ctx2[2]
            ]).join(" ")
          },
          switch_instance_spread_levels[4],
          dirty[0] & /*active*/
          262144 && {
            "aria-selected": (
              /*active*/
              ctx2[18] ? "true" : "false"
            )
          },
          dirty[0] & /*active, forceAccessible*/
          786432 && {
            tabindex: (
              /*active*/
              ctx2[18] || /*forceAccessible*/
              ctx2[19] ? "0" : "-1"
            )
          },
          dirty[0] & /*href*/
          128 && { href: (
            /*href*/
            ctx2[7]
          ) },
          dirty[0] & /*internalAttrs*/
          131072 && get_spread_object(
            /*internalAttrs*/
            ctx2[17]
          ),
          dirty[0] & /*$$restProps*/
          33554432 && get_spread_object(exclude(
            /*$$restProps*/
            ctx2[25],
            ["content$", "tabIndicator$"]
          ))
        ]) : {};
        if (dirty[0] & /*active, $$restProps, tabIndicator, indicatorSpanOnlyContent, content$class, content, content$use*/
        33841984 | dirty[1] & /*$$scope*/
        64) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx[36](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func2 = ([name, value]) => `${name}: ${value};`;
function instance_12($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "tab",
    "ripple",
    "stacked",
    "minWidth",
    "indicatorSpanOnlyContent",
    "href",
    "content$use",
    "content$class",
    "component",
    "tag",
    "activate",
    "deactivate",
    "focus",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Tab", slots, ["default", "tab-indicator"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { tab: tabId } = $$props;
  let { ripple = true } = $$props;
  let { stacked = false } = $$props;
  let { minWidth = false } = $$props;
  let { indicatorSpanOnlyContent = false } = $$props;
  let { href = void 0 } = $$props;
  let { content$use = [] } = $$props;
  let { content$class = "" } = $$props;
  let element2;
  let instance;
  let content;
  let tabIndicator;
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  let focusOnActivate = getContext("SMUI:tab:focusOnActivate");
  let active = tabId === getContext("SMUI:tab:initialActive");
  let forceAccessible = false;
  let { component = SmuiElement_default } = $$props;
  let { tag = component === SmuiElement_default ? href == null ? "button" : "a" : void 0 } = $$props;
  setContext("SMUI:label:context", "tab");
  setContext("SMUI:icon:context", "tab");
  if (!tabId) {
    throw new Error("The tab property is required! It should be passed down from the TabBar to the Tab.");
  }
  onMount(() => {
    $$invalidate(31, instance = new MDCTabFoundation({
      setAttr: addAttr,
      addClass,
      removeClass,
      hasClass,
      activateIndicator: (previousIndicatorClientRect) => tabIndicator.activate(previousIndicatorClientRect),
      deactivateIndicator: () => tabIndicator.deactivate(),
      notifyInteracted: () => dispatch(getElement(), "SMUITab:interacted", { tabId }, void 0, true),
      getOffsetLeft: () => getElement().offsetLeft,
      getOffsetWidth: () => getElement().offsetWidth,
      getContentOffsetLeft: () => content.offsetLeft,
      getContentOffsetWidth: () => content.offsetWidth,
      focus
    }));
    const accessor = {
      tabId,
      get element() {
        return getElement();
      },
      get active() {
        return active;
      },
      forceAccessible(accessible) {
        $$invalidate(19, forceAccessible = accessible);
      },
      computeIndicatorClientRect: () => tabIndicator.computeContentClientRect(),
      computeDimensions: () => instance.computeDimensions(),
      focus,
      activate,
      deactivate
    };
    dispatch(getElement(), "SMUITab:mount", accessor);
    instance.init();
    return () => {
      dispatch(getElement(), "SMUITab:unmount", accessor);
      instance.destroy();
    };
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(15, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(15, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(16, internalStyles);
      } else {
        $$invalidate(16, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(17, internalAttrs[name] = value, internalAttrs);
    }
  }
  function handleClick(event) {
    if (!event.defaultPrevented && instance) {
      instance.handleClick();
    }
  }
  function activate(previousIndicatorClientRect, skipFocus) {
    $$invalidate(18, active = true);
    if (skipFocus) {
      instance.setFocusOnActivate(false);
    }
    instance.activate(previousIndicatorClientRect);
    if (skipFocus) {
      instance.setFocusOnActivate(focusOnActivate);
    }
  }
  function deactivate() {
    $$invalidate(18, active = false);
    instance.deactivate();
  }
  function focus() {
    getElement().focus();
  }
  function getElement() {
    return element2.getElement();
  }
  $$self.$$.on_mount.push(function() {
    if (tabId === void 0 && !("tab" in $$props || $$self.$$.bound[$$self.$$.props["tab"]])) {
      console.warn("<Tab> was created without expected prop 'tab'");
    }
  });
  function tabindicator_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tabIndicator = $$value;
      $$invalidate(14, tabIndicator);
    });
  }
  function span0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      content = $$value;
      $$invalidate(13, content);
    });
  }
  function tabindicator_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tabIndicator = $$value;
      $$invalidate(14, tabIndicator);
    });
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(12, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("tab" in $$new_props)
      $$invalidate(26, tabId = $$new_props.tab);
    if ("ripple" in $$new_props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("stacked" in $$new_props)
      $$invalidate(4, stacked = $$new_props.stacked);
    if ("minWidth" in $$new_props)
      $$invalidate(5, minWidth = $$new_props.minWidth);
    if ("indicatorSpanOnlyContent" in $$new_props)
      $$invalidate(6, indicatorSpanOnlyContent = $$new_props.indicatorSpanOnlyContent);
    if ("href" in $$new_props)
      $$invalidate(7, href = $$new_props.href);
    if ("content$use" in $$new_props)
      $$invalidate(8, content$use = $$new_props.content$use);
    if ("content$class" in $$new_props)
      $$invalidate(9, content$class = $$new_props.content$class);
    if ("component" in $$new_props)
      $$invalidate(10, component = $$new_props.component);
    if ("tag" in $$new_props)
      $$invalidate(11, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(37, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCTabFoundation,
    onMount,
    setContext,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    Ripple: dist_default,
    SmuiElement: SmuiElement_default,
    TabIndicator: dist_default2,
    forwardEvents,
    use,
    className,
    style,
    tabId,
    ripple,
    stacked,
    minWidth,
    indicatorSpanOnlyContent,
    href,
    content$use,
    content$class,
    element: element2,
    instance,
    content,
    tabIndicator,
    internalClasses,
    internalStyles,
    internalAttrs,
    focusOnActivate,
    active,
    forceAccessible,
    component,
    tag,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    addAttr,
    handleClick,
    activate,
    deactivate,
    focus,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("tabId" in $$props)
      $$invalidate(26, tabId = $$new_props.tabId);
    if ("ripple" in $$props)
      $$invalidate(3, ripple = $$new_props.ripple);
    if ("stacked" in $$props)
      $$invalidate(4, stacked = $$new_props.stacked);
    if ("minWidth" in $$props)
      $$invalidate(5, minWidth = $$new_props.minWidth);
    if ("indicatorSpanOnlyContent" in $$props)
      $$invalidate(6, indicatorSpanOnlyContent = $$new_props.indicatorSpanOnlyContent);
    if ("href" in $$props)
      $$invalidate(7, href = $$new_props.href);
    if ("content$use" in $$props)
      $$invalidate(8, content$use = $$new_props.content$use);
    if ("content$class" in $$props)
      $$invalidate(9, content$class = $$new_props.content$class);
    if ("element" in $$props)
      $$invalidate(12, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(31, instance = $$new_props.instance);
    if ("content" in $$props)
      $$invalidate(13, content = $$new_props.content);
    if ("tabIndicator" in $$props)
      $$invalidate(14, tabIndicator = $$new_props.tabIndicator);
    if ("internalClasses" in $$props)
      $$invalidate(15, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(16, internalStyles = $$new_props.internalStyles);
    if ("internalAttrs" in $$props)
      $$invalidate(17, internalAttrs = $$new_props.internalAttrs);
    if ("focusOnActivate" in $$props)
      $$invalidate(38, focusOnActivate = $$new_props.focusOnActivate);
    if ("active" in $$props)
      $$invalidate(18, active = $$new_props.active);
    if ("forceAccessible" in $$props)
      $$invalidate(19, forceAccessible = $$new_props.forceAccessible);
    if ("component" in $$props)
      $$invalidate(10, component = $$new_props.component);
    if ("tag" in $$props)
      $$invalidate(11, tag = $$new_props.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[1] & /*instance*/
    1) {
      $:
        if (instance) {
          instance.setFocusOnActivate(focusOnActivate);
        }
    }
  };
  return [
    use,
    className,
    style,
    ripple,
    stacked,
    minWidth,
    indicatorSpanOnlyContent,
    href,
    content$use,
    content$class,
    component,
    tag,
    element2,
    content,
    tabIndicator,
    internalClasses,
    internalStyles,
    internalAttrs,
    active,
    forceAccessible,
    forwardEvents,
    addClass,
    removeClass,
    addStyle,
    handleClick,
    $$restProps,
    tabId,
    activate,
    deactivate,
    focus,
    getElement,
    instance,
    slots,
    tabindicator_binding,
    span0_binding,
    tabindicator_binding_1,
    switch_instance_binding,
    $$scope
  ];
}
var Tab = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_12,
      create_fragment2,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        style: 2,
        tab: 26,
        ripple: 3,
        stacked: 4,
        minWidth: 5,
        indicatorSpanOnlyContent: 6,
        href: 7,
        content$use: 8,
        content$class: 9,
        component: 10,
        tag: 11,
        activate: 27,
        deactivate: 28,
        focus: 29,
        getElement: 30
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Tab",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tab() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tab(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stacked() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stacked(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minWidth() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minWidth(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indicatorSpanOnlyContent() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indicatorSpanOnlyContent(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get content$use() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set content$use(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get content$class() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set content$class(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error_1("<Tab>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activate() {
    return this.$$.ctx[27];
  }
  set activate(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deactivate() {
    return this.$$.ctx[28];
  }
  set deactivate(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[29];
  }
  set focus(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[30];
  }
  set getElement(value) {
    throw new Error_1("<Tab>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Tab_default = Tab;

// node_modules/@smui/tab/dist/index.js
var dist_default3 = Tab_default;
export {
  CommonIcon_default as Icon,
  CommonLabel_default as Label,
  dist_default3 as default
};
//# sourceMappingURL=@smui_tab.js.map
