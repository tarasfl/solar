import {
  classAdderBuilder
} from "./chunk-WZFCNKGK.js";
import "./chunk-J7F4NX7A.js";
import {
  MDCListFoundation
} from "./chunk-4LYXOZ3I.js";
import {
  dist_default
} from "./chunk-BOPCK6KS.js";
import "./chunk-CTXZTH3U.js";
import {
  SmuiElement_default
} from "./chunk-MMI7NAQ6.js";
import "./chunk-W4OU4FMO.js";
import "./chunk-Y3XZ6UIT.js";
import {
  classMap,
  dispatch,
  forwardEventsBuilder,
  useActions
} from "./chunk-GGS237SP.js";
import "./chunk-CDAXLAUX.js";
import "./chunk-OYKM6SV3.js";
import "./chunk-7EMQ2XW3.js";
import "./chunk-ZJSI6DXQ.js";
import {
  ponyfill_exports
} from "./chunk-RJY55RCX.js";
import "./chunk-2YJBFMWA.js";
import "./chunk-FBWM3HWJ.js";
import "./chunk-ZB6PEJPW.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  compute_rest_props,
  construct_svelte_component_dev,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  mount_component,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots
} from "./chunk-NMMN3PC6.js";
import "./chunk-4DGM7FRE.js";
import "./chunk-7U33LM2Z.js";

// node_modules/@smui/list/dist/List.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[42].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[44],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[44],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[44]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[44],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <svelte:component   this={component}   {tag}   bind:this={element}   use={[forwardEvents, ...use]}   class={classMap({     [className]: true,     'mdc-deprecated-list': true,     'mdc-deprecated-list--non-interactive': nonInteractive,     'mdc-deprecated-list--dense': dense,     'mdc-deprecated-list--textual-list': textualList,     'mdc-deprecated-list--avatar-list': avatarList || selectionDialog,     'mdc-deprecated-list--icon-list': iconList,     'mdc-deprecated-list--image-list': imageList,     'mdc-deprecated-list--thumbnail-list': thumbnailList,     'mdc-deprecated-list--video-list': videoList,     'mdc-deprecated-list--two-line': twoLine,     'smui-list--three-line': threeLine && !twoLine,   })}   {role}   on:keydown={handleKeydown}   on:focusin={handleFocusin}   on:focusout={handleFocusout}   on:click={handleClick}   on:SMUIListItem:mount={handleItemMount}   on:SMUIListItem:unmount={handleItemUnmount}   on:SMUI:action={handleAction}   {...$$restProps} >",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { tag: (
      /*tag*/
      ctx[13]
    ) },
    {
      use: [
        /*forwardEvents*/
        ctx[16],
        .../*use*/
        ctx[0]
      ]
    },
    {
      class: classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-deprecated-list": true,
        "mdc-deprecated-list--non-interactive": (
          /*nonInteractive*/
          ctx[2]
        ),
        "mdc-deprecated-list--dense": (
          /*dense*/
          ctx[3]
        ),
        "mdc-deprecated-list--textual-list": (
          /*textualList*/
          ctx[4]
        ),
        "mdc-deprecated-list--avatar-list": (
          /*avatarList*/
          ctx[5] || /*selectionDialog*/
          ctx[17]
        ),
        "mdc-deprecated-list--icon-list": (
          /*iconList*/
          ctx[6]
        ),
        "mdc-deprecated-list--image-list": (
          /*imageList*/
          ctx[7]
        ),
        "mdc-deprecated-list--thumbnail-list": (
          /*thumbnailList*/
          ctx[8]
        ),
        "mdc-deprecated-list--video-list": (
          /*videoList*/
          ctx[9]
        ),
        "mdc-deprecated-list--two-line": (
          /*twoLine*/
          ctx[10]
        ),
        "smui-list--three-line": (
          /*threeLine*/
          ctx[11] && !/*twoLine*/
          ctx[10]
        )
      })
    },
    { role: (
      /*role*/
      ctx[15]
    ) },
    /*$$restProps*/
    ctx[25]
  ];
  var switch_value = (
    /*component*/
    ctx[12]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty[0] & /*tag, forwardEvents, use, className, nonInteractive, dense, textualList, avatarList, selectionDialog, iconList, imageList, thumbnailList, videoList, twoLine, threeLine, role, $$restProps*/
    33796095) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*tag*/
        8192 && { tag: (
          /*tag*/
          ctx2[13]
        ) },
        dirty[0] & /*forwardEvents, use*/
        65537 && {
          use: [
            /*forwardEvents*/
            ctx2[16],
            .../*use*/
            ctx2[0]
          ]
        },
        dirty[0] & /*className, nonInteractive, dense, textualList, avatarList, selectionDialog, iconList, imageList, thumbnailList, videoList, twoLine, threeLine*/
        135166 && {
          class: classMap({
            [
              /*className*/
              ctx2[1]
            ]: true,
            "mdc-deprecated-list": true,
            "mdc-deprecated-list--non-interactive": (
              /*nonInteractive*/
              ctx2[2]
            ),
            "mdc-deprecated-list--dense": (
              /*dense*/
              ctx2[3]
            ),
            "mdc-deprecated-list--textual-list": (
              /*textualList*/
              ctx2[4]
            ),
            "mdc-deprecated-list--avatar-list": (
              /*avatarList*/
              ctx2[5] || /*selectionDialog*/
              ctx2[17]
            ),
            "mdc-deprecated-list--icon-list": (
              /*iconList*/
              ctx2[6]
            ),
            "mdc-deprecated-list--image-list": (
              /*imageList*/
              ctx2[7]
            ),
            "mdc-deprecated-list--thumbnail-list": (
              /*thumbnailList*/
              ctx2[8]
            ),
            "mdc-deprecated-list--video-list": (
              /*videoList*/
              ctx2[9]
            ),
            "mdc-deprecated-list--two-line": (
              /*twoLine*/
              ctx2[10]
            ),
            "smui-list--three-line": (
              /*threeLine*/
              ctx2[11] && !/*twoLine*/
              ctx2[10]
            )
          })
        },
        dirty[0] & /*role*/
        32768 && { role: (
          /*role*/
          ctx2[15]
        ) },
        dirty[0] & /*$$restProps*/
        33554432 && get_spread_object(
          /*$$restProps*/
          ctx2[25]
        )
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[43](switch_instance);
    switch_instance.$on(
      "keydown",
      /*handleKeydown*/
      ctx[20]
    );
    switch_instance.$on(
      "focusin",
      /*handleFocusin*/
      ctx[21]
    );
    switch_instance.$on(
      "focusout",
      /*handleFocusout*/
      ctx[22]
    );
    switch_instance.$on(
      "click",
      /*handleClick*/
      ctx[23]
    );
    switch_instance.$on(
      "SMUIListItem:mount",
      /*handleItemMount*/
      ctx[18]
    );
    switch_instance.$on(
      "SMUIListItem:unmount",
      /*handleItemUnmount*/
      ctx[19]
    );
    switch_instance.$on(
      "SMUI:action",
      /*handleAction*/
      ctx[24]
    );
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*component*/
      4096 && switch_value !== (switch_value = /*component*/
      ctx2[12])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          ctx2[43](switch_instance);
          switch_instance.$on(
            "keydown",
            /*handleKeydown*/
            ctx2[20]
          );
          switch_instance.$on(
            "focusin",
            /*handleFocusin*/
            ctx2[21]
          );
          switch_instance.$on(
            "focusout",
            /*handleFocusout*/
            ctx2[22]
          );
          switch_instance.$on(
            "click",
            /*handleClick*/
            ctx2[23]
          );
          switch_instance.$on(
            "SMUIListItem:mount",
            /*handleItemMount*/
            ctx2[18]
          );
          switch_instance.$on(
            "SMUIListItem:unmount",
            /*handleItemUnmount*/
            ctx2[19]
          );
          switch_instance.$on(
            "SMUI:action",
            /*handleAction*/
            ctx2[24]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*tag, forwardEvents, use, className, nonInteractive, dense, textualList, avatarList, selectionDialog, iconList, imageList, thumbnailList, videoList, twoLine, threeLine, role, $$restProps*/
        33796095 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*tag*/
          8192 && { tag: (
            /*tag*/
            ctx2[13]
          ) },
          dirty[0] & /*forwardEvents, use*/
          65537 && {
            use: [
              /*forwardEvents*/
              ctx2[16],
              .../*use*/
              ctx2[0]
            ]
          },
          dirty[0] & /*className, nonInteractive, dense, textualList, avatarList, selectionDialog, iconList, imageList, thumbnailList, videoList, twoLine, threeLine*/
          135166 && {
            class: classMap({
              [
                /*className*/
                ctx2[1]
              ]: true,
              "mdc-deprecated-list": true,
              "mdc-deprecated-list--non-interactive": (
                /*nonInteractive*/
                ctx2[2]
              ),
              "mdc-deprecated-list--dense": (
                /*dense*/
                ctx2[3]
              ),
              "mdc-deprecated-list--textual-list": (
                /*textualList*/
                ctx2[4]
              ),
              "mdc-deprecated-list--avatar-list": (
                /*avatarList*/
                ctx2[5] || /*selectionDialog*/
                ctx2[17]
              ),
              "mdc-deprecated-list--icon-list": (
                /*iconList*/
                ctx2[6]
              ),
              "mdc-deprecated-list--image-list": (
                /*imageList*/
                ctx2[7]
              ),
              "mdc-deprecated-list--thumbnail-list": (
                /*thumbnailList*/
                ctx2[8]
              ),
              "mdc-deprecated-list--video-list": (
                /*videoList*/
                ctx2[9]
              ),
              "mdc-deprecated-list--two-line": (
                /*twoLine*/
                ctx2[10]
              ),
              "smui-list--three-line": (
                /*threeLine*/
                ctx2[11] && !/*twoLine*/
                ctx2[10]
              )
            })
          },
          dirty[0] & /*role*/
          32768 && { role: (
            /*role*/
            ctx2[15]
          ) },
          dirty[0] & /*$$restProps*/
          33554432 && get_spread_object(
            /*$$restProps*/
            ctx2[25]
          )
        ]) : {};
        if (dirty[1] & /*$$scope*/
        8192) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx[43](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "nonInteractive",
    "dense",
    "textualList",
    "avatarList",
    "iconList",
    "imageList",
    "thumbnailList",
    "videoList",
    "twoLine",
    "threeLine",
    "vertical",
    "wrapFocus",
    "singleSelection",
    "disabledItemsFocusable",
    "selectedIndex",
    "radioList",
    "checkList",
    "hasTypeahead",
    "component",
    "tag",
    "layout",
    "setEnabled",
    "getTypeaheadInProgress",
    "getSelectedIndex",
    "getFocusedItemIndex",
    "focusItemAtIndex",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("List", slots, ["default"]);
  var _a;
  const { closest, matches } = ponyfill_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { nonInteractive = false } = $$props;
  let { dense = false } = $$props;
  let { textualList = false } = $$props;
  let { avatarList = false } = $$props;
  let { iconList = false } = $$props;
  let { imageList = false } = $$props;
  let { thumbnailList = false } = $$props;
  let { videoList = false } = $$props;
  let { twoLine = false } = $$props;
  let { threeLine = false } = $$props;
  let { vertical = true } = $$props;
  let { wrapFocus = (_a = getContext("SMUI:list:wrapFocus")) !== null && _a !== void 0 ? _a : false } = $$props;
  let { singleSelection = false } = $$props;
  let { disabledItemsFocusable = false } = $$props;
  let { selectedIndex = -1 } = $$props;
  let { radioList = false } = $$props;
  let { checkList = false } = $$props;
  let { hasTypeahead = false } = $$props;
  let element2;
  let instance5;
  let items = [];
  let role = getContext("SMUI:list:role");
  let nav = getContext("SMUI:list:nav");
  const itemAccessorMap = /* @__PURE__ */ new WeakMap();
  let selectionDialog = getContext("SMUI:dialog:selection");
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let { component = SmuiElement_default } = $$props;
  let { tag = component === SmuiElement_default ? nav ? "nav" : "ul" : void 0 } = $$props;
  setContext("SMUI:list:nonInteractive", nonInteractive);
  setContext("SMUI:separator:context", "list");
  if (!role) {
    if (singleSelection) {
      role = "listbox";
      setContext("SMUI:list:item:role", "option");
    } else if (radioList) {
      role = "radiogroup";
      setContext("SMUI:list:item:role", "radio");
    } else if (checkList) {
      role = "group";
      setContext("SMUI:list:item:role", "checkbox");
    } else {
      role = "list";
      setContext("SMUI:list:item:role", void 0);
    }
  }
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  onMount(() => {
    $$invalidate(41, instance5 = new MDCListFoundation({
      addClassForElementIndex,
      focusItemAtIndex,
      getAttributeForElementIndex: (index, name) => {
        var _a2, _b;
        return (_b = (_a2 = getOrderedList()[index]) === null || _a2 === void 0 ? void 0 : _a2.getAttr(name)) !== null && _b !== void 0 ? _b : null;
      },
      getFocusedElementIndex: () => document.activeElement ? getOrderedList().map((accessor2) => accessor2.element).indexOf(document.activeElement) : -1,
      getListItemCount: () => items.length,
      getPrimaryTextAtIndex,
      hasCheckboxAtIndex: (index) => {
        var _a2, _b;
        return (_b = (_a2 = getOrderedList()[index]) === null || _a2 === void 0 ? void 0 : _a2.hasCheckbox) !== null && _b !== void 0 ? _b : false;
      },
      hasRadioAtIndex: (index) => {
        var _a2, _b;
        return (_b = (_a2 = getOrderedList()[index]) === null || _a2 === void 0 ? void 0 : _a2.hasRadio) !== null && _b !== void 0 ? _b : false;
      },
      isCheckboxCheckedAtIndex: (index) => {
        var _a2;
        const listItem = getOrderedList()[index];
        return (_a2 = (listItem === null || listItem === void 0 ? void 0 : listItem.hasCheckbox) && listItem.checked) !== null && _a2 !== void 0 ? _a2 : false;
      },
      isFocusInsideList: () => element2 != null && getElement() !== document.activeElement && getElement().contains(document.activeElement),
      isRootFocused: () => element2 != null && document.activeElement === getElement(),
      listItemAtIndexHasClass,
      notifyAction: (index) => {
        $$invalidate(26, selectedIndex = index);
        if (element2 != null) {
          dispatch(getElement(), "SMUIList:action", { index }, void 0, true);
        }
      },
      notifySelectionChange: (changedIndices) => {
        if (element2 != null) {
          dispatch(getElement(), "SMUIList:selectionChange", { changedIndices });
        }
      },
      removeClassForElementIndex,
      setAttributeForElementIndex,
      setCheckedCheckboxOrRadioAtIndex: (index, isChecked) => {
        getOrderedList()[index].checked = isChecked;
      },
      setTabIndexForListItemChildren: (listItemIndex, tabIndexValue) => {
        const listItem = getOrderedList()[listItemIndex];
        const selector = "button:not(:disabled), a";
        Array.prototype.forEach.call(listItem.element.querySelectorAll(selector), (el) => {
          el.setAttribute("tabindex", tabIndexValue);
        });
      }
    }));
    const accessor = {
      get element() {
        return getElement();
      },
      get items() {
        return items;
      },
      get typeaheadInProgress() {
        return instance5.isTypeaheadInProgress();
      },
      typeaheadMatchItem(nextChar, startingIndex) {
        return instance5.typeaheadMatchItem(
          nextChar,
          startingIndex,
          /** skipFocus */
          true
        );
      },
      getOrderedList,
      focusItemAtIndex,
      addClassForElementIndex,
      removeClassForElementIndex,
      setAttributeForElementIndex,
      removeAttributeForElementIndex,
      getAttributeFromElementIndex,
      getPrimaryTextAtIndex
    };
    dispatch(getElement(), "SMUIList:mount", accessor);
    instance5.init();
    instance5.layout();
    return () => {
      instance5.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function handleItemMount(event) {
    items.push(event.detail);
    itemAccessorMap.set(event.detail.element, event.detail);
    if (singleSelection && event.detail.selected) {
      $$invalidate(26, selectedIndex = getListItemIndex(event.detail.element));
    }
    event.stopPropagation();
  }
  function handleItemUnmount(event) {
    var _a2;
    const idx = (_a2 = event.detail && items.indexOf(event.detail)) !== null && _a2 !== void 0 ? _a2 : -1;
    if (idx !== -1) {
      items.splice(idx, 1);
      items = items;
      itemAccessorMap.delete(event.detail.element);
    }
    event.stopPropagation();
  }
  function handleKeydown(event) {
    if (instance5 && event.target) {
      instance5.handleKeydown(event, event.target.classList.contains("mdc-deprecated-list-item"), getListItemIndex(event.target));
    }
  }
  function handleFocusin(event) {
    if (instance5 && event.target) {
      instance5.handleFocusIn(getListItemIndex(event.target));
    }
  }
  function handleFocusout(event) {
    if (instance5 && event.target) {
      instance5.handleFocusOut(getListItemIndex(event.target));
    }
  }
  function handleClick(event) {
    if (instance5 && event.target) {
      instance5.handleClick(getListItemIndex(event.target), !matches(event.target, 'input[type="checkbox"], input[type="radio"]'), event);
    }
  }
  function handleAction(event) {
    if (radioList || checkList) {
      const index = getListItemIndex(event.target);
      if (index !== -1) {
        const item = getOrderedList()[index];
        if (item && (radioList && !item.checked || checkList)) {
          if (!matches(event.detail.target, 'input[type="checkbox"], input[type="radio"]')) {
            item.checked = !item.checked;
          }
          item.activateRipple();
          window.requestAnimationFrame(() => {
            item.deactivateRipple();
          });
        }
      }
    }
  }
  function getOrderedList() {
    if (element2 == null) {
      return [];
    }
    return [...getElement().children].map((element3) => itemAccessorMap.get(element3)).filter((accessor) => accessor && accessor._smui_list_item_accessor);
  }
  function listItemAtIndexHasClass(index, className2) {
    var _a2;
    const accessor = getOrderedList()[index];
    return (_a2 = accessor && accessor.hasClass(className2)) !== null && _a2 !== void 0 ? _a2 : false;
  }
  function addClassForElementIndex(index, className2) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addClass(className2);
  }
  function removeClassForElementIndex(index, className2) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeClass(className2);
  }
  function setAttributeForElementIndex(index, name, value) {
    const accessor = getOrderedList()[index];
    accessor && accessor.addAttr(name, value);
  }
  function removeAttributeForElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    accessor && accessor.removeAttr(name);
  }
  function getAttributeFromElementIndex(index, name) {
    const accessor = getOrderedList()[index];
    if (accessor) {
      return accessor.getAttr(name);
    } else {
      return null;
    }
  }
  function getPrimaryTextAtIndex(index) {
    var _a2;
    const accessor = getOrderedList()[index];
    return (_a2 = accessor && accessor.getPrimaryText()) !== null && _a2 !== void 0 ? _a2 : "";
  }
  function getListItemIndex(element3) {
    const nearestParent = closest(element3, ".mdc-deprecated-list-item, .mdc-deprecated-list");
    if (nearestParent && matches(nearestParent, ".mdc-deprecated-list-item")) {
      return getOrderedList().map((item) => item === null || item === void 0 ? void 0 : item.element).indexOf(nearestParent);
    }
    return -1;
  }
  function layout() {
    return instance5.layout();
  }
  function setEnabled(itemIndex, isEnabled) {
    return instance5.setEnabled(itemIndex, isEnabled);
  }
  function getTypeaheadInProgress() {
    return instance5.isTypeaheadInProgress();
  }
  function getSelectedIndex() {
    return instance5.getSelectedIndex();
  }
  function getFocusedItemIndex() {
    return instance5.getFocusedItemIndex();
  }
  function focusItemAtIndex(index) {
    const accessor = getOrderedList()[index];
    accessor && "focus" in accessor.element && accessor.element.focus();
  }
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(14, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("nonInteractive" in $$new_props)
      $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
    if ("dense" in $$new_props)
      $$invalidate(3, dense = $$new_props.dense);
    if ("textualList" in $$new_props)
      $$invalidate(4, textualList = $$new_props.textualList);
    if ("avatarList" in $$new_props)
      $$invalidate(5, avatarList = $$new_props.avatarList);
    if ("iconList" in $$new_props)
      $$invalidate(6, iconList = $$new_props.iconList);
    if ("imageList" in $$new_props)
      $$invalidate(7, imageList = $$new_props.imageList);
    if ("thumbnailList" in $$new_props)
      $$invalidate(8, thumbnailList = $$new_props.thumbnailList);
    if ("videoList" in $$new_props)
      $$invalidate(9, videoList = $$new_props.videoList);
    if ("twoLine" in $$new_props)
      $$invalidate(10, twoLine = $$new_props.twoLine);
    if ("threeLine" in $$new_props)
      $$invalidate(11, threeLine = $$new_props.threeLine);
    if ("vertical" in $$new_props)
      $$invalidate(27, vertical = $$new_props.vertical);
    if ("wrapFocus" in $$new_props)
      $$invalidate(28, wrapFocus = $$new_props.wrapFocus);
    if ("singleSelection" in $$new_props)
      $$invalidate(29, singleSelection = $$new_props.singleSelection);
    if ("disabledItemsFocusable" in $$new_props)
      $$invalidate(30, disabledItemsFocusable = $$new_props.disabledItemsFocusable);
    if ("selectedIndex" in $$new_props)
      $$invalidate(26, selectedIndex = $$new_props.selectedIndex);
    if ("radioList" in $$new_props)
      $$invalidate(31, radioList = $$new_props.radioList);
    if ("checkList" in $$new_props)
      $$invalidate(32, checkList = $$new_props.checkList);
    if ("hasTypeahead" in $$new_props)
      $$invalidate(33, hasTypeahead = $$new_props.hasTypeahead);
    if ("component" in $$new_props)
      $$invalidate(12, component = $$new_props.component);
    if ("tag" in $$new_props)
      $$invalidate(13, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(44, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCListFoundation,
    ponyfill: ponyfill_exports,
    onMount,
    onDestroy,
    getContext,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    dispatch,
    SmuiElement: SmuiElement_default,
    closest,
    matches,
    forwardEvents,
    use,
    className,
    nonInteractive,
    dense,
    textualList,
    avatarList,
    iconList,
    imageList,
    thumbnailList,
    videoList,
    twoLine,
    threeLine,
    vertical,
    wrapFocus,
    singleSelection,
    disabledItemsFocusable,
    selectedIndex,
    radioList,
    checkList,
    hasTypeahead,
    element: element2,
    instance: instance5,
    items,
    role,
    nav,
    itemAccessorMap,
    selectionDialog,
    addLayoutListener,
    removeLayoutListener,
    component,
    tag,
    handleItemMount,
    handleItemUnmount,
    handleKeydown,
    handleFocusin,
    handleFocusout,
    handleClick,
    handleAction,
    getOrderedList,
    listItemAtIndexHasClass,
    addClassForElementIndex,
    removeClassForElementIndex,
    setAttributeForElementIndex,
    removeAttributeForElementIndex,
    getAttributeFromElementIndex,
    getPrimaryTextAtIndex,
    getListItemIndex,
    layout,
    setEnabled,
    getTypeaheadInProgress,
    getSelectedIndex,
    getFocusedItemIndex,
    focusItemAtIndex,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("nonInteractive" in $$props)
      $$invalidate(2, nonInteractive = $$new_props.nonInteractive);
    if ("dense" in $$props)
      $$invalidate(3, dense = $$new_props.dense);
    if ("textualList" in $$props)
      $$invalidate(4, textualList = $$new_props.textualList);
    if ("avatarList" in $$props)
      $$invalidate(5, avatarList = $$new_props.avatarList);
    if ("iconList" in $$props)
      $$invalidate(6, iconList = $$new_props.iconList);
    if ("imageList" in $$props)
      $$invalidate(7, imageList = $$new_props.imageList);
    if ("thumbnailList" in $$props)
      $$invalidate(8, thumbnailList = $$new_props.thumbnailList);
    if ("videoList" in $$props)
      $$invalidate(9, videoList = $$new_props.videoList);
    if ("twoLine" in $$props)
      $$invalidate(10, twoLine = $$new_props.twoLine);
    if ("threeLine" in $$props)
      $$invalidate(11, threeLine = $$new_props.threeLine);
    if ("vertical" in $$props)
      $$invalidate(27, vertical = $$new_props.vertical);
    if ("wrapFocus" in $$props)
      $$invalidate(28, wrapFocus = $$new_props.wrapFocus);
    if ("singleSelection" in $$props)
      $$invalidate(29, singleSelection = $$new_props.singleSelection);
    if ("disabledItemsFocusable" in $$props)
      $$invalidate(30, disabledItemsFocusable = $$new_props.disabledItemsFocusable);
    if ("selectedIndex" in $$props)
      $$invalidate(26, selectedIndex = $$new_props.selectedIndex);
    if ("radioList" in $$props)
      $$invalidate(31, radioList = $$new_props.radioList);
    if ("checkList" in $$props)
      $$invalidate(32, checkList = $$new_props.checkList);
    if ("hasTypeahead" in $$props)
      $$invalidate(33, hasTypeahead = $$new_props.hasTypeahead);
    if ("element" in $$props)
      $$invalidate(14, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(41, instance5 = $$new_props.instance);
    if ("items" in $$props)
      items = $$new_props.items;
    if ("role" in $$props)
      $$invalidate(15, role = $$new_props.role);
    if ("nav" in $$props)
      nav = $$new_props.nav;
    if ("selectionDialog" in $$props)
      $$invalidate(17, selectionDialog = $$new_props.selectionDialog);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("component" in $$props)
      $$invalidate(12, component = $$new_props.component);
    if ("tag" in $$props)
      $$invalidate(13, tag = $$new_props.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*vertical*/
    134217728 | $$self.$$.dirty[1] & /*instance*/
    1024) {
      $:
        if (instance5) {
          instance5.setVerticalOrientation(vertical);
        }
    }
    if ($$self.$$.dirty[0] & /*wrapFocus*/
    268435456 | $$self.$$.dirty[1] & /*instance*/
    1024) {
      $:
        if (instance5) {
          instance5.setWrapFocus(wrapFocus);
        }
    }
    if ($$self.$$.dirty[1] & /*instance, hasTypeahead*/
    1028) {
      $:
        if (instance5) {
          instance5.setHasTypeahead(hasTypeahead);
        }
    }
    if ($$self.$$.dirty[0] & /*singleSelection*/
    536870912 | $$self.$$.dirty[1] & /*instance*/
    1024) {
      $:
        if (instance5) {
          instance5.setSingleSelection(singleSelection);
        }
    }
    if ($$self.$$.dirty[0] & /*disabledItemsFocusable*/
    1073741824 | $$self.$$.dirty[1] & /*instance*/
    1024) {
      $:
        if (instance5) {
          instance5.setDisabledItemsFocusable(disabledItemsFocusable);
        }
    }
    if ($$self.$$.dirty[0] & /*singleSelection, selectedIndex*/
    603979776 | $$self.$$.dirty[1] & /*instance*/
    1024) {
      $:
        if (instance5 && singleSelection && getSelectedIndex() !== selectedIndex) {
          instance5.setSelectedIndex(selectedIndex);
        }
    }
  };
  return [
    use,
    className,
    nonInteractive,
    dense,
    textualList,
    avatarList,
    iconList,
    imageList,
    thumbnailList,
    videoList,
    twoLine,
    threeLine,
    component,
    tag,
    element2,
    role,
    forwardEvents,
    selectionDialog,
    handleItemMount,
    handleItemUnmount,
    handleKeydown,
    handleFocusin,
    handleFocusout,
    handleClick,
    handleAction,
    $$restProps,
    selectedIndex,
    vertical,
    wrapFocus,
    singleSelection,
    disabledItemsFocusable,
    radioList,
    checkList,
    hasTypeahead,
    layout,
    setEnabled,
    getTypeaheadInProgress,
    getSelectedIndex,
    getFocusedItemIndex,
    focusItemAtIndex,
    getElement,
    instance5,
    slots,
    switch_instance_binding,
    $$scope
  ];
}
var List = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        nonInteractive: 2,
        dense: 3,
        textualList: 4,
        avatarList: 5,
        iconList: 6,
        imageList: 7,
        thumbnailList: 8,
        videoList: 9,
        twoLine: 10,
        threeLine: 11,
        vertical: 27,
        wrapFocus: 28,
        singleSelection: 29,
        disabledItemsFocusable: 30,
        selectedIndex: 26,
        radioList: 31,
        checkList: 32,
        hasTypeahead: 33,
        component: 12,
        tag: 13,
        layout: 34,
        setEnabled: 35,
        getTypeaheadInProgress: 36,
        getSelectedIndex: 37,
        getFocusedItemIndex: 38,
        focusItemAtIndex: 39,
        getElement: 40
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "List",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonInteractive() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonInteractive(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dense() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dense(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get textualList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set textualList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get avatarList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set avatarList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get iconList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set iconList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get imageList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set imageList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get thumbnailList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set thumbnailList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get videoList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set videoList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get twoLine() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set twoLine(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get threeLine() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set threeLine(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get vertical() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set vertical(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapFocus() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapFocus(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get singleSelection() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set singleSelection(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabledItemsFocusable() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabledItemsFocusable(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedIndex() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get radioList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set radioList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checkList() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checkList(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hasTypeahead() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hasTypeahead(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[34];
  }
  set layout(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setEnabled() {
    return this.$$.ctx[35];
  }
  set setEnabled(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getTypeaheadInProgress() {
    return this.$$.ctx[36];
  }
  set getTypeaheadInProgress(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSelectedIndex() {
    return this.$$.ctx[37];
  }
  set getSelectedIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getFocusedItemIndex() {
    return this.$$.ctx[38];
  }
  set getFocusedItemIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focusItemAtIndex() {
    return this.$$.ctx[39];
  }
  set focusItemAtIndex(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[40];
  }
  set getElement(value) {
    throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var List_default = List;

// node_modules/@smui/list/dist/Item.svelte
var file = "node_modules/@smui/list/dist/Item.svelte";
function create_if_block(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "mdc-deprecated-list-item__ripple");
      add_location(span, file, 58, 15, 1774);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(59:3) {#if ripple}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*ripple*/
    ctx[7] && create_if_block(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[34].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[37],
    null
  );
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (
        /*ripple*/
        ctx2[7]
      ) {
        if (if_block) {
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        64)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[37],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[37]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[37],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(1:0) <svelte:component   this={component}   {tag}   bind:this={element}   use={[     ...(nonInteractive       ? []       : [           [             Ripple,             {               ripple: !input,               unbounded: false,               color:                 (activated || selected) && color == null ? 'primary' : color,               disabled,               addClass,               removeClass,               addStyle,             },           ],         ]),     forwardEvents,     ...use,   ]}   class={classMap({     [className]: true,     'mdc-deprecated-list-item': !wrapper,     'mdc-deprecated-list-item__wrapper': wrapper,     'mdc-deprecated-list-item--activated': activated,     'mdc-deprecated-list-item--selected': selected,     'mdc-deprecated-list-item--disabled': disabled,     'mdc-menu-item--selected': !nav && role === 'menuitem' && selected,     'smui-menu-item--non-interactive': nonInteractive,     ...internalClasses,   })}   style={Object.entries(internalStyles)     .map(([name, value]) => `${name}: ${value};`)     .concat([style])     .join(' ')}   {...nav && activated ? { 'aria-current': 'page' } : {}}   {...!nav || wrapper ? { role } : {}}   {...!nav && role === 'option'     ? { 'aria-selected': selected ? 'true' : 'false' }     : {}}   {...!nav && (role === 'radio' || role === 'checkbox')     ? { 'aria-checked': input && input.checked ? 'true' : 'false' }     : {}}   {...!nav ? { 'aria-disabled': disabled ? 'true' : 'false' } : {}}   data-menu-item-skip-restore-focus={skipRestoreFocus || undefined}   {tabindex}   on:click={action}   on:keydown={handleKeydown}   on:SMUIGenericInput:mount={handleInputMount}   on:SMUIGenericInput:unmount={() => (input = undefined)}   {href}   {...internalAttrs}   {...$$restProps}   >",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { tag: (
      /*tag*/
      ctx[14]
    ) },
    {
      use: [
        .../*nonInteractive*/
        ctx[6] ? [] : [
          [
            dist_default,
            {
              ripple: !/*input*/
              ctx[16],
              unbounded: false,
              color: (
                /*activated*/
                (ctx[1] || /*selected*/
                ctx[0]) && /*color*/
                ctx[5] == null ? "primary" : (
                  /*color*/
                  ctx[5]
                )
              ),
              disabled: (
                /*disabled*/
                ctx[10]
              ),
              addClass: (
                /*addClass*/
                ctx[24]
              ),
              removeClass: (
                /*removeClass*/
                ctx[25]
              ),
              addStyle: (
                /*addStyle*/
                ctx[26]
              )
            }
          ]
        ],
        /*forwardEvents*/
        ctx[22],
        .../*use*/
        ctx[2]
      ]
    },
    {
      class: classMap({
        [
          /*className*/
          ctx[3]
        ]: true,
        "mdc-deprecated-list-item": !/*wrapper*/
        ctx[8],
        "mdc-deprecated-list-item__wrapper": (
          /*wrapper*/
          ctx[8]
        ),
        "mdc-deprecated-list-item--activated": (
          /*activated*/
          ctx[1]
        ),
        "mdc-deprecated-list-item--selected": (
          /*selected*/
          ctx[0]
        ),
        "mdc-deprecated-list-item--disabled": (
          /*disabled*/
          ctx[10]
        ),
        "mdc-menu-item--selected": !/*nav*/
        ctx[23] && /*role*/
        ctx[9] === "menuitem" && /*selected*/
        ctx[0],
        "smui-menu-item--non-interactive": (
          /*nonInteractive*/
          ctx[6]
        ),
        .../*internalClasses*/
        ctx[18]
      })
    },
    {
      style: Object.entries(
        /*internalStyles*/
        ctx[19]
      ).map(func).concat([
        /*style*/
        ctx[4]
      ]).join(" ")
    },
    /*nav*/
    ctx[23] && /*activated*/
    ctx[1] ? { "aria-current": "page" } : {},
    !/*nav*/
    ctx[23] || /*wrapper*/
    ctx[8] ? { role: (
      /*role*/
      ctx[9]
    ) } : {},
    !/*nav*/
    ctx[23] && /*role*/
    ctx[9] === "option" ? {
      "aria-selected": (
        /*selected*/
        ctx[0] ? "true" : "false"
      )
    } : {},
    !/*nav*/
    ctx[23] && /*role*/
    (ctx[9] === "radio" || /*role*/
    ctx[9] === "checkbox") ? {
      "aria-checked": (
        /*input*/
        ctx[16] && /*input*/
        ctx[16].checked ? "true" : "false"
      )
    } : {},
    !/*nav*/
    ctx[23] ? {
      "aria-disabled": (
        /*disabled*/
        ctx[10] ? "true" : "false"
      )
    } : {},
    {
      "data-menu-item-skip-restore-focus": (
        /*skipRestoreFocus*/
        ctx[11] || void 0
      )
    },
    { tabindex: (
      /*tabindex*/
      ctx[21]
    ) },
    { href: (
      /*href*/
      ctx[12]
    ) },
    /*internalAttrs*/
    ctx[20],
    /*$$restProps*/
    ctx[29]
  ];
  var switch_value = (
    /*component*/
    ctx[13]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty[0] & /*tag, nonInteractive, input, activated, selected, color, disabled, addClass, removeClass, addStyle, forwardEvents, use, className, wrapper, nav, role, internalClasses, internalStyles, style, skipRestoreFocus, tabindex, href, internalAttrs, $$restProps*/
    670916479) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty[0] & /*tag*/
        16384 && { tag: (
          /*tag*/
          ctx2[14]
        ) },
        dirty[0] & /*nonInteractive, input, activated, selected, color, disabled, addClass, removeClass, addStyle, forwardEvents, use*/
        121701479 && {
          use: [
            .../*nonInteractive*/
            ctx2[6] ? [] : [
              [
                dist_default,
                {
                  ripple: !/*input*/
                  ctx2[16],
                  unbounded: false,
                  color: (
                    /*activated*/
                    (ctx2[1] || /*selected*/
                    ctx2[0]) && /*color*/
                    ctx2[5] == null ? "primary" : (
                      /*color*/
                      ctx2[5]
                    )
                  ),
                  disabled: (
                    /*disabled*/
                    ctx2[10]
                  ),
                  addClass: (
                    /*addClass*/
                    ctx2[24]
                  ),
                  removeClass: (
                    /*removeClass*/
                    ctx2[25]
                  ),
                  addStyle: (
                    /*addStyle*/
                    ctx2[26]
                  )
                }
              ]
            ],
            /*forwardEvents*/
            ctx2[22],
            .../*use*/
            ctx2[2]
          ]
        },
        dirty[0] & /*className, wrapper, activated, selected, disabled, nav, role, nonInteractive, internalClasses*/
        8652619 && {
          class: classMap({
            [
              /*className*/
              ctx2[3]
            ]: true,
            "mdc-deprecated-list-item": !/*wrapper*/
            ctx2[8],
            "mdc-deprecated-list-item__wrapper": (
              /*wrapper*/
              ctx2[8]
            ),
            "mdc-deprecated-list-item--activated": (
              /*activated*/
              ctx2[1]
            ),
            "mdc-deprecated-list-item--selected": (
              /*selected*/
              ctx2[0]
            ),
            "mdc-deprecated-list-item--disabled": (
              /*disabled*/
              ctx2[10]
            ),
            "mdc-menu-item--selected": !/*nav*/
            ctx2[23] && /*role*/
            ctx2[9] === "menuitem" && /*selected*/
            ctx2[0],
            "smui-menu-item--non-interactive": (
              /*nonInteractive*/
              ctx2[6]
            ),
            .../*internalClasses*/
            ctx2[18]
          })
        },
        dirty[0] & /*internalStyles, style*/
        524304 && {
          style: Object.entries(
            /*internalStyles*/
            ctx2[19]
          ).map(func).concat([
            /*style*/
            ctx2[4]
          ]).join(" ")
        },
        dirty[0] & /*nav, activated*/
        8388610 && get_spread_object(
          /*nav*/
          ctx2[23] && /*activated*/
          ctx2[1] ? { "aria-current": "page" } : {}
        ),
        dirty[0] & /*nav, wrapper, role*/
        8389376 && get_spread_object(!/*nav*/
        ctx2[23] || /*wrapper*/
        ctx2[8] ? { role: (
          /*role*/
          ctx2[9]
        ) } : {}),
        dirty[0] & /*nav, role, selected*/
        8389121 && get_spread_object(!/*nav*/
        ctx2[23] && /*role*/
        ctx2[9] === "option" ? {
          "aria-selected": (
            /*selected*/
            ctx2[0] ? "true" : "false"
          )
        } : {}),
        dirty[0] & /*nav, role, input*/
        8454656 && get_spread_object(!/*nav*/
        ctx2[23] && /*role*/
        (ctx2[9] === "radio" || /*role*/
        ctx2[9] === "checkbox") ? {
          "aria-checked": (
            /*input*/
            ctx2[16] && /*input*/
            ctx2[16].checked ? "true" : "false"
          )
        } : {}),
        dirty[0] & /*nav, disabled*/
        8389632 && get_spread_object(!/*nav*/
        ctx2[23] ? {
          "aria-disabled": (
            /*disabled*/
            ctx2[10] ? "true" : "false"
          )
        } : {}),
        dirty[0] & /*skipRestoreFocus*/
        2048 && {
          "data-menu-item-skip-restore-focus": (
            /*skipRestoreFocus*/
            ctx2[11] || void 0
          )
        },
        dirty[0] & /*tabindex*/
        2097152 && { tabindex: (
          /*tabindex*/
          ctx2[21]
        ) },
        dirty[0] & /*href*/
        4096 && { href: (
          /*href*/
          ctx2[12]
        ) },
        dirty[0] & /*internalAttrs*/
        1048576 && get_spread_object(
          /*internalAttrs*/
          ctx2[20]
        ),
        dirty[0] & /*$$restProps*/
        536870912 && get_spread_object(
          /*$$restProps*/
          ctx2[29]
        )
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[35](switch_instance);
    switch_instance.$on(
      "click",
      /*action*/
      ctx[15]
    );
    switch_instance.$on(
      "keydown",
      /*handleKeydown*/
      ctx[27]
    );
    switch_instance.$on(
      "SMUIGenericInput:mount",
      /*handleInputMount*/
      ctx[28]
    );
    switch_instance.$on(
      "SMUIGenericInput:unmount",
      /*SMUIGenericInput_unmount_handler*/
      ctx[36]
    );
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*component*/
      8192 && switch_value !== (switch_value = /*component*/
      ctx2[13])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          ctx2[35](switch_instance);
          switch_instance.$on(
            "click",
            /*action*/
            ctx2[15]
          );
          switch_instance.$on(
            "keydown",
            /*handleKeydown*/
            ctx2[27]
          );
          switch_instance.$on(
            "SMUIGenericInput:mount",
            /*handleInputMount*/
            ctx2[28]
          );
          switch_instance.$on(
            "SMUIGenericInput:unmount",
            /*SMUIGenericInput_unmount_handler*/
            ctx2[36]
          );
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*tag, nonInteractive, input, activated, selected, color, disabled, addClass, removeClass, addStyle, forwardEvents, use, className, wrapper, nav, role, internalClasses, internalStyles, style, skipRestoreFocus, tabindex, href, internalAttrs, $$restProps*/
        670916479 ? get_spread_update(switch_instance_spread_levels, [
          dirty[0] & /*tag*/
          16384 && { tag: (
            /*tag*/
            ctx2[14]
          ) },
          dirty[0] & /*nonInteractive, input, activated, selected, color, disabled, addClass, removeClass, addStyle, forwardEvents, use*/
          121701479 && {
            use: [
              .../*nonInteractive*/
              ctx2[6] ? [] : [
                [
                  dist_default,
                  {
                    ripple: !/*input*/
                    ctx2[16],
                    unbounded: false,
                    color: (
                      /*activated*/
                      (ctx2[1] || /*selected*/
                      ctx2[0]) && /*color*/
                      ctx2[5] == null ? "primary" : (
                        /*color*/
                        ctx2[5]
                      )
                    ),
                    disabled: (
                      /*disabled*/
                      ctx2[10]
                    ),
                    addClass: (
                      /*addClass*/
                      ctx2[24]
                    ),
                    removeClass: (
                      /*removeClass*/
                      ctx2[25]
                    ),
                    addStyle: (
                      /*addStyle*/
                      ctx2[26]
                    )
                  }
                ]
              ],
              /*forwardEvents*/
              ctx2[22],
              .../*use*/
              ctx2[2]
            ]
          },
          dirty[0] & /*className, wrapper, activated, selected, disabled, nav, role, nonInteractive, internalClasses*/
          8652619 && {
            class: classMap({
              [
                /*className*/
                ctx2[3]
              ]: true,
              "mdc-deprecated-list-item": !/*wrapper*/
              ctx2[8],
              "mdc-deprecated-list-item__wrapper": (
                /*wrapper*/
                ctx2[8]
              ),
              "mdc-deprecated-list-item--activated": (
                /*activated*/
                ctx2[1]
              ),
              "mdc-deprecated-list-item--selected": (
                /*selected*/
                ctx2[0]
              ),
              "mdc-deprecated-list-item--disabled": (
                /*disabled*/
                ctx2[10]
              ),
              "mdc-menu-item--selected": !/*nav*/
              ctx2[23] && /*role*/
              ctx2[9] === "menuitem" && /*selected*/
              ctx2[0],
              "smui-menu-item--non-interactive": (
                /*nonInteractive*/
                ctx2[6]
              ),
              .../*internalClasses*/
              ctx2[18]
            })
          },
          dirty[0] & /*internalStyles, style*/
          524304 && {
            style: Object.entries(
              /*internalStyles*/
              ctx2[19]
            ).map(func).concat([
              /*style*/
              ctx2[4]
            ]).join(" ")
          },
          dirty[0] & /*nav, activated*/
          8388610 && get_spread_object(
            /*nav*/
            ctx2[23] && /*activated*/
            ctx2[1] ? { "aria-current": "page" } : {}
          ),
          dirty[0] & /*nav, wrapper, role*/
          8389376 && get_spread_object(!/*nav*/
          ctx2[23] || /*wrapper*/
          ctx2[8] ? { role: (
            /*role*/
            ctx2[9]
          ) } : {}),
          dirty[0] & /*nav, role, selected*/
          8389121 && get_spread_object(!/*nav*/
          ctx2[23] && /*role*/
          ctx2[9] === "option" ? {
            "aria-selected": (
              /*selected*/
              ctx2[0] ? "true" : "false"
            )
          } : {}),
          dirty[0] & /*nav, role, input*/
          8454656 && get_spread_object(!/*nav*/
          ctx2[23] && /*role*/
          (ctx2[9] === "radio" || /*role*/
          ctx2[9] === "checkbox") ? {
            "aria-checked": (
              /*input*/
              ctx2[16] && /*input*/
              ctx2[16].checked ? "true" : "false"
            )
          } : {}),
          dirty[0] & /*nav, disabled*/
          8389632 && get_spread_object(!/*nav*/
          ctx2[23] ? {
            "aria-disabled": (
              /*disabled*/
              ctx2[10] ? "true" : "false"
            )
          } : {}),
          dirty[0] & /*skipRestoreFocus*/
          2048 && {
            "data-menu-item-skip-restore-focus": (
              /*skipRestoreFocus*/
              ctx2[11] || void 0
            )
          },
          dirty[0] & /*tabindex*/
          2097152 && { tabindex: (
            /*tabindex*/
            ctx2[21]
          ) },
          dirty[0] & /*href*/
          4096 && { href: (
            /*href*/
            ctx2[12]
          ) },
          dirty[0] & /*internalAttrs*/
          1048576 && get_spread_object(
            /*internalAttrs*/
            ctx2[20]
          ),
          dirty[0] & /*$$restProps*/
          536870912 && get_spread_object(
            /*$$restProps*/
            ctx2[29]
          )
        ]) : {};
        if (dirty[0] & /*ripple*/
        128 | dirty[1] & /*$$scope*/
        64) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx[35](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var counter = 0;
var func = ([name, value]) => `${name}: ${value};`;
function instance($$self, $$props, $$invalidate) {
  let tabindex;
  const omit_props_names = [
    "use",
    "class",
    "style",
    "color",
    "nonInteractive",
    "ripple",
    "wrapper",
    "activated",
    "role",
    "selected",
    "disabled",
    "skipRestoreFocus",
    "tabindex",
    "inputId",
    "href",
    "component",
    "tag",
    "action",
    "getPrimaryText",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Item", slots, ["default"]);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value) {
    return value === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { color = void 0 } = $$props;
  let { nonInteractive = (_a = getContext("SMUI:list:nonInteractive")) !== null && _a !== void 0 ? _a : false } = $$props;
  setContext("SMUI:list:nonInteractive", void 0);
  let { ripple = !nonInteractive } = $$props;
  let { wrapper = false } = $$props;
  let { activated = false } = $$props;
  let { role = wrapper ? "presentation" : getContext("SMUI:list:item:role") } = $$props;
  setContext("SMUI:list:item:role", void 0);
  let { selected = false } = $$props;
  let { disabled = false } = $$props;
  let { skipRestoreFocus = false } = $$props;
  let { tabindex: tabindexProp = uninitializedValue } = $$props;
  let { inputId = "SMUI-form-field-list-" + counter++ } = $$props;
  let { href = void 0 } = $$props;
  let element2;
  let internalClasses = {};
  let internalStyles = {};
  let internalAttrs = {};
  let input;
  let addTabindexIfNoItemsSelectedRaf;
  let nav = getContext("SMUI:list:item:nav");
  let { component = SmuiElement_default } = $$props;
  let { tag = component === SmuiElement_default ? nav ? href ? "a" : "span" : "li" : void 0 } = $$props;
  setContext("SMUI:generic:input:props", { id: inputId });
  setContext("SMUI:separator:context", void 0);
  onMount(() => {
    if (!selected && !nonInteractive) {
      let first = true;
      let el = element2.getElement();
      while (el.previousSibling) {
        el = el.previousSibling;
        if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item") && !el.classList.contains("mdc-deprecated-list-item--disabled")) {
          first = false;
          break;
        }
      }
      if (first) {
        addTabindexIfNoItemsSelectedRaf = window.requestAnimationFrame(() => addTabindexIfNoItemsSelected(el));
      }
    }
    const accessor = {
      _smui_list_item_accessor: true,
      get element() {
        return getElement();
      },
      get selected() {
        return selected;
      },
      set selected(value) {
        $$invalidate(0, selected = value);
      },
      hasClass,
      addClass,
      removeClass,
      getAttr,
      addAttr,
      removeAttr,
      getPrimaryText,
      // For inputs within item.
      get checked() {
        var _a2;
        return (_a2 = input && input.checked) !== null && _a2 !== void 0 ? _a2 : false;
      },
      set checked(value) {
        if (input) {
          $$invalidate(16, input.checked = !!value, input);
        }
      },
      get hasCheckbox() {
        return !!(input && "_smui_checkbox_accessor" in input);
      },
      get hasRadio() {
        return !!(input && "_smui_radio_accessor" in input);
      },
      activateRipple() {
        if (input) {
          input.activateRipple();
        }
      },
      deactivateRipple() {
        if (input) {
          input.deactivateRipple();
        }
      },
      // For select options.
      getValue() {
        return $$restProps.value;
      },
      // For autocomplete
      action,
      get tabindex() {
        return tabindex;
      },
      set tabindex(value) {
        $$invalidate(30, tabindexProp = value);
      },
      get disabled() {
        return disabled;
      },
      get activated() {
        return activated;
      },
      set activated(value) {
        $$invalidate(1, activated = value);
      }
    };
    dispatch(getElement(), "SMUIListItem:mount", accessor);
    return () => {
      dispatch(getElement(), "SMUIListItem:unmount", accessor);
    };
  });
  onDestroy(() => {
    if (addTabindexIfNoItemsSelectedRaf) {
      window.cancelAnimationFrame(addTabindexIfNoItemsSelectedRaf);
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(18, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(18, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(19, internalStyles);
      } else {
        $$invalidate(19, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function getAttr(name) {
    var _a2;
    return name in internalAttrs ? (_a2 = internalAttrs[name]) !== null && _a2 !== void 0 ? _a2 : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(20, internalAttrs[name] = value, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(20, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function addTabindexIfNoItemsSelected(el) {
    let noneSelected = true;
    while (el.nextElementSibling) {
      el = el.nextElementSibling;
      if (el.nodeType === 1 && el.classList.contains("mdc-deprecated-list-item")) {
        const tabindexAttr = el.attributes.getNamedItem("tabindex");
        if (tabindexAttr && tabindexAttr.value === "0") {
          noneSelected = false;
          break;
        }
      }
    }
    if (noneSelected) {
      $$invalidate(21, tabindex = 0);
    }
  }
  function handleKeydown(e) {
    const isEnter = e.key === "Enter";
    const isSpace = e.key === "Space";
    if (isEnter || isSpace) {
      action(e);
    }
  }
  function handleInputMount(e) {
    if ("_smui_checkbox_accessor" in e.detail || "_smui_radio_accessor" in e.detail) {
      $$invalidate(16, input = e.detail);
    }
  }
  function action(e) {
    if (!disabled) {
      dispatch(getElement(), "SMUI:action", e);
    }
  }
  function getPrimaryText() {
    var _a2, _b, _c;
    const element3 = getElement();
    const primaryText = element3.querySelector(".mdc-deprecated-list-item__primary-text");
    if (primaryText) {
      return (_a2 = primaryText.textContent) !== null && _a2 !== void 0 ? _a2 : "";
    }
    const text = element3.querySelector(".mdc-deprecated-list-item__text");
    if (text) {
      return (_b = text.textContent) !== null && _b !== void 0 ? _b : "";
    }
    return (_c = element3.textContent) !== null && _c !== void 0 ? _c : "";
  }
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(17, element2);
    });
  }
  const SMUIGenericInput_unmount_handler = () => $$invalidate(16, input = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(29, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("color" in $$new_props)
      $$invalidate(5, color = $$new_props.color);
    if ("nonInteractive" in $$new_props)
      $$invalidate(6, nonInteractive = $$new_props.nonInteractive);
    if ("ripple" in $$new_props)
      $$invalidate(7, ripple = $$new_props.ripple);
    if ("wrapper" in $$new_props)
      $$invalidate(8, wrapper = $$new_props.wrapper);
    if ("activated" in $$new_props)
      $$invalidate(1, activated = $$new_props.activated);
    if ("role" in $$new_props)
      $$invalidate(9, role = $$new_props.role);
    if ("selected" in $$new_props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$new_props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("skipRestoreFocus" in $$new_props)
      $$invalidate(11, skipRestoreFocus = $$new_props.skipRestoreFocus);
    if ("tabindex" in $$new_props)
      $$invalidate(30, tabindexProp = $$new_props.tabindex);
    if ("inputId" in $$new_props)
      $$invalidate(31, inputId = $$new_props.inputId);
    if ("href" in $$new_props)
      $$invalidate(12, href = $$new_props.href);
    if ("component" in $$new_props)
      $$invalidate(13, component = $$new_props.component);
    if ("tag" in $$new_props)
      $$invalidate(14, tag = $$new_props.tag);
    if ("$$scope" in $$new_props)
      $$invalidate(37, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    counter,
    _a,
    onMount,
    onDestroy,
    getContext,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    dispatch,
    Ripple: dist_default,
    SmuiElement: SmuiElement_default,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    style,
    color,
    nonInteractive,
    ripple,
    wrapper,
    activated,
    role,
    selected,
    disabled,
    skipRestoreFocus,
    tabindexProp,
    inputId,
    href,
    element: element2,
    internalClasses,
    internalStyles,
    internalAttrs,
    input,
    addTabindexIfNoItemsSelectedRaf,
    nav,
    component,
    tag,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    getAttr,
    addAttr,
    removeAttr,
    addTabindexIfNoItemsSelected,
    handleKeydown,
    handleInputMount,
    action,
    getPrimaryText,
    getElement,
    tabindex
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("color" in $$props)
      $$invalidate(5, color = $$new_props.color);
    if ("nonInteractive" in $$props)
      $$invalidate(6, nonInteractive = $$new_props.nonInteractive);
    if ("ripple" in $$props)
      $$invalidate(7, ripple = $$new_props.ripple);
    if ("wrapper" in $$props)
      $$invalidate(8, wrapper = $$new_props.wrapper);
    if ("activated" in $$props)
      $$invalidate(1, activated = $$new_props.activated);
    if ("role" in $$props)
      $$invalidate(9, role = $$new_props.role);
    if ("selected" in $$props)
      $$invalidate(0, selected = $$new_props.selected);
    if ("disabled" in $$props)
      $$invalidate(10, disabled = $$new_props.disabled);
    if ("skipRestoreFocus" in $$props)
      $$invalidate(11, skipRestoreFocus = $$new_props.skipRestoreFocus);
    if ("tabindexProp" in $$props)
      $$invalidate(30, tabindexProp = $$new_props.tabindexProp);
    if ("inputId" in $$props)
      $$invalidate(31, inputId = $$new_props.inputId);
    if ("href" in $$props)
      $$invalidate(12, href = $$new_props.href);
    if ("element" in $$props)
      $$invalidate(17, element2 = $$new_props.element);
    if ("internalClasses" in $$props)
      $$invalidate(18, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(19, internalStyles = $$new_props.internalStyles);
    if ("internalAttrs" in $$props)
      $$invalidate(20, internalAttrs = $$new_props.internalAttrs);
    if ("input" in $$props)
      $$invalidate(16, input = $$new_props.input);
    if ("addTabindexIfNoItemsSelectedRaf" in $$props)
      addTabindexIfNoItemsSelectedRaf = $$new_props.addTabindexIfNoItemsSelectedRaf;
    if ("nav" in $$props)
      $$invalidate(23, nav = $$new_props.nav);
    if ("component" in $$props)
      $$invalidate(13, component = $$new_props.component);
    if ("tag" in $$props)
      $$invalidate(14, tag = $$new_props.tag);
    if ("tabindex" in $$props)
      $$invalidate(21, tabindex = $$new_props.tabindex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*tabindexProp, nonInteractive, disabled, selected, input*/
    1073808449) {
      $:
        $$invalidate(21, tabindex = isUninitializedValue(tabindexProp) ? !nonInteractive && !disabled && (selected || input && input.checked) ? 0 : -1 : tabindexProp);
    }
  };
  return [
    selected,
    activated,
    use,
    className,
    style,
    color,
    nonInteractive,
    ripple,
    wrapper,
    role,
    disabled,
    skipRestoreFocus,
    href,
    component,
    tag,
    action,
    input,
    element2,
    internalClasses,
    internalStyles,
    internalAttrs,
    tabindex,
    forwardEvents,
    nav,
    addClass,
    removeClass,
    addStyle,
    handleKeydown,
    handleInputMount,
    $$restProps,
    tabindexProp,
    inputId,
    getPrimaryText,
    getElement,
    slots,
    switch_instance_binding,
    SMUIGenericInput_unmount_handler,
    $$scope
  ];
}
var Item = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance,
      create_fragment2,
      safe_not_equal,
      {
        use: 2,
        class: 3,
        style: 4,
        color: 5,
        nonInteractive: 6,
        ripple: 7,
        wrapper: 8,
        activated: 1,
        role: 9,
        selected: 0,
        disabled: 10,
        skipRestoreFocus: 11,
        tabindex: 30,
        inputId: 31,
        href: 12,
        component: 13,
        tag: 14,
        action: 15,
        getPrimaryText: 32,
        getElement: 33
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Item",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get color() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set color(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get nonInteractive() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set nonInteractive(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapper() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapper(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activated() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set activated(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get role() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set role(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selected() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selected(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get skipRestoreFocus() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set skipRestoreFocus(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get href() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set href(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get action() {
    return this.$$.ctx[15];
  }
  set action(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getPrimaryText() {
    return this.$$.ctx[32];
  }
  set getPrimaryText(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[33];
  }
  set getElement(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Item_default = Item;

// node_modules/@smui/list/dist/Text.js
var Text_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__text",
  tag: "span"
});

// node_modules/@smui/list/dist/PrimaryText.js
var PrimaryText_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__primary-text",
  tag: "span"
});

// node_modules/@smui/list/dist/SecondaryText.js
var SecondaryText_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__secondary-text",
  tag: "span"
});

// node_modules/@smui/list/dist/Graphic.svelte
var file2 = "node_modules/@smui/list/dist/Graphic.svelte";
function create_fragment3(ctx) {
  let span;
  let span_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let span_levels = [
    {
      class: span_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-deprecated-list-item__graphic": true,
        "mdc-menu__selection-group-icon": (
          /*menuSelectionGroup*/
          ctx[4]
        )
      })
    },
    /*$$restProps*/
    ctx[5]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file2, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[9](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[3].call(null, span))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*className*/
        2 && span_class_value !== (span_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-deprecated-list-item__graphic": true,
          "mdc-menu__selection-group-icon": (
            /*menuSelectionGroup*/
            ctx2[4]
          )
        }))) && { class: span_class_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Graphic", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  let menuSelectionGroup = getContext("SMUI:list:graphic:menu-selection-group");
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    element: element2,
    menuSelectionGroup,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("menuSelectionGroup" in $$props)
      $$invalidate(4, menuSelectionGroup = $$new_props.menuSelectionGroup);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    forwardEvents,
    menuSelectionGroup,
    $$restProps,
    getElement,
    $$scope,
    slots,
    span_binding
  ];
}
var Graphic = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment3, safe_not_equal, { use: 0, class: 1, getElement: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Graphic",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Graphic>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[6];
  }
  set getElement(value) {
    throw new Error("<Graphic>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Graphic_default = Graphic;

// node_modules/@smui/list/dist/Meta.js
var Meta_default = classAdderBuilder({
  class: "mdc-deprecated-list-item__meta",
  tag: "span"
});

// node_modules/@smui/list/dist/Label.svelte
var file3 = "node_modules/@smui/list/dist/Label.svelte";
function create_fragment4(ctx) {
  let label;
  let label_class_value;
  let label_for_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[8].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[7],
    null
  );
  let label_levels = [
    {
      class: label_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-deprecated-list-item__text": true
      })
    },
    {
      for: label_for_value = /*inputProps*/
      ctx[4] ? (
        /*inputProps*/
        ctx[4].id
      ) : void 0
    },
    /*$$restProps*/
    ctx[5]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true, for: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label, label_data);
      add_location(label, file3, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      ctx[9](label);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            label,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[3].call(null, label))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        128)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[7],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[7]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[7],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & /*className*/
        2 && label_class_value !== (label_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-deprecated-list-item__text": true
        }))) && { class: label_class_value },
        { for: label_for_value },
        dirty & /*$$restProps*/
        32 && /*$$restProps*/
        ctx2[5]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[9](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Label", slots, ["default"]);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  let inputProps = (_a = getContext("SMUI:generic:input:props")) !== null && _a !== void 0 ? _a : {};
  function getElement() {
    return element2;
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(5, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(7, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    element: element2,
    inputProps,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("inputProps" in $$props)
      $$invalidate(4, inputProps = $$new_props.inputProps);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    forwardEvents,
    inputProps,
    $$restProps,
    getElement,
    $$scope,
    slots,
    label_binding
  ];
}
var Label = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment4, safe_not_equal, { use: 0, class: 1, getElement: 6 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Label",
      options,
      id: create_fragment4.name
    });
  }
  get use() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Label>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[6];
  }
  set getElement(value) {
    throw new Error("<Label>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Label_default = Label;

// node_modules/@smui/list/dist/Group.js
var Group_default = classAdderBuilder({
  class: "mdc-deprecated-list-group",
  tag: "div"
});

// node_modules/@smui/list/dist/Subheader.js
var Subheader_default = classAdderBuilder({
  class: "mdc-deprecated-list-group__subheader",
  tag: "h3"
});

// node_modules/@smui/list/dist/Separator.svelte
function create_fragment5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    { tag: (
      /*tag*/
      ctx[8]
    ) },
    {
      use: [
        /*forwardEvents*/
        ctx[10],
        .../*use*/
        ctx[0]
      ]
    },
    {
      class: classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-deprecated-list-divider": true,
        "mdc-deprecated-list-divider--padded": (
          /*padded*/
          ctx[2]
        ),
        "mdc-deprecated-list-divider--inset": (
          /*inset*/
          ctx[3]
        ),
        "mdc-deprecated-list-divider--inset-leading": (
          /*insetLeading*/
          ctx[4]
        ),
        "mdc-deprecated-list-divider--inset-trailing": (
          /*insetTrailing*/
          ctx[5]
        ),
        "mdc-deprecated-list-divider--inset-padding": (
          /*insetPadding*/
          ctx[6]
        )
      })
    },
    { role: "separator" },
    /*$$restProps*/
    ctx[11]
  ];
  var switch_value = (
    /*component*/
    ctx[7]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*tag, forwardEvents, use, className, padded, inset, insetLeading, insetTrailing, insetPadding, $$restProps*/
    3455) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [
        dirty & /*tag*/
        256 && { tag: (
          /*tag*/
          ctx2[8]
        ) },
        dirty & /*forwardEvents, use*/
        1025 && {
          use: [
            /*forwardEvents*/
            ctx2[10],
            .../*use*/
            ctx2[0]
          ]
        },
        dirty & /*className, padded, inset, insetLeading, insetTrailing, insetPadding*/
        126 && {
          class: classMap({
            [
              /*className*/
              ctx2[1]
            ]: true,
            "mdc-deprecated-list-divider": true,
            "mdc-deprecated-list-divider--padded": (
              /*padded*/
              ctx2[2]
            ),
            "mdc-deprecated-list-divider--inset": (
              /*inset*/
              ctx2[3]
            ),
            "mdc-deprecated-list-divider--inset-leading": (
              /*insetLeading*/
              ctx2[4]
            ),
            "mdc-deprecated-list-divider--inset-trailing": (
              /*insetTrailing*/
              ctx2[5]
            ),
            "mdc-deprecated-list-divider--inset-padding": (
              /*insetPadding*/
              ctx2[6]
            )
          })
        },
        switch_instance_spread_levels[3],
        dirty & /*$$restProps*/
        2048 && get_spread_object(
          /*$$restProps*/
          ctx2[11]
        )
      ]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[13](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    l: function claim(nodes) {
      if (switch_instance)
        claim_component(switch_instance.$$.fragment, nodes);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_hydration_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if (dirty & /*component*/
      128 && switch_value !== (switch_value = /*component*/
      ctx2[7])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          ctx2[13](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*tag, forwardEvents, use, className, padded, inset, insetLeading, insetTrailing, insetPadding, $$restProps*/
        3455 ? get_spread_update(switch_instance_spread_levels, [
          dirty & /*tag*/
          256 && { tag: (
            /*tag*/
            ctx2[8]
          ) },
          dirty & /*forwardEvents, use*/
          1025 && {
            use: [
              /*forwardEvents*/
              ctx2[10],
              .../*use*/
              ctx2[0]
            ]
          },
          dirty & /*className, padded, inset, insetLeading, insetTrailing, insetPadding*/
          126 && {
            class: classMap({
              [
                /*className*/
                ctx2[1]
              ]: true,
              "mdc-deprecated-list-divider": true,
              "mdc-deprecated-list-divider--padded": (
                /*padded*/
                ctx2[2]
              ),
              "mdc-deprecated-list-divider--inset": (
                /*inset*/
                ctx2[3]
              ),
              "mdc-deprecated-list-divider--inset-leading": (
                /*insetLeading*/
                ctx2[4]
              ),
              "mdc-deprecated-list-divider--inset-trailing": (
                /*insetTrailing*/
                ctx2[5]
              ),
              "mdc-deprecated-list-divider--inset-padding": (
                /*insetPadding*/
                ctx2[6]
              )
            })
          },
          switch_instance_spread_levels[3],
          dirty & /*$$restProps*/
          2048 && get_spread_object(
            /*$$restProps*/
            ctx2[11]
          )
        ]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx[13](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "padded",
    "inset",
    "insetLeading",
    "insetTrailing",
    "insetPadding",
    "component",
    "tag",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Separator", slots, []);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { padded = false } = $$props;
  let { inset = false } = $$props;
  let { insetLeading = false } = $$props;
  let { insetTrailing = false } = $$props;
  let { insetPadding = false } = $$props;
  let element2;
  let nav = getContext("SMUI:list:item:nav");
  let context = getContext("SMUI:separator:context");
  let { component = SmuiElement_default } = $$props;
  let { tag = component === SmuiElement_default ? nav || context !== "list" ? "hr" : "li" : void 0 } = $$props;
  function getElement() {
    return element2.getElement();
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(9, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("padded" in $$new_props)
      $$invalidate(2, padded = $$new_props.padded);
    if ("inset" in $$new_props)
      $$invalidate(3, inset = $$new_props.inset);
    if ("insetLeading" in $$new_props)
      $$invalidate(4, insetLeading = $$new_props.insetLeading);
    if ("insetTrailing" in $$new_props)
      $$invalidate(5, insetTrailing = $$new_props.insetTrailing);
    if ("insetPadding" in $$new_props)
      $$invalidate(6, insetPadding = $$new_props.insetPadding);
    if ("component" in $$new_props)
      $$invalidate(7, component = $$new_props.component);
    if ("tag" in $$new_props)
      $$invalidate(8, tag = $$new_props.tag);
  };
  $$self.$capture_state = () => ({
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    SmuiElement: SmuiElement_default,
    forwardEvents,
    use,
    className,
    padded,
    inset,
    insetLeading,
    insetTrailing,
    insetPadding,
    element: element2,
    nav,
    context,
    component,
    tag,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("padded" in $$props)
      $$invalidate(2, padded = $$new_props.padded);
    if ("inset" in $$props)
      $$invalidate(3, inset = $$new_props.inset);
    if ("insetLeading" in $$props)
      $$invalidate(4, insetLeading = $$new_props.insetLeading);
    if ("insetTrailing" in $$props)
      $$invalidate(5, insetTrailing = $$new_props.insetTrailing);
    if ("insetPadding" in $$props)
      $$invalidate(6, insetPadding = $$new_props.insetPadding);
    if ("element" in $$props)
      $$invalidate(9, element2 = $$new_props.element);
    if ("nav" in $$props)
      nav = $$new_props.nav;
    if ("context" in $$props)
      context = $$new_props.context;
    if ("component" in $$props)
      $$invalidate(7, component = $$new_props.component);
    if ("tag" in $$props)
      $$invalidate(8, tag = $$new_props.tag);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    padded,
    inset,
    insetLeading,
    insetTrailing,
    insetPadding,
    component,
    tag,
    element2,
    forwardEvents,
    $$restProps,
    getElement,
    switch_instance_binding
  ];
}
var Separator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment5, safe_not_equal, {
      use: 0,
      class: 1,
      padded: 2,
      inset: 3,
      insetLeading: 4,
      insetTrailing: 5,
      insetPadding: 6,
      component: 7,
      tag: 8,
      getElement: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Separator",
      options,
      id: create_fragment5.name
    });
  }
  get use() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get padded() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set padded(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inset() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inset(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetLeading() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetLeading(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetTrailing() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetTrailing(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get insetPadding() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set insetPadding(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get component() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set component(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tag() {
    throw new Error("<Separator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tag(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[12];
  }
  set getElement(value) {
    throw new Error("<Separator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Separator_default = Separator;

// node_modules/@smui/list/dist/index.js
var dist_default2 = List_default;
export {
  Graphic_default as Graphic,
  Group_default as Group,
  Item_default as Item,
  Label_default as Label,
  Meta_default as Meta,
  PrimaryText_default as PrimaryText,
  SecondaryText_default as SecondaryText,
  Separator_default as Separator,
  Subheader_default as Subheader,
  Text_default as Text,
  dist_default2 as default
};
//# sourceMappingURL=@smui_list.js.map
