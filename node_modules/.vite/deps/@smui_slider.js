import {
  getCorrectPropertyName
} from "./chunk-NQKK4KOY.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-DXJYLXNN.js";
import {
  dist_default
} from "./chunk-PUBUOBZD.js";
import "./chunk-CTXZTH3U.js";
import {
  MDCRipple,
  MDCRippleFoundation
} from "./chunk-AI3MMAIG.js";
import "./chunk-W4OU4FMO.js";
import {
  applyPassive
} from "./chunk-OYKM6SV3.js";
import "./chunk-Y3XZ6UIT.js";
import "./chunk-RFTMRRON.js";
import {
  MDCComponent,
  MDCFoundation
} from "./chunk-ODRA5LQH.js";
import {
  matches
} from "./chunk-BT6PLM7B.js";
import "./chunk-X7HCJ7ZS.js";
import {
  __assign,
  __extends
} from "./chunk-X43LXICK.js";
import "./chunk-ZB6PEJPW.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  binding_callbacks,
  bubble,
  children,
  claim_element,
  claim_space,
  claim_text,
  compute_rest_props,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  ensure_array_like_dev,
  exclude_internal_props,
  getContext,
  get_current_component,
  get_spread_update,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  set_attributes,
  set_data_dev,
  set_input_value,
  space,
  text,
  to_number,
  validate_slots
} from "./chunk-NMMN3PC6.js";
import "./chunk-4DGM7FRE.js";
import "./chunk-7U33LM2Z.js";

// node_modules/@material/slider/constants.js
var cssClasses = {
  DISABLED: "mdc-slider--disabled",
  DISCRETE: "mdc-slider--discrete",
  INPUT: "mdc-slider__input",
  RANGE: "mdc-slider--range",
  THUMB: "mdc-slider__thumb",
  // Applied when thumb is in the focused state.
  THUMB_FOCUSED: "mdc-slider__thumb--focused",
  THUMB_KNOB: "mdc-slider__thumb-knob",
  // Class added to the top thumb (for overlapping thumbs in range slider).
  THUMB_TOP: "mdc-slider__thumb--top",
  THUMB_WITH_INDICATOR: "mdc-slider__thumb--with-indicator",
  TICK_MARKS: "mdc-slider--tick-marks",
  TICK_MARKS_CONTAINER: "mdc-slider__tick-marks",
  TICK_MARK_ACTIVE: "mdc-slider__tick-mark--active",
  TICK_MARK_INACTIVE: "mdc-slider__tick-mark--inactive",
  TRACK: "mdc-slider__track",
  // The active track fill element that will be scaled as the value changes.
  TRACK_ACTIVE: "mdc-slider__track--active_fill",
  VALUE_INDICATOR_CONTAINER: "mdc-slider__value-indicator-container",
  VALUE_INDICATOR_TEXT: "mdc-slider__value-indicator-text"
};
var numbers = {
  // Default step size.
  STEP_SIZE: 1,
  // Default minimum difference between the start and end values.
  MIN_RANGE: 0,
  // Minimum absolute difference between clientX of move event / down event
  // for which to update thumb, in the case of overlapping thumbs.
  // This is needed to reduce chances of choosing the thumb based on
  // pointer jitter.
  THUMB_UPDATE_MIN_PX: 5
};
var attributes = {
  ARIA_VALUETEXT: "aria-valuetext",
  INPUT_DISABLED: "disabled",
  INPUT_MIN: "min",
  INPUT_MAX: "max",
  INPUT_VALUE: "value",
  INPUT_STEP: "step",
  DATA_MIN_RANGE: "data-min-range"
};
var events = {
  CHANGE: "MDCSlider:change",
  INPUT: "MDCSlider:input"
};
var strings = {
  VAR_VALUE_INDICATOR_CARET_LEFT: "--slider-value-indicator-caret-left",
  VAR_VALUE_INDICATOR_CARET_RIGHT: "--slider-value-indicator-caret-right",
  VAR_VALUE_INDICATOR_CARET_TRANSFORM: "--slider-value-indicator-caret-transform",
  VAR_VALUE_INDICATOR_CONTAINER_LEFT: "--slider-value-indicator-container-left",
  VAR_VALUE_INDICATOR_CONTAINER_RIGHT: "--slider-value-indicator-container-right",
  VAR_VALUE_INDICATOR_CONTAINER_TRANSFORM: "--slider-value-indicator-container-transform"
};

// node_modules/@material/animation/animationframe.js
var AnimationFrame = (
  /** @class */
  function() {
    function AnimationFrame2() {
      this.rafIDs = /* @__PURE__ */ new Map();
    }
    AnimationFrame2.prototype.request = function(key, callback) {
      var _this = this;
      this.cancel(key);
      var frameID = requestAnimationFrame(function(frame) {
        _this.rafIDs.delete(key);
        callback(frame);
      });
      this.rafIDs.set(key, frameID);
    };
    AnimationFrame2.prototype.cancel = function(key) {
      var rafID = this.rafIDs.get(key);
      if (rafID) {
        cancelAnimationFrame(rafID);
        this.rafIDs.delete(key);
      }
    };
    AnimationFrame2.prototype.cancelAll = function() {
      var _this = this;
      this.rafIDs.forEach(function(_, key) {
        _this.cancel(key);
      });
    };
    AnimationFrame2.prototype.getQueue = function() {
      var queue = [];
      this.rafIDs.forEach(function(_, key) {
        queue.push(key);
      });
      return queue;
    };
    return AnimationFrame2;
  }()
);

// node_modules/@material/slider/types.js
var TickMark;
(function(TickMark2) {
  TickMark2[TickMark2["ACTIVE"] = 0] = "ACTIVE";
  TickMark2[TickMark2["INACTIVE"] = 1] = "INACTIVE";
})(TickMark || (TickMark = {}));
var Thumb;
(function(Thumb2) {
  Thumb2[Thumb2["START"] = 1] = "START";
  Thumb2[Thumb2["END"] = 2] = "END";
})(Thumb || (Thumb = {}));

// node_modules/@material/slider/foundation.js
var AnimationKeys;
(function(AnimationKeys2) {
  AnimationKeys2["SLIDER_UPDATE"] = "slider_update";
})(AnimationKeys || (AnimationKeys = {}));
var HAS_WINDOW = typeof window !== "undefined";
var MDCSliderFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCSliderFoundation2, _super);
    function MDCSliderFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCSliderFoundation2.defaultAdapter), adapter)) || this;
      _this.initialStylesRemoved = false;
      _this.isDisabled = false;
      _this.isDiscrete = false;
      _this.step = numbers.STEP_SIZE;
      _this.minRange = numbers.MIN_RANGE;
      _this.hasTickMarks = false;
      _this.isRange = false;
      _this.thumb = null;
      _this.downEventClientX = null;
      _this.startThumbKnobWidth = 0;
      _this.endThumbKnobWidth = 0;
      _this.animFrame = new AnimationFrame();
      return _this;
    }
    Object.defineProperty(MDCSliderFoundation2, "defaultAdapter", {
      get: function() {
        return {
          hasClass: function() {
            return false;
          },
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          addThumbClass: function() {
            return void 0;
          },
          removeThumbClass: function() {
            return void 0;
          },
          getAttribute: function() {
            return null;
          },
          getInputValue: function() {
            return "";
          },
          setInputValue: function() {
            return void 0;
          },
          getInputAttribute: function() {
            return null;
          },
          setInputAttribute: function() {
            return null;
          },
          removeInputAttribute: function() {
            return null;
          },
          focusInput: function() {
            return void 0;
          },
          isInputFocused: function() {
            return false;
          },
          shouldHideFocusStylesForPointerEvents: function() {
            return false;
          },
          getThumbKnobWidth: function() {
            return 0;
          },
          getValueIndicatorContainerWidth: function() {
            return 0;
          },
          getThumbBoundingClientRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          getBoundingClientRect: function() {
            return { top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0 };
          },
          isRTL: function() {
            return false;
          },
          setThumbStyleProperty: function() {
            return void 0;
          },
          removeThumbStyleProperty: function() {
            return void 0;
          },
          setTrackActiveStyleProperty: function() {
            return void 0;
          },
          removeTrackActiveStyleProperty: function() {
            return void 0;
          },
          setValueIndicatorText: function() {
            return void 0;
          },
          getValueToAriaValueTextFn: function() {
            return null;
          },
          updateTickMarks: function() {
            return void 0;
          },
          setPointerCapture: function() {
            return void 0;
          },
          emitChangeEvent: function() {
            return void 0;
          },
          emitInputEvent: function() {
            return void 0;
          },
          emitDragStartEvent: function() {
            return void 0;
          },
          emitDragEndEvent: function() {
            return void 0;
          },
          registerEventHandler: function() {
            return void 0;
          },
          deregisterEventHandler: function() {
            return void 0;
          },
          registerThumbEventHandler: function() {
            return void 0;
          },
          deregisterThumbEventHandler: function() {
            return void 0;
          },
          registerInputEventHandler: function() {
            return void 0;
          },
          deregisterInputEventHandler: function() {
            return void 0;
          },
          registerBodyEventHandler: function() {
            return void 0;
          },
          deregisterBodyEventHandler: function() {
            return void 0;
          },
          registerWindowEventHandler: function() {
            return void 0;
          },
          deregisterWindowEventHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCSliderFoundation2.prototype.init = function() {
      var _this = this;
      this.isDisabled = this.adapter.hasClass(cssClasses.DISABLED);
      this.isDiscrete = this.adapter.hasClass(cssClasses.DISCRETE);
      this.hasTickMarks = this.adapter.hasClass(cssClasses.TICK_MARKS);
      this.isRange = this.adapter.hasClass(cssClasses.RANGE);
      var min = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_MIN, this.isRange ? Thumb.START : Thumb.END), attributes.INPUT_MIN);
      var max = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_MAX, Thumb.END), attributes.INPUT_MAX);
      var value = this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_VALUE, Thumb.END), attributes.INPUT_VALUE);
      var valueStart = this.isRange ? this.convertAttributeValueToNumber(this.adapter.getInputAttribute(attributes.INPUT_VALUE, Thumb.START), attributes.INPUT_VALUE) : min;
      var stepAttr = this.adapter.getInputAttribute(attributes.INPUT_STEP, Thumb.END);
      var step = stepAttr ? this.convertAttributeValueToNumber(stepAttr, attributes.INPUT_STEP) : this.step;
      var minRangeAttr = this.adapter.getAttribute(attributes.DATA_MIN_RANGE);
      var minRange = minRangeAttr ? this.convertAttributeValueToNumber(minRangeAttr, attributes.DATA_MIN_RANGE) : this.minRange;
      this.validateProperties({ min, max, value, valueStart, step, minRange });
      this.min = min;
      this.max = max;
      this.value = value;
      this.valueStart = valueStart;
      this.step = step;
      this.minRange = minRange;
      this.numDecimalPlaces = getNumDecimalPlaces(this.step);
      this.valueBeforeDownEvent = value;
      this.valueStartBeforeDownEvent = valueStart;
      this.mousedownOrTouchstartListener = this.handleMousedownOrTouchstart.bind(this);
      this.moveListener = this.handleMove.bind(this);
      this.pointerdownListener = this.handlePointerdown.bind(this);
      this.pointerupListener = this.handlePointerup.bind(this);
      this.thumbMouseenterListener = this.handleThumbMouseenter.bind(this);
      this.thumbMouseleaveListener = this.handleThumbMouseleave.bind(this);
      this.inputStartChangeListener = function() {
        _this.handleInputChange(Thumb.START);
      };
      this.inputEndChangeListener = function() {
        _this.handleInputChange(Thumb.END);
      };
      this.inputStartFocusListener = function() {
        _this.handleInputFocus(Thumb.START);
      };
      this.inputEndFocusListener = function() {
        _this.handleInputFocus(Thumb.END);
      };
      this.inputStartBlurListener = function() {
        _this.handleInputBlur(Thumb.START);
      };
      this.inputEndBlurListener = function() {
        _this.handleInputBlur(Thumb.END);
      };
      this.resizeListener = this.handleResize.bind(this);
      this.registerEventHandlers();
    };
    MDCSliderFoundation2.prototype.destroy = function() {
      this.deregisterEventHandlers();
    };
    MDCSliderFoundation2.prototype.setMin = function(value) {
      this.min = value;
      if (!this.isRange) {
        this.valueStart = value;
      }
      this.updateUI();
    };
    MDCSliderFoundation2.prototype.setMax = function(value) {
      this.max = value;
      this.updateUI();
    };
    MDCSliderFoundation2.prototype.getMin = function() {
      return this.min;
    };
    MDCSliderFoundation2.prototype.getMax = function() {
      return this.max;
    };
    MDCSliderFoundation2.prototype.getValue = function() {
      return this.value;
    };
    MDCSliderFoundation2.prototype.setValue = function(value) {
      if (this.isRange && value < this.valueStart + this.minRange) {
        throw new Error("end thumb value (" + value + ") must be >= start thumb " + ("value (" + this.valueStart + ") + min range (" + this.minRange + ")"));
      }
      this.updateValue(value, Thumb.END);
    };
    MDCSliderFoundation2.prototype.getValueStart = function() {
      if (!this.isRange) {
        throw new Error("`valueStart` is only applicable for range sliders.");
      }
      return this.valueStart;
    };
    MDCSliderFoundation2.prototype.setValueStart = function(valueStart) {
      if (!this.isRange) {
        throw new Error("`valueStart` is only applicable for range sliders.");
      }
      if (this.isRange && valueStart > this.value - this.minRange) {
        throw new Error("start thumb value (" + valueStart + ") must be <= end thumb " + ("value (" + this.value + ") - min range (" + this.minRange + ")"));
      }
      this.updateValue(valueStart, Thumb.START);
    };
    MDCSliderFoundation2.prototype.setStep = function(value) {
      this.step = value;
      this.numDecimalPlaces = getNumDecimalPlaces(value);
      this.updateUI();
    };
    MDCSliderFoundation2.prototype.setMinRange = function(value) {
      if (!this.isRange) {
        throw new Error("`minRange` is only applicable for range sliders.");
      }
      if (value < 0) {
        throw new Error("`minRange` must be non-negative. " + ("Current value: " + value));
      }
      if (this.value - this.valueStart < value) {
        throw new Error("start thumb value (" + this.valueStart + ") and end thumb value " + ("(" + this.value + ") must differ by at least " + value + "."));
      }
      this.minRange = value;
    };
    MDCSliderFoundation2.prototype.setIsDiscrete = function(value) {
      this.isDiscrete = value;
      this.updateValueIndicatorUI();
      this.updateTickMarksUI();
    };
    MDCSliderFoundation2.prototype.getStep = function() {
      return this.step;
    };
    MDCSliderFoundation2.prototype.getMinRange = function() {
      if (!this.isRange) {
        throw new Error("`minRange` is only applicable for range sliders.");
      }
      return this.minRange;
    };
    MDCSliderFoundation2.prototype.setHasTickMarks = function(value) {
      this.hasTickMarks = value;
      this.updateTickMarksUI();
    };
    MDCSliderFoundation2.prototype.getDisabled = function() {
      return this.isDisabled;
    };
    MDCSliderFoundation2.prototype.setDisabled = function(disabled) {
      this.isDisabled = disabled;
      if (disabled) {
        this.adapter.addClass(cssClasses.DISABLED);
        if (this.isRange) {
          this.adapter.setInputAttribute(attributes.INPUT_DISABLED, "", Thumb.START);
        }
        this.adapter.setInputAttribute(attributes.INPUT_DISABLED, "", Thumb.END);
      } else {
        this.adapter.removeClass(cssClasses.DISABLED);
        if (this.isRange) {
          this.adapter.removeInputAttribute(attributes.INPUT_DISABLED, Thumb.START);
        }
        this.adapter.removeInputAttribute(attributes.INPUT_DISABLED, Thumb.END);
      }
    };
    MDCSliderFoundation2.prototype.getIsRange = function() {
      return this.isRange;
    };
    MDCSliderFoundation2.prototype.layout = function(_a) {
      var _b = _a === void 0 ? {} : _a, skipUpdateUI = _b.skipUpdateUI;
      this.rect = this.adapter.getBoundingClientRect();
      if (this.isRange) {
        this.startThumbKnobWidth = this.adapter.getThumbKnobWidth(Thumb.START);
        this.endThumbKnobWidth = this.adapter.getThumbKnobWidth(Thumb.END);
      }
      if (!skipUpdateUI) {
        this.updateUI();
      }
    };
    MDCSliderFoundation2.prototype.handleResize = function() {
      this.layout();
    };
    MDCSliderFoundation2.prototype.handleDown = function(event) {
      if (this.isDisabled)
        return;
      this.valueStartBeforeDownEvent = this.valueStart;
      this.valueBeforeDownEvent = this.value;
      var clientX = event.clientX != null ? event.clientX : event.targetTouches[0].clientX;
      this.downEventClientX = clientX;
      var value = this.mapClientXOnSliderScale(clientX);
      this.thumb = this.getThumbFromDownEvent(clientX, value);
      if (this.thumb === null)
        return;
      this.handleDragStart(event, value, this.thumb);
      this.updateValue(value, this.thumb, { emitInputEvent: true });
    };
    MDCSliderFoundation2.prototype.handleMove = function(event) {
      if (this.isDisabled)
        return;
      event.preventDefault();
      var clientX = event.clientX != null ? event.clientX : event.targetTouches[0].clientX;
      var dragAlreadyStarted = this.thumb != null;
      this.thumb = this.getThumbFromMoveEvent(clientX);
      if (this.thumb === null)
        return;
      var value = this.mapClientXOnSliderScale(clientX);
      if (!dragAlreadyStarted) {
        this.handleDragStart(event, value, this.thumb);
        this.adapter.emitDragStartEvent(value, this.thumb);
      }
      this.updateValue(value, this.thumb, { emitInputEvent: true });
    };
    MDCSliderFoundation2.prototype.handleUp = function() {
      var _a, _b;
      if (this.isDisabled || this.thumb === null)
        return;
      if ((_b = (_a = this.adapter).shouldHideFocusStylesForPointerEvents) === null || _b === void 0 ? void 0 : _b.call(_a)) {
        this.handleInputBlur(this.thumb);
      }
      var oldValue = this.thumb === Thumb.START ? this.valueStartBeforeDownEvent : this.valueBeforeDownEvent;
      var newValue = this.thumb === Thumb.START ? this.valueStart : this.value;
      if (oldValue !== newValue) {
        this.adapter.emitChangeEvent(newValue, this.thumb);
      }
      this.adapter.emitDragEndEvent(newValue, this.thumb);
      this.thumb = null;
    };
    MDCSliderFoundation2.prototype.handleThumbMouseenter = function() {
      if (!this.isDiscrete || !this.isRange)
        return;
      this.adapter.addThumbClass(cssClasses.THUMB_WITH_INDICATOR, Thumb.START);
      this.adapter.addThumbClass(cssClasses.THUMB_WITH_INDICATOR, Thumb.END);
    };
    MDCSliderFoundation2.prototype.handleThumbMouseleave = function() {
      var _a, _b;
      if (!this.isDiscrete || !this.isRange)
        return;
      if (!((_b = (_a = this.adapter).shouldHideFocusStylesForPointerEvents) === null || _b === void 0 ? void 0 : _b.call(_a)) && (this.adapter.isInputFocused(Thumb.START) || this.adapter.isInputFocused(Thumb.END)) || this.thumb) {
        return;
      }
      this.adapter.removeThumbClass(cssClasses.THUMB_WITH_INDICATOR, Thumb.START);
      this.adapter.removeThumbClass(cssClasses.THUMB_WITH_INDICATOR, Thumb.END);
    };
    MDCSliderFoundation2.prototype.handleMousedownOrTouchstart = function(event) {
      var _this = this;
      var moveEventType = event.type === "mousedown" ? "mousemove" : "touchmove";
      this.adapter.registerBodyEventHandler(moveEventType, this.moveListener);
      var upHandler = function() {
        _this.handleUp();
        _this.adapter.deregisterBodyEventHandler(moveEventType, _this.moveListener);
        _this.adapter.deregisterEventHandler("mouseup", upHandler);
        _this.adapter.deregisterEventHandler("touchend", upHandler);
      };
      this.adapter.registerBodyEventHandler("mouseup", upHandler);
      this.adapter.registerBodyEventHandler("touchend", upHandler);
      this.handleDown(event);
    };
    MDCSliderFoundation2.prototype.handlePointerdown = function(event) {
      var isPrimaryButton = event.button === 0;
      if (!isPrimaryButton)
        return;
      if (event.pointerId != null) {
        this.adapter.setPointerCapture(event.pointerId);
      }
      this.adapter.registerEventHandler("pointermove", this.moveListener);
      this.handleDown(event);
    };
    MDCSliderFoundation2.prototype.handleInputChange = function(thumb) {
      var value = Number(this.adapter.getInputValue(thumb));
      if (thumb === Thumb.START) {
        this.setValueStart(value);
      } else {
        this.setValue(value);
      }
      this.adapter.emitChangeEvent(thumb === Thumb.START ? this.valueStart : this.value, thumb);
      this.adapter.emitInputEvent(thumb === Thumb.START ? this.valueStart : this.value, thumb);
    };
    MDCSliderFoundation2.prototype.handleInputFocus = function(thumb) {
      this.adapter.addThumbClass(cssClasses.THUMB_FOCUSED, thumb);
      if (!this.isDiscrete)
        return;
      this.adapter.addThumbClass(cssClasses.THUMB_WITH_INDICATOR, thumb);
      if (this.isRange) {
        var otherThumb = thumb === Thumb.START ? Thumb.END : Thumb.START;
        this.adapter.addThumbClass(cssClasses.THUMB_WITH_INDICATOR, otherThumb);
      }
    };
    MDCSliderFoundation2.prototype.handleInputBlur = function(thumb) {
      this.adapter.removeThumbClass(cssClasses.THUMB_FOCUSED, thumb);
      if (!this.isDiscrete)
        return;
      this.adapter.removeThumbClass(cssClasses.THUMB_WITH_INDICATOR, thumb);
      if (this.isRange) {
        var otherThumb = thumb === Thumb.START ? Thumb.END : Thumb.START;
        this.adapter.removeThumbClass(cssClasses.THUMB_WITH_INDICATOR, otherThumb);
      }
    };
    MDCSliderFoundation2.prototype.handleDragStart = function(event, value, thumb) {
      var _a, _b;
      this.adapter.emitDragStartEvent(value, thumb);
      this.adapter.focusInput(thumb);
      if ((_b = (_a = this.adapter).shouldHideFocusStylesForPointerEvents) === null || _b === void 0 ? void 0 : _b.call(_a)) {
        this.handleInputFocus(thumb);
      }
      event.preventDefault();
    };
    MDCSliderFoundation2.prototype.getThumbFromDownEvent = function(clientX, value) {
      if (!this.isRange)
        return Thumb.END;
      var thumbStartRect = this.adapter.getThumbBoundingClientRect(Thumb.START);
      var thumbEndRect = this.adapter.getThumbBoundingClientRect(Thumb.END);
      var inThumbStartBounds = clientX >= thumbStartRect.left && clientX <= thumbStartRect.right;
      var inThumbEndBounds = clientX >= thumbEndRect.left && clientX <= thumbEndRect.right;
      if (inThumbStartBounds && inThumbEndBounds) {
        return null;
      }
      if (inThumbStartBounds) {
        return Thumb.START;
      }
      if (inThumbEndBounds) {
        return Thumb.END;
      }
      if (value < this.valueStart) {
        return Thumb.START;
      }
      if (value > this.value) {
        return Thumb.END;
      }
      return value - this.valueStart <= this.value - value ? Thumb.START : Thumb.END;
    };
    MDCSliderFoundation2.prototype.getThumbFromMoveEvent = function(clientX) {
      if (this.thumb !== null)
        return this.thumb;
      if (this.downEventClientX === null) {
        throw new Error("`downEventClientX` is null after move event.");
      }
      var moveDistanceUnderThreshold = Math.abs(this.downEventClientX - clientX) < numbers.THUMB_UPDATE_MIN_PX;
      if (moveDistanceUnderThreshold)
        return this.thumb;
      var draggedThumbToLeft = clientX < this.downEventClientX;
      if (draggedThumbToLeft) {
        return this.adapter.isRTL() ? Thumb.END : Thumb.START;
      } else {
        return this.adapter.isRTL() ? Thumb.START : Thumb.END;
      }
    };
    MDCSliderFoundation2.prototype.updateUI = function(thumb) {
      if (thumb) {
        this.updateThumbAndInputAttributes(thumb);
      } else {
        this.updateThumbAndInputAttributes(Thumb.START);
        this.updateThumbAndInputAttributes(Thumb.END);
      }
      this.updateThumbAndTrackUI(thumb);
      this.updateValueIndicatorUI(thumb);
      this.updateTickMarksUI();
    };
    MDCSliderFoundation2.prototype.updateThumbAndInputAttributes = function(thumb) {
      if (!thumb)
        return;
      var value = this.isRange && thumb === Thumb.START ? this.valueStart : this.value;
      var valueStr = String(value);
      this.adapter.setInputAttribute(attributes.INPUT_VALUE, valueStr, thumb);
      if (this.isRange && thumb === Thumb.START) {
        this.adapter.setInputAttribute(attributes.INPUT_MIN, String(value + this.minRange), Thumb.END);
      } else if (this.isRange && thumb === Thumb.END) {
        this.adapter.setInputAttribute(attributes.INPUT_MAX, String(value - this.minRange), Thumb.START);
      }
      if (this.adapter.getInputValue(thumb) !== valueStr) {
        this.adapter.setInputValue(valueStr, thumb);
      }
      var valueToAriaValueTextFn = this.adapter.getValueToAriaValueTextFn();
      if (valueToAriaValueTextFn) {
        this.adapter.setInputAttribute(attributes.ARIA_VALUETEXT, valueToAriaValueTextFn(value, thumb), thumb);
      }
    };
    MDCSliderFoundation2.prototype.updateValueIndicatorUI = function(thumb) {
      if (!this.isDiscrete)
        return;
      var value = this.isRange && thumb === Thumb.START ? this.valueStart : this.value;
      this.adapter.setValueIndicatorText(value, thumb === Thumb.START ? Thumb.START : Thumb.END);
      if (!thumb && this.isRange) {
        this.adapter.setValueIndicatorText(this.valueStart, Thumb.START);
      }
    };
    MDCSliderFoundation2.prototype.updateTickMarksUI = function() {
      if (!this.isDiscrete || !this.hasTickMarks)
        return;
      var numTickMarksInactiveStart = (this.valueStart - this.min) / this.step;
      var numTickMarksActive = (this.value - this.valueStart) / this.step + 1;
      var numTickMarksInactiveEnd = (this.max - this.value) / this.step;
      var tickMarksInactiveStart = Array.from({ length: numTickMarksInactiveStart }).fill(TickMark.INACTIVE);
      var tickMarksActive = Array.from({ length: numTickMarksActive }).fill(TickMark.ACTIVE);
      var tickMarksInactiveEnd = Array.from({ length: numTickMarksInactiveEnd }).fill(TickMark.INACTIVE);
      this.adapter.updateTickMarks(tickMarksInactiveStart.concat(tickMarksActive).concat(tickMarksInactiveEnd));
    };
    MDCSliderFoundation2.prototype.mapClientXOnSliderScale = function(clientX) {
      var xPos = clientX - this.rect.left;
      var pctComplete = xPos / this.rect.width;
      if (this.adapter.isRTL()) {
        pctComplete = 1 - pctComplete;
      }
      var value = this.min + pctComplete * (this.max - this.min);
      if (value === this.max || value === this.min) {
        return value;
      }
      return Number(this.quantize(value).toFixed(this.numDecimalPlaces));
    };
    MDCSliderFoundation2.prototype.quantize = function(value) {
      var numSteps = Math.round((value - this.min) / this.step);
      return this.min + numSteps * this.step;
    };
    MDCSliderFoundation2.prototype.updateValue = function(value, thumb, _a) {
      var _b = _a === void 0 ? {} : _a, emitInputEvent = _b.emitInputEvent;
      value = this.clampValue(value, thumb);
      if (this.isRange && thumb === Thumb.START) {
        if (this.valueStart === value)
          return;
        this.valueStart = value;
      } else {
        if (this.value === value)
          return;
        this.value = value;
      }
      this.updateUI(thumb);
      if (emitInputEvent) {
        this.adapter.emitInputEvent(thumb === Thumb.START ? this.valueStart : this.value, thumb);
      }
    };
    MDCSliderFoundation2.prototype.clampValue = function(value, thumb) {
      value = Math.min(Math.max(value, this.min), this.max);
      var thumbStartMovedPastThumbEnd = this.isRange && thumb === Thumb.START && value > this.value - this.minRange;
      if (thumbStartMovedPastThumbEnd) {
        return this.value - this.minRange;
      }
      var thumbEndMovedPastThumbStart = this.isRange && thumb === Thumb.END && value < this.valueStart + this.minRange;
      if (thumbEndMovedPastThumbStart) {
        return this.valueStart + this.minRange;
      }
      return value;
    };
    MDCSliderFoundation2.prototype.updateThumbAndTrackUI = function(thumb) {
      var _this = this;
      var _a = this, max = _a.max, min = _a.min;
      var pctComplete = (this.value - this.valueStart) / (max - min);
      var rangePx = pctComplete * this.rect.width;
      var isRtl = this.adapter.isRTL();
      var transformProp = HAS_WINDOW ? getCorrectPropertyName(window, "transform") : "transform";
      if (this.isRange) {
        var thumbLeftPos_1 = this.adapter.isRTL() ? (max - this.value) / (max - min) * this.rect.width : (this.valueStart - min) / (max - min) * this.rect.width;
        var thumbRightPos_1 = thumbLeftPos_1 + rangePx;
        this.animFrame.request(AnimationKeys.SLIDER_UPDATE, function() {
          var trackAnimatesFromRight = !isRtl && thumb === Thumb.START || isRtl && thumb !== Thumb.START;
          if (trackAnimatesFromRight) {
            _this.adapter.setTrackActiveStyleProperty("transform-origin", "right");
            _this.adapter.setTrackActiveStyleProperty("left", "auto");
            _this.adapter.setTrackActiveStyleProperty("right", _this.rect.width - thumbRightPos_1 + "px");
          } else {
            _this.adapter.setTrackActiveStyleProperty("transform-origin", "left");
            _this.adapter.setTrackActiveStyleProperty("right", "auto");
            _this.adapter.setTrackActiveStyleProperty("left", thumbLeftPos_1 + "px");
          }
          _this.adapter.setTrackActiveStyleProperty(transformProp, "scaleX(" + pctComplete + ")");
          var thumbStartPos = isRtl ? thumbRightPos_1 : thumbLeftPos_1;
          var thumbEndPos = _this.adapter.isRTL() ? thumbLeftPos_1 : thumbRightPos_1;
          if (thumb === Thumb.START || !thumb || !_this.initialStylesRemoved) {
            _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbStartPos + "px)", Thumb.START);
            _this.alignValueIndicator(Thumb.START, thumbStartPos);
          }
          if (thumb === Thumb.END || !thumb || !_this.initialStylesRemoved) {
            _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbEndPos + "px)", Thumb.END);
            _this.alignValueIndicator(Thumb.END, thumbEndPos);
          }
          _this.removeInitialStyles(isRtl);
          _this.updateOverlappingThumbsUI(thumbStartPos, thumbEndPos, thumb);
        });
      } else {
        this.animFrame.request(AnimationKeys.SLIDER_UPDATE, function() {
          var thumbStartPos = isRtl ? _this.rect.width - rangePx : rangePx;
          _this.adapter.setThumbStyleProperty(transformProp, "translateX(" + thumbStartPos + "px)", Thumb.END);
          _this.alignValueIndicator(Thumb.END, thumbStartPos);
          _this.adapter.setTrackActiveStyleProperty(transformProp, "scaleX(" + pctComplete + ")");
          _this.removeInitialStyles(isRtl);
        });
      }
    };
    MDCSliderFoundation2.prototype.alignValueIndicator = function(thumb, thumbPos) {
      if (!this.isDiscrete)
        return;
      var thumbHalfWidth = this.adapter.getThumbBoundingClientRect(thumb).width / 2;
      var containerWidth = this.adapter.getValueIndicatorContainerWidth(thumb);
      var sliderWidth = this.adapter.getBoundingClientRect().width;
      if (containerWidth / 2 > thumbPos + thumbHalfWidth) {
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CARET_LEFT, thumbHalfWidth + "px", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CARET_RIGHT, "auto", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CARET_TRANSFORM, "translateX(-50%)", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CONTAINER_LEFT, "0", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CONTAINER_RIGHT, "auto", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CONTAINER_TRANSFORM, "none", thumb);
      } else if (containerWidth / 2 > sliderWidth - thumbPos + thumbHalfWidth) {
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CARET_LEFT, "auto", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CARET_RIGHT, thumbHalfWidth + "px", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CARET_TRANSFORM, "translateX(50%)", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CONTAINER_LEFT, "auto", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CONTAINER_RIGHT, "0", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CONTAINER_TRANSFORM, "none", thumb);
      } else {
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CARET_LEFT, "50%", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CARET_RIGHT, "auto", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CARET_TRANSFORM, "translateX(-50%)", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CONTAINER_LEFT, "50%", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CONTAINER_RIGHT, "auto", thumb);
        this.adapter.setThumbStyleProperty(strings.VAR_VALUE_INDICATOR_CONTAINER_TRANSFORM, "translateX(-50%)", thumb);
      }
    };
    MDCSliderFoundation2.prototype.removeInitialStyles = function(isRtl) {
      if (this.initialStylesRemoved)
        return;
      var position = isRtl ? "right" : "left";
      this.adapter.removeThumbStyleProperty(position, Thumb.END);
      if (this.isRange) {
        this.adapter.removeThumbStyleProperty(position, Thumb.START);
      }
      this.initialStylesRemoved = true;
      this.resetTrackAndThumbAnimation();
    };
    MDCSliderFoundation2.prototype.resetTrackAndThumbAnimation = function() {
      var _this = this;
      if (!this.isDiscrete)
        return;
      var transitionProp = HAS_WINDOW ? getCorrectPropertyName(window, "transition") : "transition";
      var transitionDefault = "none 0s ease 0s";
      this.adapter.setThumbStyleProperty(transitionProp, transitionDefault, Thumb.END);
      if (this.isRange) {
        this.adapter.setThumbStyleProperty(transitionProp, transitionDefault, Thumb.START);
      }
      this.adapter.setTrackActiveStyleProperty(transitionProp, transitionDefault);
      requestAnimationFrame(function() {
        _this.adapter.removeThumbStyleProperty(transitionProp, Thumb.END);
        _this.adapter.removeTrackActiveStyleProperty(transitionProp);
        if (_this.isRange) {
          _this.adapter.removeThumbStyleProperty(transitionProp, Thumb.START);
        }
      });
    };
    MDCSliderFoundation2.prototype.updateOverlappingThumbsUI = function(thumbStartPos, thumbEndPos, thumb) {
      var thumbsOverlap = false;
      if (this.adapter.isRTL()) {
        var startThumbLeftEdge = thumbStartPos - this.startThumbKnobWidth / 2;
        var endThumbRightEdge = thumbEndPos + this.endThumbKnobWidth / 2;
        thumbsOverlap = endThumbRightEdge >= startThumbLeftEdge;
      } else {
        var startThumbRightEdge = thumbStartPos + this.startThumbKnobWidth / 2;
        var endThumbLeftEdge = thumbEndPos - this.endThumbKnobWidth / 2;
        thumbsOverlap = startThumbRightEdge >= endThumbLeftEdge;
      }
      if (thumbsOverlap) {
        this.adapter.addThumbClass(
          cssClasses.THUMB_TOP,
          // If no thumb was dragged (in the case of initial layout), end
          // thumb is on top by default.
          thumb || Thumb.END
        );
        this.adapter.removeThumbClass(cssClasses.THUMB_TOP, thumb === Thumb.START ? Thumb.END : Thumb.START);
      } else {
        this.adapter.removeThumbClass(cssClasses.THUMB_TOP, Thumb.START);
        this.adapter.removeThumbClass(cssClasses.THUMB_TOP, Thumb.END);
      }
    };
    MDCSliderFoundation2.prototype.convertAttributeValueToNumber = function(attributeValue, attributeName) {
      if (attributeValue === null) {
        throw new Error("MDCSliderFoundation: `" + attributeName + "` must be non-null.");
      }
      var value = Number(attributeValue);
      if (isNaN(value)) {
        throw new Error("MDCSliderFoundation: `" + attributeName + "` value is `" + attributeValue + "`, but must be a number.");
      }
      return value;
    };
    MDCSliderFoundation2.prototype.validateProperties = function(_a) {
      var min = _a.min, max = _a.max, value = _a.value, valueStart = _a.valueStart, step = _a.step, minRange = _a.minRange;
      if (min >= max) {
        throw new Error("MDCSliderFoundation: min must be strictly less than max. " + ("Current: [min: " + min + ", max: " + max + "]"));
      }
      if (step <= 0) {
        throw new Error("MDCSliderFoundation: step must be a positive number. " + ("Current step: " + step));
      }
      if (this.isRange) {
        if (value < min || value > max || valueStart < min || valueStart > max) {
          throw new Error("MDCSliderFoundation: values must be in [min, max] range. " + ("Current values: [start value: " + valueStart + ", end value: ") + (value + ", min: " + min + ", max: " + max + "]"));
        }
        if (valueStart > value) {
          throw new Error("MDCSliderFoundation: start value must be <= end value. " + ("Current values: [start value: " + valueStart + ", end value: " + value + "]"));
        }
        if (minRange < 0) {
          throw new Error("MDCSliderFoundation: minimum range must be non-negative. " + ("Current min range: " + minRange));
        }
        if (value - valueStart < minRange) {
          throw new Error("MDCSliderFoundation: start value and end value must differ by at least " + (minRange + ". Current values: [start value: " + valueStart + ", ") + ("end value: " + value + "]"));
        }
        var numStepsValueStartFromMin = (valueStart - min) / step;
        var numStepsValueFromMin = (value - min) / step;
        if (!Number.isInteger(parseFloat(numStepsValueStartFromMin.toFixed(6))) || !Number.isInteger(parseFloat(numStepsValueFromMin.toFixed(6)))) {
          throw new Error("MDCSliderFoundation: Slider values must be valid based on the " + ("step value (" + step + "). Current values: [start value: ") + (valueStart + ", end value: " + value + ", min: " + min + "]"));
        }
      } else {
        if (value < min || value > max) {
          throw new Error("MDCSliderFoundation: value must be in [min, max] range. " + ("Current values: [value: " + value + ", min: " + min + ", max: " + max + "]"));
        }
        var numStepsValueFromMin = (value - min) / step;
        if (!Number.isInteger(parseFloat(numStepsValueFromMin.toFixed(6)))) {
          throw new Error("MDCSliderFoundation: Slider value must be valid based on the " + ("step value (" + step + "). Current value: " + value));
        }
      }
    };
    MDCSliderFoundation2.prototype.registerEventHandlers = function() {
      this.adapter.registerWindowEventHandler("resize", this.resizeListener);
      if (MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS) {
        this.adapter.registerEventHandler("pointerdown", this.pointerdownListener);
        this.adapter.registerEventHandler("pointerup", this.pointerupListener);
      } else {
        this.adapter.registerEventHandler("mousedown", this.mousedownOrTouchstartListener);
        this.adapter.registerEventHandler("touchstart", this.mousedownOrTouchstartListener);
      }
      if (this.isRange) {
        this.adapter.registerThumbEventHandler(Thumb.START, "mouseenter", this.thumbMouseenterListener);
        this.adapter.registerThumbEventHandler(Thumb.START, "mouseleave", this.thumbMouseleaveListener);
        this.adapter.registerInputEventHandler(Thumb.START, "change", this.inputStartChangeListener);
        this.adapter.registerInputEventHandler(Thumb.START, "focus", this.inputStartFocusListener);
        this.adapter.registerInputEventHandler(Thumb.START, "blur", this.inputStartBlurListener);
      }
      this.adapter.registerThumbEventHandler(Thumb.END, "mouseenter", this.thumbMouseenterListener);
      this.adapter.registerThumbEventHandler(Thumb.END, "mouseleave", this.thumbMouseleaveListener);
      this.adapter.registerInputEventHandler(Thumb.END, "change", this.inputEndChangeListener);
      this.adapter.registerInputEventHandler(Thumb.END, "focus", this.inputEndFocusListener);
      this.adapter.registerInputEventHandler(Thumb.END, "blur", this.inputEndBlurListener);
    };
    MDCSliderFoundation2.prototype.deregisterEventHandlers = function() {
      this.adapter.deregisterWindowEventHandler("resize", this.resizeListener);
      if (MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS) {
        this.adapter.deregisterEventHandler("pointerdown", this.pointerdownListener);
        this.adapter.deregisterEventHandler("pointerup", this.pointerupListener);
      } else {
        this.adapter.deregisterEventHandler("mousedown", this.mousedownOrTouchstartListener);
        this.adapter.deregisterEventHandler("touchstart", this.mousedownOrTouchstartListener);
      }
      if (this.isRange) {
        this.adapter.deregisterThumbEventHandler(Thumb.START, "mouseenter", this.thumbMouseenterListener);
        this.adapter.deregisterThumbEventHandler(Thumb.START, "mouseleave", this.thumbMouseleaveListener);
        this.adapter.deregisterInputEventHandler(Thumb.START, "change", this.inputStartChangeListener);
        this.adapter.deregisterInputEventHandler(Thumb.START, "focus", this.inputStartFocusListener);
        this.adapter.deregisterInputEventHandler(Thumb.START, "blur", this.inputStartBlurListener);
      }
      this.adapter.deregisterThumbEventHandler(Thumb.END, "mouseenter", this.thumbMouseenterListener);
      this.adapter.deregisterThumbEventHandler(Thumb.END, "mouseleave", this.thumbMouseleaveListener);
      this.adapter.deregisterInputEventHandler(Thumb.END, "change", this.inputEndChangeListener);
      this.adapter.deregisterInputEventHandler(Thumb.END, "focus", this.inputEndFocusListener);
      this.adapter.deregisterInputEventHandler(Thumb.END, "blur", this.inputEndBlurListener);
    };
    MDCSliderFoundation2.prototype.handlePointerup = function() {
      this.handleUp();
      this.adapter.deregisterEventHandler("pointermove", this.moveListener);
    };
    MDCSliderFoundation2.SUPPORTS_POINTER_EVENTS = HAS_WINDOW && Boolean(window.PointerEvent) && // #setPointerCapture is buggy on iOS, so we can't use pointer events
    // until the following bug is fixed:
    // https://bugs.webkit.org/show_bug.cgi?id=220196
    !isIOS();
    return MDCSliderFoundation2;
  }(MDCFoundation)
);
function isIOS() {
  return [
    "iPad Simulator",
    "iPhone Simulator",
    "iPod Simulator",
    "iPad",
    "iPhone",
    "iPod"
  ].includes(navigator.platform) || navigator.userAgent.includes("Mac") && "ontouchend" in document;
}
function getNumDecimalPlaces(n) {
  var match = /(?:\.(\d+))?(?:[eE]([+\-]?\d+))?$/.exec(String(n));
  if (!match)
    return 0;
  var fraction = match[1] || "";
  var exponent = match[2] || 0;
  return Math.max(
    0,
    // lower limit
    (fraction === "0" ? 0 : fraction.length) - Number(exponent)
  );
}

// node_modules/@material/slider/component.js
var MDCSlider = (
  /** @class */
  function(_super) {
    __extends(MDCSlider2, _super);
    function MDCSlider2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.skipInitialUIUpdate = false;
      _this.valueToAriaValueTextFn = null;
      return _this;
    }
    MDCSlider2.attachTo = function(root, options) {
      if (options === void 0) {
        options = {};
      }
      return new MDCSlider2(root, void 0, options);
    };
    MDCSlider2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        addClass: function(className) {
          _this.root.classList.add(className);
        },
        removeClass: function(className) {
          _this.root.classList.remove(className);
        },
        addThumbClass: function(className, thumb) {
          _this.getThumbEl(thumb).classList.add(className);
        },
        removeThumbClass: function(className, thumb) {
          _this.getThumbEl(thumb).classList.remove(className);
        },
        getAttribute: function(attribute) {
          return _this.root.getAttribute(attribute);
        },
        getInputValue: function(thumb) {
          return _this.getInput(thumb).value;
        },
        setInputValue: function(value, thumb) {
          _this.getInput(thumb).value = value;
        },
        getInputAttribute: function(attribute, thumb) {
          return _this.getInput(thumb).getAttribute(attribute);
        },
        setInputAttribute: function(attribute, value, thumb) {
          _this.getInput(thumb).setAttribute(attribute, value);
        },
        removeInputAttribute: function(attribute, thumb) {
          _this.getInput(thumb).removeAttribute(attribute);
        },
        focusInput: function(thumb) {
          _this.getInput(thumb).focus();
        },
        isInputFocused: function(thumb) {
          return _this.getInput(thumb) === document.activeElement;
        },
        shouldHideFocusStylesForPointerEvents: function() {
          return false;
        },
        getThumbKnobWidth: function(thumb) {
          return _this.getThumbEl(thumb).querySelector("." + cssClasses.THUMB_KNOB).getBoundingClientRect().width;
        },
        getThumbBoundingClientRect: function(thumb) {
          return _this.getThumbEl(thumb).getBoundingClientRect();
        },
        getBoundingClientRect: function() {
          return _this.root.getBoundingClientRect();
        },
        getValueIndicatorContainerWidth: function(thumb) {
          return _this.getThumbEl(thumb).querySelector("." + cssClasses.VALUE_INDICATOR_CONTAINER).getBoundingClientRect().width;
        },
        isRTL: function() {
          return getComputedStyle(_this.root).direction === "rtl";
        },
        setThumbStyleProperty: function(propertyName, value, thumb) {
          _this.getThumbEl(thumb).style.setProperty(propertyName, value);
        },
        removeThumbStyleProperty: function(propertyName, thumb) {
          _this.getThumbEl(thumb).style.removeProperty(propertyName);
        },
        setTrackActiveStyleProperty: function(propertyName, value) {
          _this.trackActive.style.setProperty(propertyName, value);
        },
        removeTrackActiveStyleProperty: function(propertyName) {
          _this.trackActive.style.removeProperty(propertyName);
        },
        setValueIndicatorText: function(value, thumb) {
          var valueIndicatorEl = _this.getThumbEl(thumb).querySelector("." + cssClasses.VALUE_INDICATOR_TEXT);
          valueIndicatorEl.textContent = String(value);
        },
        getValueToAriaValueTextFn: function() {
          return _this.valueToAriaValueTextFn;
        },
        updateTickMarks: function(tickMarks) {
          var tickMarksContainer = _this.root.querySelector("." + cssClasses.TICK_MARKS_CONTAINER);
          if (!tickMarksContainer) {
            tickMarksContainer = document.createElement("div");
            tickMarksContainer.classList.add(cssClasses.TICK_MARKS_CONTAINER);
            var track = _this.root.querySelector("." + cssClasses.TRACK);
            track.appendChild(tickMarksContainer);
          }
          if (tickMarks.length !== tickMarksContainer.children.length) {
            while (tickMarksContainer.firstChild) {
              tickMarksContainer.removeChild(tickMarksContainer.firstChild);
            }
            _this.addTickMarks(tickMarksContainer, tickMarks);
          } else {
            _this.updateTickMarks(tickMarksContainer, tickMarks);
          }
        },
        setPointerCapture: function(pointerId) {
          _this.root.setPointerCapture(pointerId);
        },
        emitChangeEvent: function(value, thumb) {
          _this.emit(events.CHANGE, { value, thumb });
        },
        emitInputEvent: function(value, thumb) {
          _this.emit(events.INPUT, { value, thumb });
        },
        emitDragStartEvent: function(_, thumb) {
          _this.getRipple(thumb).activate();
        },
        emitDragEndEvent: function(_, thumb) {
          _this.getRipple(thumb).deactivate();
        },
        registerEventHandler: function(evtType, handler) {
          _this.listen(evtType, handler);
        },
        deregisterEventHandler: function(evtType, handler) {
          _this.unlisten(evtType, handler);
        },
        registerThumbEventHandler: function(thumb, evtType, handler) {
          _this.getThumbEl(thumb).addEventListener(evtType, handler);
        },
        deregisterThumbEventHandler: function(thumb, evtType, handler) {
          _this.getThumbEl(thumb).removeEventListener(evtType, handler);
        },
        registerInputEventHandler: function(thumb, evtType, handler) {
          _this.getInput(thumb).addEventListener(evtType, handler);
        },
        deregisterInputEventHandler: function(thumb, evtType, handler) {
          _this.getInput(thumb).removeEventListener(evtType, handler);
        },
        registerBodyEventHandler: function(evtType, handler) {
          document.body.addEventListener(evtType, handler);
        },
        deregisterBodyEventHandler: function(evtType, handler) {
          document.body.removeEventListener(evtType, handler);
        },
        registerWindowEventHandler: function(evtType, handler) {
          window.addEventListener(evtType, handler);
        },
        deregisterWindowEventHandler: function(evtType, handler) {
          window.removeEventListener(evtType, handler);
        }
        // tslint:enable:object-literal-sort-keys
      };
      return new MDCSliderFoundation(adapter);
    };
    MDCSlider2.prototype.initialize = function(_a) {
      var _b = _a === void 0 ? {} : _a, skipInitialUIUpdate = _b.skipInitialUIUpdate;
      this.inputs = [].slice.call(this.root.querySelectorAll("." + cssClasses.INPUT));
      this.thumbs = [].slice.call(this.root.querySelectorAll("." + cssClasses.THUMB));
      this.trackActive = this.root.querySelector("." + cssClasses.TRACK_ACTIVE);
      this.ripples = this.createRipples();
      if (skipInitialUIUpdate) {
        this.skipInitialUIUpdate = true;
      }
    };
    MDCSlider2.prototype.initialSyncWithDOM = function() {
      this.foundation.layout({ skipUpdateUI: this.skipInitialUIUpdate });
    };
    MDCSlider2.prototype.layout = function() {
      this.foundation.layout();
    };
    MDCSlider2.prototype.getValueStart = function() {
      return this.foundation.getValueStart();
    };
    MDCSlider2.prototype.setValueStart = function(valueStart) {
      this.foundation.setValueStart(valueStart);
    };
    MDCSlider2.prototype.getValue = function() {
      return this.foundation.getValue();
    };
    MDCSlider2.prototype.setValue = function(value) {
      this.foundation.setValue(value);
    };
    MDCSlider2.prototype.getDisabled = function() {
      return this.foundation.getDisabled();
    };
    MDCSlider2.prototype.setDisabled = function(disabled) {
      this.foundation.setDisabled(disabled);
    };
    MDCSlider2.prototype.setValueToAriaValueTextFn = function(mapFn) {
      this.valueToAriaValueTextFn = mapFn;
    };
    MDCSlider2.prototype.getThumbEl = function(thumb) {
      return thumb === Thumb.END ? this.thumbs[this.thumbs.length - 1] : this.thumbs[0];
    };
    MDCSlider2.prototype.getInput = function(thumb) {
      return thumb === Thumb.END ? this.inputs[this.inputs.length - 1] : this.inputs[0];
    };
    MDCSlider2.prototype.getRipple = function(thumb) {
      return thumb === Thumb.END ? this.ripples[this.ripples.length - 1] : this.ripples[0];
    };
    MDCSlider2.prototype.addTickMarks = function(tickMarkContainer, tickMarks) {
      var fragment = document.createDocumentFragment();
      for (var i = 0; i < tickMarks.length; i++) {
        var div = document.createElement("div");
        var tickMarkClass = tickMarks[i] === TickMark.ACTIVE ? cssClasses.TICK_MARK_ACTIVE : cssClasses.TICK_MARK_INACTIVE;
        div.classList.add(tickMarkClass);
        fragment.appendChild(div);
      }
      tickMarkContainer.appendChild(fragment);
    };
    MDCSlider2.prototype.updateTickMarks = function(tickMarkContainer, tickMarks) {
      var tickMarkEls = Array.from(tickMarkContainer.children);
      for (var i = 0; i < tickMarkEls.length; i++) {
        if (tickMarks[i] === TickMark.ACTIVE) {
          tickMarkEls[i].classList.add(cssClasses.TICK_MARK_ACTIVE);
          tickMarkEls[i].classList.remove(cssClasses.TICK_MARK_INACTIVE);
        } else {
          tickMarkEls[i].classList.add(cssClasses.TICK_MARK_INACTIVE);
          tickMarkEls[i].classList.remove(cssClasses.TICK_MARK_ACTIVE);
        }
      }
    };
    MDCSlider2.prototype.createRipples = function() {
      var ripples = [];
      var rippleSurfaces = [].slice.call(this.root.querySelectorAll("." + cssClasses.THUMB));
      var _loop_1 = function(i2) {
        var rippleSurface = rippleSurfaces[i2];
        var input = this_1.inputs[i2];
        var adapter = __assign(__assign({}, MDCRipple.createAdapter(this_1)), { addClass: function(className) {
          rippleSurface.classList.add(className);
        }, computeBoundingRect: function() {
          return rippleSurface.getBoundingClientRect();
        }, deregisterInteractionHandler: function(evtType, handler) {
          input.removeEventListener(evtType, handler);
        }, isSurfaceActive: function() {
          return matches(input, ":active");
        }, isUnbounded: function() {
          return true;
        }, registerInteractionHandler: function(evtType, handler) {
          input.addEventListener(evtType, handler, applyPassive());
        }, removeClass: function(className) {
          rippleSurface.classList.remove(className);
        }, updateCssVariable: function(varName, value) {
          rippleSurface.style.setProperty(varName, value);
        } });
        var ripple = new MDCRipple(rippleSurface, new MDCRippleFoundation(adapter));
        ripple.unbounded = true;
        ripples.push(ripple);
      };
      var this_1 = this;
      for (var i = 0; i < rippleSurfaces.length; i++) {
        _loop_1(i);
      }
      return ripples;
    };
    return MDCSlider2;
  }(MDCComponent)
);

// node_modules/@smui/slider/dist/Slider.svelte
var file = "node_modules/@smui/slider/dist/Slider.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[92] = list[i];
  return child_ctx;
}
function create_else_block_1(ctx) {
  let input_1;
  let input_1_class_value;
  let mounted;
  let dispose;
  let input_1_levels = [
    {
      class: input_1_class_value = classMap({
        [
          /*input$class*/
          ctx[13]
        ]: true,
        "mdc-slider__input": true
      })
    },
    { type: "range" },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    { step: (
      /*step*/
      ctx[9]
    ) },
    { min: (
      /*min*/
      ctx[10]
    ) },
    { max: (
      /*max*/
      ctx[11]
    ) },
    /*inputProps*/
    ctx[33],
    /*inputAttrs*/
    ctx[24],
    prefixFilter(
      /*$$restProps*/
      ctx[37],
      "input$"
    )
  ];
  let input_data = {};
  for (let i = 0; i < input_1_levels.length; i += 1) {
    input_data = assign(input_data, input_1_levels[i]);
  }
  const block = {
    c: function create() {
      input_1 = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input_1 = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        step: true,
        min: true,
        max: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input_1, input_data);
      add_location(input_1, file, 56, 4, 1267);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input_1, anchor);
      if (input_1.autofocus)
        input_1.focus();
      ctx[62](input_1);
      set_input_value(
        input_1,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input_1,
            "change",
            /*input_1_change_input_handler*/
            ctx[63]
          ),
          listen_dev(
            input_1,
            "input",
            /*input_1_change_input_handler*/
            ctx[63]
          ),
          listen_dev(
            input_1,
            "blur",
            /*blur_handler_2*/
            ctx[56],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input_1,
            "focus",
            /*focus_handler_2*/
            ctx[57],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input_1, input_data = get_spread_update(input_1_levels, [
        dirty[0] & /*input$class*/
        8192 && input_1_class_value !== (input_1_class_value = classMap({
          [
            /*input$class*/
            ctx2[13]
          ]: true,
          "mdc-slider__input": true
        })) && { class: input_1_class_value },
        { type: "range" },
        dirty[0] & /*disabled*/
        32 && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        dirty[0] & /*step*/
        512 && { step: (
          /*step*/
          ctx2[9]
        ) },
        dirty[0] & /*min*/
        1024 && { min: (
          /*min*/
          ctx2[10]
        ) },
        dirty[0] & /*max*/
        2048 && { max: (
          /*max*/
          ctx2[11]
        ) },
        /*inputProps*/
        ctx2[33],
        dirty[0] & /*inputAttrs*/
        16777216 && /*inputAttrs*/
        ctx2[24],
        dirty[1] & /*$$restProps*/
        64 && prefixFilter(
          /*$$restProps*/
          ctx2[37],
          "input$"
        )
      ]));
      if (dirty[0] & /*value*/
      1) {
        set_input_value(
          input_1,
          /*value*/
          ctx2[0]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input_1);
      }
      ctx[62](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(56:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let input0;
  let input0_class_value;
  let t;
  let input1;
  let input1_class_value;
  let mounted;
  let dispose;
  let input0_levels = [
    {
      class: input0_class_value = classMap({
        [
          /*input$class*/
          ctx[13]
        ]: true,
        "mdc-slider__input": true
      })
    },
    { type: "range" },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    { step: (
      /*step*/
      ctx[9]
    ) },
    { min: (
      /*min*/
      ctx[10]
    ) },
    { max: (
      /*end*/
      ctx[2]
    ) },
    /*inputStartAttrs*/
    ctx[25],
    prefixFilter(
      /*$$restProps*/
      ctx[37],
      "input$"
    )
  ];
  let input_data_1 = {};
  for (let i = 0; i < input0_levels.length; i += 1) {
    input_data_1 = assign(input_data_1, input0_levels[i]);
  }
  let input1_levels = [
    {
      class: input1_class_value = classMap({
        [
          /*input$class*/
          ctx[13]
        ]: true,
        "mdc-slider__input": true
      })
    },
    { type: "range" },
    { disabled: (
      /*disabled*/
      ctx[5]
    ) },
    { step: (
      /*step*/
      ctx[9]
    ) },
    { min: (
      /*start*/
      ctx[1]
    ) },
    { max: (
      /*max*/
      ctx[11]
    ) },
    /*inputProps*/
    ctx[33],
    /*inputAttrs*/
    ctx[24],
    prefixFilter(
      /*$$restProps*/
      ctx[37],
      "input$"
    )
  ];
  let input_data = {};
  for (let i = 0; i < input1_levels.length; i += 1) {
    input_data = assign(input_data, input1_levels[i]);
  }
  const block = {
    c: function create() {
      input0 = element("input");
      t = space();
      input1 = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input0 = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        step: true,
        min: true,
        max: true
      });
      t = claim_space(nodes);
      input1 = claim_element(nodes, "INPUT", {
        class: true,
        type: true,
        step: true,
        min: true,
        max: true
      });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input0, input_data_1);
      add_location(input0, file, 20, 4, 545);
      set_attributes(input1, input_data);
      add_location(input1, file, 37, 4, 895);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input0, anchor);
      if (input0.autofocus)
        input0.focus();
      ctx[58](input0);
      set_input_value(
        input0,
        /*start*/
        ctx[1]
      );
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, input1, anchor);
      if (input1.autofocus)
        input1.focus();
      ctx[60](input1);
      set_input_value(
        input1,
        /*end*/
        ctx[2]
      );
      if (!mounted) {
        dispose = [
          listen_dev(
            input0,
            "change",
            /*input0_change_input_handler*/
            ctx[59]
          ),
          listen_dev(
            input0,
            "input",
            /*input0_change_input_handler*/
            ctx[59]
          ),
          listen_dev(
            input0,
            "blur",
            /*blur_handler*/
            ctx[54],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input0,
            "focus",
            /*focus_handler*/
            ctx[55],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input1,
            "change",
            /*input1_change_input_handler*/
            ctx[61]
          ),
          listen_dev(
            input1,
            "input",
            /*input1_change_input_handler*/
            ctx[61]
          ),
          listen_dev(
            input1,
            "blur",
            /*blur_handler_1*/
            ctx[52],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            input1,
            "focus",
            /*focus_handler_1*/
            ctx[53],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      set_attributes(input0, input_data_1 = get_spread_update(input0_levels, [
        dirty[0] & /*input$class*/
        8192 && input0_class_value !== (input0_class_value = classMap({
          [
            /*input$class*/
            ctx2[13]
          ]: true,
          "mdc-slider__input": true
        })) && { class: input0_class_value },
        { type: "range" },
        dirty[0] & /*disabled*/
        32 && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        dirty[0] & /*step*/
        512 && { step: (
          /*step*/
          ctx2[9]
        ) },
        dirty[0] & /*min*/
        1024 && { min: (
          /*min*/
          ctx2[10]
        ) },
        dirty[0] & /*end*/
        4 && { max: (
          /*end*/
          ctx2[2]
        ) },
        dirty[0] & /*inputStartAttrs*/
        33554432 && /*inputStartAttrs*/
        ctx2[25],
        dirty[1] & /*$$restProps*/
        64 && prefixFilter(
          /*$$restProps*/
          ctx2[37],
          "input$"
        )
      ]));
      if (dirty[0] & /*start*/
      2) {
        set_input_value(
          input0,
          /*start*/
          ctx2[1]
        );
      }
      set_attributes(input1, input_data = get_spread_update(input1_levels, [
        dirty[0] & /*input$class*/
        8192 && input1_class_value !== (input1_class_value = classMap({
          [
            /*input$class*/
            ctx2[13]
          ]: true,
          "mdc-slider__input": true
        })) && { class: input1_class_value },
        { type: "range" },
        dirty[0] & /*disabled*/
        32 && { disabled: (
          /*disabled*/
          ctx2[5]
        ) },
        dirty[0] & /*step*/
        512 && { step: (
          /*step*/
          ctx2[9]
        ) },
        dirty[0] & /*start*/
        2 && { min: (
          /*start*/
          ctx2[1]
        ) },
        dirty[0] & /*max*/
        2048 && { max: (
          /*max*/
          ctx2[11]
        ) },
        /*inputProps*/
        ctx2[33],
        dirty[0] & /*inputAttrs*/
        16777216 && /*inputAttrs*/
        ctx2[24],
        dirty[1] & /*$$restProps*/
        64 && prefixFilter(
          /*$$restProps*/
          ctx2[37],
          "input$"
        )
      ]));
      if (dirty[0] & /*end*/
      4) {
        set_input_value(
          input1,
          /*end*/
          ctx2[2]
        );
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input0);
        detach_dev(t);
        detach_dev(input1);
      }
      ctx[58](null);
      ctx[60](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(20:2) {#if range}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let div;
  let each_value = ensure_array_like_dev(
    /*currentTickMarks*/
    ctx[31]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const block = {
    c: function create() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div_nodes);
      }
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "mdc-slider__tick-marks");
      add_location(div, file, 87, 6, 2003);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p: function update(ctx2, dirty) {
      if (dirty[1] & /*currentTickMarks*/
      1) {
        each_value = ensure_array_like_dev(
          /*currentTickMarks*/
          ctx2[31]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(87:4) {#if discrete && tickMarks && step > 0}",
    ctx
  });
  return block;
}
function create_each_block(ctx) {
  let div;
  let div_class_value;
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", div_class_value = /*tickMark*/
      ctx[92] === TickMark.ACTIVE ? "mdc-slider__tick-mark--active" : "mdc-slider__tick-mark--inactive");
      add_location(div, file, 89, 10, 2095);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty[1] & /*currentTickMarks*/
      1 && div_class_value !== (div_class_value = /*tickMark*/
      ctx2[92] === TickMark.ACTIVE ? "mdc-slider__tick-mark--active" : "mdc-slider__tick-mark--inactive")) {
        attr_dev(div, "class", div_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(89:8) {#each currentTickMarks as tickMark}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let div1;
  let t;
  let div0;
  let div1_class_value;
  let div1_style_value;
  let Ripple_action;
  let mounted;
  let dispose;
  let if_block = (
    /*discrete*/
    ctx[7] && create_if_block_3(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div0 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      if (if_block)
        if_block.l(div1_nodes);
      t = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "mdc-slider__thumb-knob");
      add_location(div0, file, 185, 6, 5243);
      attr_dev(div1, "class", div1_class_value = classMap({
        "mdc-slider__thumb": true,
        .../*thumbClasses*/
        ctx[23]
      }));
      attr_dev(div1, "style", div1_style_value = Object.entries(
        /*thumbStyles*/
        ctx[27]
      ).map(func_3).join(" "));
      add_location(div1, file, 158, 4, 4337);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t);
      append_hydration_dev(div1, div0);
      ctx[74](div0);
      ctx[75](div1);
      if (!mounted) {
        dispose = action_destroyer(Ripple_action = dist_default.call(null, div1, {
          unbounded: true,
          disabled: (
            /*disabled*/
            ctx[5]
          ),
          active: (
            /*thumbRippleActive*/
            ctx[29]
          ),
          eventTarget: (
            /*input*/
            ctx[15]
          ),
          activeTarget: (
            /*input*/
            ctx[15]
          ),
          addClass: (
            /*Ripple_function_6*/
            ctx[76]
          ),
          removeClass: (
            /*Ripple_function_7*/
            ctx[77]
          ),
          addStyle: (
            /*Ripple_function_8*/
            ctx[78]
          )
        }));
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*discrete*/
        ctx2[7]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          if_block.m(div1, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty[0] & /*thumbClasses*/
      8388608 && div1_class_value !== (div1_class_value = classMap({
        "mdc-slider__thumb": true,
        .../*thumbClasses*/
        ctx2[23]
      }))) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (dirty[0] & /*thumbStyles*/
      134217728 && div1_style_value !== (div1_style_value = Object.entries(
        /*thumbStyles*/
        ctx2[27]
      ).map(func_3).join(" "))) {
        attr_dev(div1, "style", div1_style_value);
      }
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & /*disabled, thumbRippleActive, input*/
      536903712)
        Ripple_action.update.call(null, {
          unbounded: true,
          disabled: (
            /*disabled*/
            ctx2[5]
          ),
          active: (
            /*thumbRippleActive*/
            ctx2[29]
          ),
          eventTarget: (
            /*input*/
            ctx2[15]
          ),
          activeTarget: (
            /*input*/
            ctx2[15]
          ),
          addClass: (
            /*Ripple_function_6*/
            ctx2[76]
          ),
          removeClass: (
            /*Ripple_function_7*/
            ctx2[77]
          ),
          addStyle: (
            /*Ripple_function_8*/
            ctx2[78]
          )
        });
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (if_block)
        if_block.d();
      ctx[74](null);
      ctx[75](null);
      mounted = false;
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(158:2) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let div1;
  let t0;
  let div0;
  let div1_class_value;
  let div1_style_value;
  let Ripple_action;
  let t1;
  let div3;
  let t2;
  let div2;
  let div3_class_value;
  let div3_style_value;
  let Ripple_action_1;
  let mounted;
  let dispose;
  let if_block0 = (
    /*discrete*/
    ctx[7] && create_if_block_2(ctx)
  );
  let if_block1 = (
    /*discrete*/
    ctx[7] && create_if_block_1(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      div3 = element("div");
      if (if_block1)
        if_block1.c();
      t2 = space();
      div2 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(nodes);
      div3 = claim_element(nodes, "DIV", { class: true, style: true });
      var div3_nodes = children(div3);
      if (if_block1)
        if_block1.l(div3_nodes);
      t2 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      children(div2).forEach(detach_dev);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "mdc-slider__thumb-knob");
      add_location(div0, file, 126, 6, 3266);
      attr_dev(div1, "class", div1_class_value = classMap({
        "mdc-slider__thumb": true,
        .../*thumbStartClasses*/
        ctx[22]
      }));
      attr_dev(div1, "style", div1_style_value = Object.entries(
        /*thumbStartStyles*/
        ctx[28]
      ).map(func_1).join(" "));
      add_location(div1, file, 99, 4, 2326);
      attr_dev(div2, "class", "mdc-slider__thumb-knob");
      add_location(div2, file, 155, 6, 4251);
      attr_dev(div3, "class", div3_class_value = classMap({
        "mdc-slider__thumb": true,
        .../*thumbClasses*/
        ctx[23]
      }));
      attr_dev(div3, "style", div3_style_value = Object.entries(
        /*thumbStyles*/
        ctx[27]
      ).map(func_2).join(" "));
      add_location(div3, file, 128, 4, 3347);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      ctx[64](div0);
      ctx[65](div1);
      insert_hydration_dev(target, t1, anchor);
      insert_hydration_dev(target, div3, anchor);
      if (if_block1)
        if_block1.m(div3, null);
      append_hydration_dev(div3, t2);
      append_hydration_dev(div3, div2);
      ctx[69](div2);
      ctx[70](div3);
      if (!mounted) {
        dispose = [
          action_destroyer(Ripple_action = dist_default.call(null, div1, {
            unbounded: true,
            disabled: (
              /*disabled*/
              ctx[5]
            ),
            active: (
              /*thumbStartRippleActive*/
              ctx[30]
            ),
            eventTarget: (
              /*inputStart*/
              ctx[16]
            ),
            activeTarget: (
              /*inputStart*/
              ctx[16]
            ),
            addClass: (
              /*Ripple_function*/
              ctx[66]
            ),
            removeClass: (
              /*Ripple_function_1*/
              ctx[67]
            ),
            addStyle: (
              /*Ripple_function_2*/
              ctx[68]
            )
          })),
          action_destroyer(Ripple_action_1 = dist_default.call(null, div3, {
            unbounded: true,
            disabled: (
              /*disabled*/
              ctx[5]
            ),
            active: (
              /*thumbRippleActive*/
              ctx[29]
            ),
            eventTarget: (
              /*input*/
              ctx[15]
            ),
            activeTarget: (
              /*input*/
              ctx[15]
            ),
            addClass: (
              /*Ripple_function_3*/
              ctx[71]
            ),
            removeClass: (
              /*Ripple_function_4*/
              ctx[72]
            ),
            addStyle: (
              /*Ripple_function_5*/
              ctx[73]
            )
          }))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (
        /*discrete*/
        ctx2[7]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2(ctx2);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*thumbStartClasses*/
      4194304 && div1_class_value !== (div1_class_value = classMap({
        "mdc-slider__thumb": true,
        .../*thumbStartClasses*/
        ctx2[22]
      }))) {
        attr_dev(div1, "class", div1_class_value);
      }
      if (dirty[0] & /*thumbStartStyles*/
      268435456 && div1_style_value !== (div1_style_value = Object.entries(
        /*thumbStartStyles*/
        ctx2[28]
      ).map(func_1).join(" "))) {
        attr_dev(div1, "style", div1_style_value);
      }
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & /*disabled, thumbStartRippleActive, inputStart*/
      1073807392)
        Ripple_action.update.call(null, {
          unbounded: true,
          disabled: (
            /*disabled*/
            ctx2[5]
          ),
          active: (
            /*thumbStartRippleActive*/
            ctx2[30]
          ),
          eventTarget: (
            /*inputStart*/
            ctx2[16]
          ),
          activeTarget: (
            /*inputStart*/
            ctx2[16]
          ),
          addClass: (
            /*Ripple_function*/
            ctx2[66]
          ),
          removeClass: (
            /*Ripple_function_1*/
            ctx2[67]
          ),
          addStyle: (
            /*Ripple_function_2*/
            ctx2[68]
          )
        });
      if (
        /*discrete*/
        ctx2[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          if_block1.m(div3, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (dirty[0] & /*thumbClasses*/
      8388608 && div3_class_value !== (div3_class_value = classMap({
        "mdc-slider__thumb": true,
        .../*thumbClasses*/
        ctx2[23]
      }))) {
        attr_dev(div3, "class", div3_class_value);
      }
      if (dirty[0] & /*thumbStyles*/
      134217728 && div3_style_value !== (div3_style_value = Object.entries(
        /*thumbStyles*/
        ctx2[27]
      ).map(func_2).join(" "))) {
        attr_dev(div3, "style", div3_style_value);
      }
      if (Ripple_action_1 && is_function(Ripple_action_1.update) && dirty[0] & /*disabled, thumbRippleActive, input*/
      536903712)
        Ripple_action_1.update.call(null, {
          unbounded: true,
          disabled: (
            /*disabled*/
            ctx2[5]
          ),
          active: (
            /*thumbRippleActive*/
            ctx2[29]
          ),
          eventTarget: (
            /*input*/
            ctx2[15]
          ),
          activeTarget: (
            /*input*/
            ctx2[15]
          ),
          addClass: (
            /*Ripple_function_3*/
            ctx2[71]
          ),
          removeClass: (
            /*Ripple_function_4*/
            ctx2[72]
          ),
          addStyle: (
            /*Ripple_function_5*/
            ctx2[73]
          )
        });
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
        detach_dev(t1);
        detach_dev(div3);
      }
      if (if_block0)
        if_block0.d();
      ctx[64](null);
      ctx[65](null);
      if (if_block1)
        if_block1.d();
      ctx[69](null);
      ctx[70](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(99:2) {#if range}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let div1;
  let div0;
  let span;
  let t;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      t = text(
        /*value*/
        ctx[0]
      );
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "aria-hidden": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      span = claim_element(div0_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*value*/
        ctx[0]
      );
      span_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "mdc-slider__value-indicator-text");
      add_location(span, file, 181, 12, 5131);
      attr_dev(div0, "class", "mdc-slider__value-indicator");
      add_location(div0, file, 180, 10, 5077);
      attr_dev(div1, "class", "mdc-slider__value-indicator-container");
      attr_dev(div1, "aria-hidden", "true");
      add_location(div1, file, 179, 8, 4996);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, span);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*value*/
      1)
        set_data_dev(
          t,
          /*value*/
          ctx2[0]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(179:6) {#if discrete}",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let div1;
  let div0;
  let span;
  let t;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      t = text(
        /*start*/
        ctx[1]
      );
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "aria-hidden": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      span = claim_element(div0_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*start*/
        ctx[1]
      );
      span_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "mdc-slider__value-indicator-text");
      add_location(span, file, 122, 12, 3154);
      attr_dev(div0, "class", "mdc-slider__value-indicator");
      add_location(div0, file, 121, 10, 3100);
      attr_dev(div1, "class", "mdc-slider__value-indicator-container");
      attr_dev(div1, "aria-hidden", "true");
      add_location(div1, file, 120, 8, 3019);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, span);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*start*/
      2)
        set_data_dev(
          t,
          /*start*/
          ctx2[1]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(120:6) {#if discrete}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div1;
  let div0;
  let span;
  let t;
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      t = text(
        /*end*/
        ctx[2]
      );
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, "aria-hidden": true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      span = claim_element(div0_nodes, "SPAN", { class: true });
      var span_nodes = children(span);
      t = claim_text(
        span_nodes,
        /*end*/
        ctx[2]
      );
      span_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "mdc-slider__value-indicator-text");
      add_location(span, file, 151, 12, 4141);
      attr_dev(div0, "class", "mdc-slider__value-indicator");
      add_location(div0, file, 150, 10, 4087);
      attr_dev(div1, "class", "mdc-slider__value-indicator-container");
      attr_dev(div1, "aria-hidden", "true");
      add_location(div1, file, 149, 8, 4006);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, span);
      append_hydration_dev(span, t);
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*end*/
      4)
        set_data_dev(
          t,
          /*end*/
          ctx2[2]
        );
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(149:6) {#if discrete}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div4;
  let t0;
  let div3;
  let div0;
  let t1;
  let div2;
  let div1;
  let div1_style_value;
  let t2;
  let t3;
  let div4_class_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*range*/
      ctx2[6]
    )
      return create_if_block_5;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx, [-1, -1, -1, -1]);
  let if_block0 = current_block_type(ctx);
  let if_block1 = (
    /*discrete*/
    ctx[7] && /*tickMarks*/
    ctx[8] && /*step*/
    ctx[9] > 0 && create_if_block_4(ctx)
  );
  function select_block_type_1(ctx2, dirty) {
    if (
      /*range*/
      ctx2[6]
    )
      return create_if_block;
    return create_else_block;
  }
  let current_block_type_1 = select_block_type_1(ctx, [-1, -1, -1, -1]);
  let if_block2 = current_block_type_1(ctx);
  let div4_levels = [
    {
      class: div4_class_value = Object.entries({
        [
          /*className*/
          ctx[4]
        ]: true,
        "mdc-slider": true,
        "mdc-slider--range": (
          /*range*/
          ctx[6]
        ),
        "mdc-slider--discrete": (
          /*discrete*/
          ctx[7]
        ),
        "mdc-slider--tick-marks": (
          /*discrete*/
          ctx[7] && /*tickMarks*/
          ctx[8]
        ),
        "mdc-slider--disabled": (
          /*disabled*/
          ctx[5]
        ),
        .../*internalClasses*/
        ctx[21]
      }).filter(func_4).map(func_5).join(" ")
    },
    /*range*/
    ctx[6] ? {
      "data-min-range": `${/*minRange*/
      ctx[12]}`
    } : {},
    exclude(
      /*$$restProps*/
      ctx[37],
      ["input$"]
    )
  ];
  let div_data_4 = {};
  for (let i = 0; i < div4_levels.length; i += 1) {
    div_data_4 = assign(div_data_4, div4_levels[i]);
  }
  const block = {
    c: function create() {
      div4 = element("div");
      if_block0.c();
      t0 = space();
      div3 = element("div");
      div0 = element("div");
      t1 = space();
      div2 = element("div");
      div1 = element("div");
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if_block2.c();
      this.h();
    },
    l: function claim(nodes) {
      div4 = claim_element(nodes, "DIV", { class: true });
      var div4_nodes = children(div4);
      if_block0.l(div4_nodes);
      t0 = claim_space(div4_nodes);
      div3 = claim_element(div4_nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true, style: true });
      children(div1).forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      if (if_block1)
        if_block1.l(div3_nodes);
      div3_nodes.forEach(detach_dev);
      t3 = claim_space(div4_nodes);
      if_block2.l(div4_nodes);
      div4_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "mdc-slider__track--inactive");
      add_location(div0, file, 77, 4, 1660);
      attr_dev(div1, "class", "mdc-slider__track--active_fill");
      attr_dev(div1, "style", div1_style_value = Object.entries(
        /*trackActiveStyles*/
        ctx[26]
      ).map(func).join(" "));
      add_location(div1, file, 79, 6, 1754);
      attr_dev(div2, "class", "mdc-slider__track--active");
      add_location(div2, file, 78, 4, 1708);
      attr_dev(div3, "class", "mdc-slider__track");
      add_location(div3, file, 76, 2, 1624);
      set_attributes(div4, div_data_4);
      add_location(div4, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div4, anchor);
      if_block0.m(div4, null);
      append_hydration_dev(div4, t0);
      append_hydration_dev(div4, div3);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div3, t2);
      if (if_block1)
        if_block1.m(div3, null);
      append_hydration_dev(div4, t3);
      if_block2.m(div4, null);
      ctx[79](div4);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div4,
            /*use*/
            ctx[3]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[32].call(null, div4))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div4, t0);
        }
      }
      if (dirty[0] & /*trackActiveStyles*/
      67108864 && div1_style_value !== (div1_style_value = Object.entries(
        /*trackActiveStyles*/
        ctx2[26]
      ).map(func).join(" "))) {
        attr_dev(div1, "style", div1_style_value);
      }
      if (
        /*discrete*/
        ctx2[7] && /*tickMarks*/
        ctx2[8] && /*step*/
        ctx2[9] > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          if_block1.m(div3, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (current_block_type_1 === (current_block_type_1 = select_block_type_1(ctx2, dirty)) && if_block2) {
        if_block2.p(ctx2, dirty);
      } else {
        if_block2.d(1);
        if_block2 = current_block_type_1(ctx2);
        if (if_block2) {
          if_block2.c();
          if_block2.m(div4, null);
        }
      }
      set_attributes(div4, div_data_4 = get_spread_update(div4_levels, [
        dirty[0] & /*className, range, discrete, tickMarks, disabled, internalClasses*/
        2097648 && div4_class_value !== (div4_class_value = Object.entries({
          [
            /*className*/
            ctx2[4]
          ]: true,
          "mdc-slider": true,
          "mdc-slider--range": (
            /*range*/
            ctx2[6]
          ),
          "mdc-slider--discrete": (
            /*discrete*/
            ctx2[7]
          ),
          "mdc-slider--tick-marks": (
            /*discrete*/
            ctx2[7] && /*tickMarks*/
            ctx2[8]
          ),
          "mdc-slider--disabled": (
            /*disabled*/
            ctx2[5]
          ),
          .../*internalClasses*/
          ctx2[21]
        }).filter(func_4).map(func_5).join(" ")) && { class: div4_class_value },
        dirty[0] & /*range, minRange*/
        4160 && /*range*/
        (ctx2[6] ? {
          "data-min-range": `${/*minRange*/
          ctx2[12]}`
        } : {}),
        dirty[1] & /*$$restProps*/
        64 && exclude(
          /*$$restProps*/
          ctx2[37],
          ["input$"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      8)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[3]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div4);
      }
      if_block0.d();
      if (if_block1)
        if_block1.d();
      if_block2.d();
      ctx[79](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
var func_1 = ([name, value]) => `${name}: ${value};`;
var func_2 = ([name, value]) => `${name}: ${value};`;
var func_3 = ([name, value]) => `${name}: ${value};`;
var func_4 = ([name, value]) => name !== "" && value;
var func_5 = ([name]) => name;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "disabled",
    "range",
    "discrete",
    "tickMarks",
    "step",
    "min",
    "max",
    "minRange",
    "value",
    "start",
    "end",
    "valueToAriaValueTextFn",
    "hideFocusStylesForPointerEvents",
    "input$class",
    "layout",
    "getId",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Slider", slots, []);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { disabled = false } = $$props;
  let { range = false } = $$props;
  let { discrete = false } = $$props;
  let { tickMarks = false } = $$props;
  let { step = 1 } = $$props;
  let { min = 0 } = $$props;
  let { max = 100 } = $$props;
  let { minRange = 0 } = $$props;
  let { value = void 0 } = $$props;
  let { start = void 0 } = $$props;
  let { end = void 0 } = $$props;
  let { valueToAriaValueTextFn = (value2) => `${value2}` } = $$props;
  let { hideFocusStylesForPointerEvents = false } = $$props;
  let { input$class = "" } = $$props;
  let element2;
  let instance;
  let input;
  let inputStart = void 0;
  let thumbEl;
  let thumbStart = void 0;
  let thumbKnob;
  let thumbKnobStart = void 0;
  let internalClasses = {};
  let thumbStartClasses = {};
  let thumbClasses = {};
  let inputAttrs = {};
  let inputStartAttrs = {};
  let trackActiveStyles = {};
  let thumbStyles = {};
  let thumbStartStyles = {};
  let thumbRippleActive = false;
  let thumbStartRippleActive = false;
  let currentTickMarks;
  let inputProps = (_a = getContext("SMUI:generic:input:props")) !== null && _a !== void 0 ? _a : {};
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let previousMin = min;
  let previousMax = max;
  let previousStep = step;
  let previousDiscrete = discrete;
  let previousTickMarks = tickMarks;
  if (tickMarks && step > 0) {
    const absMax = max + Math.abs(min);
    if (range && typeof start === "number" && typeof end === "number") {
      const absStart = start + Math.abs(min);
      const absEnd = end + Math.abs(min);
      currentTickMarks = [
        ...Array(absStart / step).map(() => TickMark.INACTIVE),
        ...Array(absMax / step - absStart / step - (absMax - absEnd) / step + 1).map(() => TickMark.ACTIVE),
        ...Array((absMax - absEnd) / step).map(() => TickMark.INACTIVE)
      ];
    } else if (typeof value === "number") {
      const absValue = value + Math.abs(min);
      currentTickMarks = [
        ...Array(absValue / step + 1).map(() => TickMark.ACTIVE),
        ...Array((absMax - absValue) / step).map(() => TickMark.INACTIVE)
      ];
    }
  }
  if (range && typeof start === "number" && typeof end === "number") {
    const percent = (end - start) / (max - min);
    const percentStart = start / (max - min);
    const percentEnd = end / (max - min);
    trackActiveStyles.transform = `scaleX(${percent})`;
    thumbStyles.left = `calc(${percentEnd * 100}% -24px)`;
    thumbStartStyles.left = `calc(${percentStart * 100}% -24px)`;
  } else if (typeof value === "number") {
    const percent = value / (max - min);
    trackActiveStyles.transform = `scaleX(${percent})`;
    thumbStyles.left = `calc(${percent * 100}% -24px)`;
  }
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  let previousValue = value;
  let previousStart = start;
  let previousEnd = end;
  onMount(() => {
    $$invalidate(43, instance = new MDCSliderFoundation({
      hasClass,
      addClass,
      removeClass,
      addThumbClass,
      removeThumbClass,
      getAttribute: (attribute) => getElement().getAttribute(attribute),
      getInputValue: (thumb) => {
        var _a2;
        return `${(_a2 = range ? thumb === Thumb.START ? start : end : value) !== null && _a2 !== void 0 ? _a2 : 0}`;
      },
      setInputValue: (val, thumb) => {
        if (range) {
          if (thumb === Thumb.START) {
            $$invalidate(1, start = Number(val));
            $$invalidate(50, previousStart = start);
          } else {
            $$invalidate(2, end = Number(val));
            $$invalidate(51, previousEnd = end);
          }
        } else {
          $$invalidate(0, value = Number(val));
          $$invalidate(49, previousValue = value);
        }
      },
      getInputAttribute: getInputAttr,
      setInputAttribute: addInputAttr,
      removeInputAttribute: removeInputAttr,
      focusInput: (thumb) => {
        if (range && thumb === Thumb.START && inputStart) {
          inputStart.focus();
        } else {
          input.focus();
        }
      },
      isInputFocused: (thumb) => (range && thumb === Thumb.START ? inputStart : input) === document.activeElement,
      shouldHideFocusStylesForPointerEvents: () => hideFocusStylesForPointerEvents,
      getThumbKnobWidth: (thumb) => {
        var _a2;
        return ((_a2 = range && thumb === Thumb.START ? thumbKnobStart : thumbKnob) !== null && _a2 !== void 0 ? _a2 : thumbKnob).getBoundingClientRect().width;
      },
      getThumbBoundingClientRect: (thumb) => {
        var _a2;
        return ((_a2 = range && thumb === Thumb.START ? thumbStart : thumbEl) !== null && _a2 !== void 0 ? _a2 : thumbEl).getBoundingClientRect();
      },
      getBoundingClientRect: () => getElement().getBoundingClientRect(),
      getValueIndicatorContainerWidth: (thumb) => {
        var _a2;
        return ((_a2 = range && thumb === Thumb.START ? thumbStart : thumbEl) !== null && _a2 !== void 0 ? _a2 : thumbEl).querySelector(`.mdc-slider__value-indicator-container`).getBoundingClientRect().width;
      },
      isRTL: () => getComputedStyle(getElement()).direction === "rtl",
      setThumbStyleProperty: addThumbStyle,
      removeThumbStyleProperty: removeThumbStyle,
      setTrackActiveStyleProperty: addTrackActiveStyle,
      removeTrackActiveStyleProperty: removeTrackActiveStyle,
      // Handled by Svelte.
      setValueIndicatorText: (_value, _thumb) => void 0,
      getValueToAriaValueTextFn: () => valueToAriaValueTextFn,
      updateTickMarks: (tickMarks2) => {
        $$invalidate(31, currentTickMarks = tickMarks2);
      },
      setPointerCapture: (pointerId) => {
        getElement().setPointerCapture(pointerId);
      },
      emitChangeEvent: (value2, thumb) => {
        dispatch(getElement(), "SMUISlider:change", { value: value2, thumb }, void 0, true);
      },
      emitInputEvent: (value2, thumb) => {
        dispatch(getElement(), "SMUISlider:input", { value: value2, thumb }, void 0, true);
      },
      emitDragStartEvent: (_, thumb) => {
        if (range && thumb === Thumb.START) {
          $$invalidate(30, thumbStartRippleActive = true);
        } else {
          $$invalidate(29, thumbRippleActive = true);
        }
      },
      emitDragEndEvent: (_, thumb) => {
        if (range && thumb === Thumb.START) {
          $$invalidate(30, thumbStartRippleActive = false);
        } else {
          $$invalidate(29, thumbRippleActive = false);
        }
      },
      registerEventHandler: (evtType, handler) => {
        getElement().addEventListener(evtType, handler);
      },
      deregisterEventHandler: (evtType, handler) => {
        getElement().removeEventListener(evtType, handler);
      },
      registerThumbEventHandler: (thumb, evtType, handler) => {
        var _a2;
        (_a2 = range && thumb === Thumb.START ? thumbStart : thumbEl) === null || _a2 === void 0 ? void 0 : _a2.addEventListener(evtType, handler);
      },
      deregisterThumbEventHandler: (thumb, evtType, handler) => {
        var _a2;
        (_a2 = range && thumb === Thumb.START ? thumbStart : thumbEl) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(evtType, handler);
      },
      registerInputEventHandler: (thumb, evtType, handler) => {
        var _a2;
        (_a2 = range && thumb === Thumb.START ? inputStart : input) === null || _a2 === void 0 ? void 0 : _a2.addEventListener(evtType, handler);
      },
      deregisterInputEventHandler: (thumb, evtType, handler) => {
        var _a2;
        (_a2 = range && thumb === Thumb.START ? inputStart : input) === null || _a2 === void 0 ? void 0 : _a2.removeEventListener(evtType, handler);
      },
      registerBodyEventHandler: (evtType, handler) => {
        document.body.addEventListener(evtType, handler);
      },
      deregisterBodyEventHandler: (evtType, handler) => {
        document.body.removeEventListener(evtType, handler);
      },
      registerWindowEventHandler: (evtType, handler) => {
        window.addEventListener(evtType, handler);
      },
      deregisterWindowEventHandler: (evtType, handler) => {
        window.removeEventListener(evtType, handler);
      }
    }));
    const accessor = {
      get element() {
        return getElement();
      },
      activateRipple() {
        if (!disabled) {
          $$invalidate(29, thumbRippleActive = true);
        }
      },
      deactivateRipple() {
        $$invalidate(29, thumbRippleActive = false);
      }
    };
    dispatch(element2, "SMUIGenericInput:mount", accessor);
    instance.init();
    instance.layout({ skipUpdateUI: true });
    return () => {
      dispatch(element2, "SMUIGenericInput:unmount", accessor);
      instance.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(21, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(21, internalClasses[className2] = false, internalClasses);
    }
  }
  function addThumbClass(className2, thumb) {
    if (range && thumb === Thumb.START) {
      if (!thumbStartClasses[className2]) {
        $$invalidate(22, thumbStartClasses[className2] = true, thumbStartClasses);
      }
    } else {
      if (!thumbClasses[className2]) {
        $$invalidate(23, thumbClasses[className2] = true, thumbClasses);
      }
    }
  }
  function removeThumbClass(className2, thumb) {
    if (range && thumb === Thumb.START) {
      if (!(className2 in thumbStartClasses) || thumbStartClasses[className2]) {
        $$invalidate(22, thumbStartClasses[className2] = false, thumbStartClasses);
      }
    } else {
      if (!(className2 in thumbClasses) || thumbClasses[className2]) {
        $$invalidate(23, thumbClasses[className2] = false, thumbClasses);
      }
    }
  }
  function addThumbStyle(name, value2, thumb) {
    if (range && thumb === Thumb.START) {
      if (thumbStartStyles[name] != value2) {
        if (value2 === "" || value2 == null) {
          delete thumbStartStyles[name];
          $$invalidate(28, thumbStartStyles);
        } else {
          $$invalidate(28, thumbStartStyles[name] = value2, thumbStartStyles);
        }
      }
    } else {
      if (thumbStyles[name] != value2) {
        if (value2 === "" || value2 == null) {
          delete thumbStyles[name];
          $$invalidate(27, thumbStyles);
        } else {
          $$invalidate(27, thumbStyles[name] = value2, thumbStyles);
        }
      }
    }
  }
  function removeThumbStyle(name, thumb) {
    if (range && thumb === Thumb.START) {
      if (name in thumbStartStyles) {
        delete thumbStartStyles[name];
        $$invalidate(28, thumbStartStyles);
      }
    } else {
      if (name in thumbStyles) {
        delete thumbStyles[name];
        $$invalidate(27, thumbStyles);
      }
    }
  }
  function getInputAttr(name, thumb) {
    var _a2, _b, _c;
    if (range && thumb === Thumb.START) {
      if (name === "value") {
        return `${start}`;
      }
      return name in inputStartAttrs ? (_a2 = inputStartAttrs[name]) !== null && _a2 !== void 0 ? _a2 : null : (_b = inputStart === null || inputStart === void 0 ? void 0 : inputStart.getAttribute(name)) !== null && _b !== void 0 ? _b : null;
    } else {
      if (name === "value") {
        return `${range ? end : value}`;
      }
      return name in inputAttrs ? (_c = inputAttrs[name]) !== null && _c !== void 0 ? _c : null : input.getAttribute(name);
    }
  }
  function addInputAttr(name, value2, thumb) {
    if (range && thumb === Thumb.START) {
      if (inputStartAttrs[name] !== value2) {
        $$invalidate(25, inputStartAttrs[name] = value2, inputStartAttrs);
      }
    } else {
      if (inputAttrs[name] !== value2) {
        $$invalidate(24, inputAttrs[name] = value2, inputAttrs);
      }
    }
  }
  function removeInputAttr(name, thumb) {
    if (range && thumb === Thumb.START) {
      if (!(name in inputStartAttrs) || inputStartAttrs[name] != null) {
        $$invalidate(25, inputStartAttrs[name] = void 0, inputStartAttrs);
      }
    } else {
      if (!(name in inputAttrs) || inputAttrs[name] != null) {
        $$invalidate(24, inputAttrs[name] = void 0, inputAttrs);
      }
    }
  }
  function addTrackActiveStyle(name, value2) {
    if (trackActiveStyles[name] != value2) {
      if (value2 === "" || value2 == null) {
        delete trackActiveStyles[name];
        $$invalidate(26, trackActiveStyles);
      } else {
        $$invalidate(26, trackActiveStyles[name] = value2, trackActiveStyles);
      }
    }
  }
  function removeTrackActiveStyle(name) {
    if (name in trackActiveStyles) {
      delete trackActiveStyles[name];
      $$invalidate(26, trackActiveStyles);
    }
  }
  function layout() {
    return instance.layout();
  }
  function getId() {
    return inputProps && inputProps.id;
  }
  function getElement() {
    return element2;
  }
  function blur_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function focus_handler_2(event) {
    bubble.call(this, $$self, event);
  }
  function input0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      inputStart = $$value;
      $$invalidate(16, inputStart);
    });
  }
  function input0_change_input_handler() {
    start = to_number(this.value);
    $$invalidate(1, start);
  }
  function input1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(15, input);
    });
  }
  function input1_change_input_handler() {
    end = to_number(this.value);
    $$invalidate(2, end);
  }
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(15, input);
    });
  }
  function input_1_change_input_handler() {
    value = to_number(this.value);
    $$invalidate(0, value);
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thumbKnobStart = $$value;
      $$invalidate(20, thumbKnobStart);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thumbStart = $$value;
      $$invalidate(18, thumbStart);
    });
  }
  const Ripple_function = (className2) => addThumbClass(className2, Thumb.START);
  const Ripple_function_1 = (className2) => removeThumbClass(className2, Thumb.START);
  const Ripple_function_2 = (name, value2) => addThumbStyle(name, value2, Thumb.START);
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thumbKnob = $$value;
      $$invalidate(19, thumbKnob);
    });
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thumbEl = $$value;
      $$invalidate(17, thumbEl);
    });
  }
  const Ripple_function_3 = (className2) => addThumbClass(className2, Thumb.END);
  const Ripple_function_4 = (className2) => removeThumbClass(className2, Thumb.END);
  const Ripple_function_5 = (name, value2) => addThumbStyle(name, value2, Thumb.END);
  function div0_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thumbKnob = $$value;
      $$invalidate(19, thumbKnob);
    });
  }
  function div1_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      thumbEl = $$value;
      $$invalidate(17, thumbEl);
    });
  }
  const Ripple_function_6 = (className2) => addThumbClass(className2, Thumb.END);
  const Ripple_function_7 = (className2) => removeThumbClass(className2, Thumb.END);
  const Ripple_function_8 = (name, value2) => addThumbStyle(name, value2, Thumb.END);
  function div4_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(14, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(37, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(3, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(4, className = $$new_props.class);
    if ("disabled" in $$new_props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("range" in $$new_props)
      $$invalidate(6, range = $$new_props.range);
    if ("discrete" in $$new_props)
      $$invalidate(7, discrete = $$new_props.discrete);
    if ("tickMarks" in $$new_props)
      $$invalidate(8, tickMarks = $$new_props.tickMarks);
    if ("step" in $$new_props)
      $$invalidate(9, step = $$new_props.step);
    if ("min" in $$new_props)
      $$invalidate(10, min = $$new_props.min);
    if ("max" in $$new_props)
      $$invalidate(11, max = $$new_props.max);
    if ("minRange" in $$new_props)
      $$invalidate(12, minRange = $$new_props.minRange);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("start" in $$new_props)
      $$invalidate(1, start = $$new_props.start);
    if ("end" in $$new_props)
      $$invalidate(2, end = $$new_props.end);
    if ("valueToAriaValueTextFn" in $$new_props)
      $$invalidate(38, valueToAriaValueTextFn = $$new_props.valueToAriaValueTextFn);
    if ("hideFocusStylesForPointerEvents" in $$new_props)
      $$invalidate(39, hideFocusStylesForPointerEvents = $$new_props.hideFocusStylesForPointerEvents);
    if ("input$class" in $$new_props)
      $$invalidate(13, input$class = $$new_props.input$class);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCSliderFoundation,
    Thumb,
    TickMark,
    onMount,
    onDestroy,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    Ripple: dist_default,
    forwardEvents,
    use,
    className,
    disabled,
    range,
    discrete,
    tickMarks,
    step,
    min,
    max,
    minRange,
    value,
    start,
    end,
    valueToAriaValueTextFn,
    hideFocusStylesForPointerEvents,
    input$class,
    element: element2,
    instance,
    input,
    inputStart,
    thumbEl,
    thumbStart,
    thumbKnob,
    thumbKnobStart,
    internalClasses,
    thumbStartClasses,
    thumbClasses,
    inputAttrs,
    inputStartAttrs,
    trackActiveStyles,
    thumbStyles,
    thumbStartStyles,
    thumbRippleActive,
    thumbStartRippleActive,
    currentTickMarks,
    inputProps,
    addLayoutListener,
    removeLayoutListener,
    previousMin,
    previousMax,
    previousStep,
    previousDiscrete,
    previousTickMarks,
    previousValue,
    previousStart,
    previousEnd,
    hasClass,
    addClass,
    removeClass,
    addThumbClass,
    removeThumbClass,
    addThumbStyle,
    removeThumbStyle,
    getInputAttr,
    addInputAttr,
    removeInputAttr,
    addTrackActiveStyle,
    removeTrackActiveStyle,
    layout,
    getId,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(3, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(4, className = $$new_props.className);
    if ("disabled" in $$props)
      $$invalidate(5, disabled = $$new_props.disabled);
    if ("range" in $$props)
      $$invalidate(6, range = $$new_props.range);
    if ("discrete" in $$props)
      $$invalidate(7, discrete = $$new_props.discrete);
    if ("tickMarks" in $$props)
      $$invalidate(8, tickMarks = $$new_props.tickMarks);
    if ("step" in $$props)
      $$invalidate(9, step = $$new_props.step);
    if ("min" in $$props)
      $$invalidate(10, min = $$new_props.min);
    if ("max" in $$props)
      $$invalidate(11, max = $$new_props.max);
    if ("minRange" in $$props)
      $$invalidate(12, minRange = $$new_props.minRange);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("start" in $$props)
      $$invalidate(1, start = $$new_props.start);
    if ("end" in $$props)
      $$invalidate(2, end = $$new_props.end);
    if ("valueToAriaValueTextFn" in $$props)
      $$invalidate(38, valueToAriaValueTextFn = $$new_props.valueToAriaValueTextFn);
    if ("hideFocusStylesForPointerEvents" in $$props)
      $$invalidate(39, hideFocusStylesForPointerEvents = $$new_props.hideFocusStylesForPointerEvents);
    if ("input$class" in $$props)
      $$invalidate(13, input$class = $$new_props.input$class);
    if ("element" in $$props)
      $$invalidate(14, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(43, instance = $$new_props.instance);
    if ("input" in $$props)
      $$invalidate(15, input = $$new_props.input);
    if ("inputStart" in $$props)
      $$invalidate(16, inputStart = $$new_props.inputStart);
    if ("thumbEl" in $$props)
      $$invalidate(17, thumbEl = $$new_props.thumbEl);
    if ("thumbStart" in $$props)
      $$invalidate(18, thumbStart = $$new_props.thumbStart);
    if ("thumbKnob" in $$props)
      $$invalidate(19, thumbKnob = $$new_props.thumbKnob);
    if ("thumbKnobStart" in $$props)
      $$invalidate(20, thumbKnobStart = $$new_props.thumbKnobStart);
    if ("internalClasses" in $$props)
      $$invalidate(21, internalClasses = $$new_props.internalClasses);
    if ("thumbStartClasses" in $$props)
      $$invalidate(22, thumbStartClasses = $$new_props.thumbStartClasses);
    if ("thumbClasses" in $$props)
      $$invalidate(23, thumbClasses = $$new_props.thumbClasses);
    if ("inputAttrs" in $$props)
      $$invalidate(24, inputAttrs = $$new_props.inputAttrs);
    if ("inputStartAttrs" in $$props)
      $$invalidate(25, inputStartAttrs = $$new_props.inputStartAttrs);
    if ("trackActiveStyles" in $$props)
      $$invalidate(26, trackActiveStyles = $$new_props.trackActiveStyles);
    if ("thumbStyles" in $$props)
      $$invalidate(27, thumbStyles = $$new_props.thumbStyles);
    if ("thumbStartStyles" in $$props)
      $$invalidate(28, thumbStartStyles = $$new_props.thumbStartStyles);
    if ("thumbRippleActive" in $$props)
      $$invalidate(29, thumbRippleActive = $$new_props.thumbRippleActive);
    if ("thumbStartRippleActive" in $$props)
      $$invalidate(30, thumbStartRippleActive = $$new_props.thumbStartRippleActive);
    if ("currentTickMarks" in $$props)
      $$invalidate(31, currentTickMarks = $$new_props.currentTickMarks);
    if ("inputProps" in $$props)
      $$invalidate(33, inputProps = $$new_props.inputProps);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("previousMin" in $$props)
      $$invalidate(44, previousMin = $$new_props.previousMin);
    if ("previousMax" in $$props)
      $$invalidate(45, previousMax = $$new_props.previousMax);
    if ("previousStep" in $$props)
      $$invalidate(46, previousStep = $$new_props.previousStep);
    if ("previousDiscrete" in $$props)
      $$invalidate(47, previousDiscrete = $$new_props.previousDiscrete);
    if ("previousTickMarks" in $$props)
      $$invalidate(48, previousTickMarks = $$new_props.previousTickMarks);
    if ("previousValue" in $$props)
      $$invalidate(49, previousValue = $$new_props.previousValue);
    if ("previousStart" in $$props)
      $$invalidate(50, previousStart = $$new_props.previousStart);
    if ("previousEnd" in $$props)
      $$invalidate(51, previousEnd = $$new_props.previousEnd);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*min*/
    1024 | $$self.$$.dirty[1] & /*previousMin, instance*/
    12288) {
      $:
        if (min !== previousMin) {
          if (instance) {
            instance.setMin(min);
          }
          $$invalidate(44, previousMin = min);
        }
    }
    if ($$self.$$.dirty[0] & /*max*/
    2048 | $$self.$$.dirty[1] & /*previousMax, instance*/
    20480) {
      $:
        if (max !== previousMax) {
          if (instance) {
            instance.setMax(max);
          }
          $$invalidate(45, previousMax = max);
        }
    }
    if ($$self.$$.dirty[0] & /*step*/
    512 | $$self.$$.dirty[1] & /*previousStep, instance*/
    36864) {
      $:
        if (step !== previousStep) {
          if (instance) {
            instance.setStep(step);
          }
          $$invalidate(46, previousStep = step);
        }
    }
    if ($$self.$$.dirty[0] & /*discrete*/
    128 | $$self.$$.dirty[1] & /*previousDiscrete, instance*/
    69632) {
      $:
        if (discrete !== previousDiscrete) {
          if (instance) {
            instance.setIsDiscrete(discrete);
          }
          $$invalidate(47, previousDiscrete = discrete);
        }
    }
    if ($$self.$$.dirty[0] & /*tickMarks*/
    256 | $$self.$$.dirty[1] & /*previousTickMarks, instance*/
    135168) {
      $:
        if (tickMarks !== previousTickMarks) {
          if (instance) {
            instance.setHasTickMarks(tickMarks);
          }
          $$invalidate(48, previousTickMarks = tickMarks);
        }
    }
    if ($$self.$$.dirty[0] & /*value, start, end*/
    7 | $$self.$$.dirty[1] & /*instance, previousValue, previousStart, previousEnd*/
    1839104) {
      $:
        if (instance) {
          if (previousValue !== value && typeof value === "number") {
            instance.setValue(value);
          }
          if (previousStart !== start && typeof start === "number") {
            instance.setValueStart(start);
          }
          if (previousEnd !== end && typeof end === "number") {
            instance.setValue(end);
          }
          $$invalidate(49, previousValue = value);
          $$invalidate(50, previousStart = start);
          $$invalidate(51, previousEnd = end);
          instance.layout();
        }
    }
  };
  return [
    value,
    start,
    end,
    use,
    className,
    disabled,
    range,
    discrete,
    tickMarks,
    step,
    min,
    max,
    minRange,
    input$class,
    element2,
    input,
    inputStart,
    thumbEl,
    thumbStart,
    thumbKnob,
    thumbKnobStart,
    internalClasses,
    thumbStartClasses,
    thumbClasses,
    inputAttrs,
    inputStartAttrs,
    trackActiveStyles,
    thumbStyles,
    thumbStartStyles,
    thumbRippleActive,
    thumbStartRippleActive,
    currentTickMarks,
    forwardEvents,
    inputProps,
    addThumbClass,
    removeThumbClass,
    addThumbStyle,
    $$restProps,
    valueToAriaValueTextFn,
    hideFocusStylesForPointerEvents,
    layout,
    getId,
    getElement,
    instance,
    previousMin,
    previousMax,
    previousStep,
    previousDiscrete,
    previousTickMarks,
    previousValue,
    previousStart,
    previousEnd,
    blur_handler_1,
    focus_handler_1,
    blur_handler,
    focus_handler,
    blur_handler_2,
    focus_handler_2,
    input0_binding,
    input0_change_input_handler,
    input1_binding,
    input1_change_input_handler,
    input_1_binding,
    input_1_change_input_handler,
    div0_binding,
    div1_binding,
    Ripple_function,
    Ripple_function_1,
    Ripple_function_2,
    div2_binding,
    div3_binding,
    Ripple_function_3,
    Ripple_function_4,
    Ripple_function_5,
    div0_binding_1,
    div1_binding_1,
    Ripple_function_6,
    Ripple_function_7,
    Ripple_function_8,
    div4_binding
  ];
}
var Slider = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 3,
        class: 4,
        disabled: 5,
        range: 6,
        discrete: 7,
        tickMarks: 8,
        step: 9,
        min: 10,
        max: 11,
        minRange: 12,
        value: 0,
        start: 1,
        end: 2,
        valueToAriaValueTextFn: 38,
        hideFocusStylesForPointerEvents: 39,
        input$class: 13,
        layout: 40,
        getId: 41,
        getElement: 42
      },
      null,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Slider",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get range() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set range(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get discrete() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set discrete(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tickMarks() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tickMarks(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get step() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set step(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get min() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set min(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get max() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set max(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get minRange() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set minRange(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get start() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set start(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get end() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set end(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get valueToAriaValueTextFn() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set valueToAriaValueTextFn(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hideFocusStylesForPointerEvents() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hideFocusStylesForPointerEvents(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get input$class() {
    throw new Error("<Slider>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set input$class(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[40];
  }
  set layout(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getId() {
    return this.$$.ctx[41];
  }
  set getId(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[42];
  }
  set getElement(value) {
    throw new Error("<Slider>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Slider_default = Slider;

// node_modules/@smui/slider/dist/index.js
var dist_default2 = Slider_default;
export {
  dist_default2 as default
};
/*! Bundled license information:

@material/slider/adapter.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/slider/constants.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/animation/animationframe.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/slider/types.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/slider/foundation.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/slider/component.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/slider/index.js:
  (**
   * @license
   * Copyright 2020 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)
*/
//# sourceMappingURL=@smui_slider.js.map
