import {
  MDCMenuSurface,
  MDCMenuSurfaceFoundation
} from "./chunk-FELNWKDU.js";
import {
  MDCList,
  MDCListFoundation,
  cssClasses,
  numbers
} from "./chunk-676XXDVG.js";
import {
  MDCComponent,
  MDCFoundation
} from "./chunk-ODRA5LQH.js";
import {
  __assign,
  __extends
} from "./chunk-X43LXICK.js";
import {
  closest
} from "./chunk-BT6PLM7B.js";

// node_modules/@material/menu/constants.js
var cssClasses2 = {
  MENU_SELECTED_LIST_ITEM: "mdc-menu-item--selected",
  MENU_SELECTION_GROUP: "mdc-menu__selection-group",
  ROOT: "mdc-menu"
};
var strings = {
  ARIA_CHECKED_ATTR: "aria-checked",
  ARIA_DISABLED_ATTR: "aria-disabled",
  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
  LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
  SELECTED_EVENT: "MDCMenu:selected",
  SKIP_RESTORE_FOCUS: "data-menu-item-skip-restore-focus"
};
var numbers2 = {
  FOCUS_ROOT_INDEX: -1
};
var DefaultFocusState;
(function(DefaultFocusState2) {
  DefaultFocusState2[DefaultFocusState2["NONE"] = 0] = "NONE";
  DefaultFocusState2[DefaultFocusState2["LIST_ROOT"] = 1] = "LIST_ROOT";
  DefaultFocusState2[DefaultFocusState2["FIRST_ITEM"] = 2] = "FIRST_ITEM";
  DefaultFocusState2[DefaultFocusState2["LAST_ITEM"] = 3] = "LAST_ITEM";
})(DefaultFocusState || (DefaultFocusState = {}));

// node_modules/@material/menu/foundation.js
var MDCMenuFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCMenuFoundation2, _super);
    function MDCMenuFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCMenuFoundation2.defaultAdapter), adapter)) || this;
      _this.closeAnimationEndTimerId = 0;
      _this.defaultFocusState = DefaultFocusState.LIST_ROOT;
      _this.selectedIndex = -1;
      return _this;
    }
    Object.defineProperty(MDCMenuFoundation2, "cssClasses", {
      get: function() {
        return cssClasses2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "strings", {
      get: function() {
        return strings;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "numbers", {
      get: function() {
        return numbers2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "defaultAdapter", {
      /**
       * @see {@link MDCMenuAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClassToElementAtIndex: function() {
            return void 0;
          },
          removeClassFromElementAtIndex: function() {
            return void 0;
          },
          addAttributeToElementAtIndex: function() {
            return void 0;
          },
          removeAttributeFromElementAtIndex: function() {
            return void 0;
          },
          getAttributeFromElementAtIndex: function() {
            return null;
          },
          elementContainsClass: function() {
            return false;
          },
          closeSurface: function() {
            return void 0;
          },
          getElementIndex: function() {
            return -1;
          },
          notifySelected: function() {
            return void 0;
          },
          getMenuItemCount: function() {
            return 0;
          },
          focusItemAtIndex: function() {
            return void 0;
          },
          focusListRoot: function() {
            return void 0;
          },
          getSelectedSiblingOfItemAtIndex: function() {
            return -1;
          },
          isSelectableItemAtIndex: function() {
            return false;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCMenuFoundation2.prototype.destroy = function() {
      if (this.closeAnimationEndTimerId) {
        clearTimeout(this.closeAnimationEndTimerId);
      }
      this.adapter.closeSurface();
    };
    MDCMenuFoundation2.prototype.handleKeydown = function(evt) {
      var key = evt.key, keyCode = evt.keyCode;
      var isTab = key === "Tab" || keyCode === 9;
      if (isTab) {
        this.adapter.closeSurface(
          /** skipRestoreFocus */
          true
        );
      }
    };
    MDCMenuFoundation2.prototype.handleItemAction = function(listItem) {
      var _this = this;
      var index = this.adapter.getElementIndex(listItem);
      if (index < 0) {
        return;
      }
      this.adapter.notifySelected({ index });
      var skipRestoreFocus = this.adapter.getAttributeFromElementAtIndex(index, strings.SKIP_RESTORE_FOCUS) === "true";
      this.adapter.closeSurface(skipRestoreFocus);
      this.closeAnimationEndTimerId = setTimeout(function() {
        var recomputedIndex = _this.adapter.getElementIndex(listItem);
        if (recomputedIndex >= 0 && _this.adapter.isSelectableItemAtIndex(recomputedIndex)) {
          _this.setSelectedIndex(recomputedIndex);
        }
      }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
    };
    MDCMenuFoundation2.prototype.handleMenuSurfaceOpened = function() {
      switch (this.defaultFocusState) {
        case DefaultFocusState.FIRST_ITEM:
          this.adapter.focusItemAtIndex(0);
          break;
        case DefaultFocusState.LAST_ITEM:
          this.adapter.focusItemAtIndex(this.adapter.getMenuItemCount() - 1);
          break;
        case DefaultFocusState.NONE:
          break;
        default:
          this.adapter.focusListRoot();
          break;
      }
    };
    MDCMenuFoundation2.prototype.setDefaultFocusState = function(focusState) {
      this.defaultFocusState = focusState;
    };
    MDCMenuFoundation2.prototype.getSelectedIndex = function() {
      return this.selectedIndex;
    };
    MDCMenuFoundation2.prototype.setSelectedIndex = function(index) {
      this.validatedIndex(index);
      if (!this.adapter.isSelectableItemAtIndex(index)) {
        throw new Error("MDCMenuFoundation: No selection group at specified index.");
      }
      var prevSelectedIndex = this.adapter.getSelectedSiblingOfItemAtIndex(index);
      if (prevSelectedIndex >= 0) {
        this.adapter.removeAttributeFromElementAtIndex(prevSelectedIndex, strings.ARIA_CHECKED_ATTR);
        this.adapter.removeClassFromElementAtIndex(prevSelectedIndex, cssClasses2.MENU_SELECTED_LIST_ITEM);
      }
      this.adapter.addClassToElementAtIndex(index, cssClasses2.MENU_SELECTED_LIST_ITEM);
      this.adapter.addAttributeToElementAtIndex(index, strings.ARIA_CHECKED_ATTR, "true");
      this.selectedIndex = index;
    };
    MDCMenuFoundation2.prototype.setEnabled = function(index, isEnabled) {
      this.validatedIndex(index);
      if (isEnabled) {
        this.adapter.removeClassFromElementAtIndex(index, cssClasses.LIST_ITEM_DISABLED_CLASS);
        this.adapter.addAttributeToElementAtIndex(index, strings.ARIA_DISABLED_ATTR, "false");
      } else {
        this.adapter.addClassToElementAtIndex(index, cssClasses.LIST_ITEM_DISABLED_CLASS);
        this.adapter.addAttributeToElementAtIndex(index, strings.ARIA_DISABLED_ATTR, "true");
      }
    };
    MDCMenuFoundation2.prototype.validatedIndex = function(index) {
      var menuSize = this.adapter.getMenuItemCount();
      var isIndexInRange = index >= 0 && index < menuSize;
      if (!isIndexInRange) {
        throw new Error("MDCMenuFoundation: No list item at specified index.");
      }
    };
    return MDCMenuFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/menu/component.js
var MDCMenu = (
  /** @class */
  function(_super) {
    __extends(MDCMenu2, _super);
    function MDCMenu2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCMenu2.attachTo = function(root) {
      return new MDCMenu2(root);
    };
    MDCMenu2.prototype.initialize = function(menuSurfaceFactory, listFactory) {
      if (menuSurfaceFactory === void 0) {
        menuSurfaceFactory = function(el) {
          return new MDCMenuSurface(el);
        };
      }
      if (listFactory === void 0) {
        listFactory = function(el) {
          return new MDCList(el);
        };
      }
      this.menuSurfaceFactory = menuSurfaceFactory;
      this.listFactory = listFactory;
    };
    MDCMenu2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.menuSurface = this.menuSurfaceFactory(this.root);
      var list = this.root.querySelector(strings.LIST_SELECTOR);
      if (list) {
        this.list = this.listFactory(list);
        this.list.wrapFocus = true;
      } else {
        this.list = null;
      }
      this.handleKeydown = function(evt) {
        _this.foundation.handleKeydown(evt);
      };
      this.handleItemAction = function(evt) {
        _this.foundation.handleItemAction(_this.items[evt.detail.index]);
      };
      this.handleMenuSurfaceOpened = function() {
        _this.foundation.handleMenuSurfaceOpened();
      };
      this.menuSurface.listen(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened);
      this.listen("keydown", this.handleKeydown);
      this.listen(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction);
    };
    MDCMenu2.prototype.destroy = function() {
      if (this.list) {
        this.list.destroy();
      }
      this.menuSurface.destroy();
      this.menuSurface.unlisten(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened);
      this.unlisten("keydown", this.handleKeydown);
      this.unlisten(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction);
      _super.prototype.destroy.call(this);
    };
    Object.defineProperty(MDCMenu2.prototype, "open", {
      get: function() {
        return this.menuSurface.isOpen();
      },
      set: function(value) {
        if (value) {
          this.menuSurface.open();
        } else {
          this.menuSurface.close();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "wrapFocus", {
      get: function() {
        return this.list ? this.list.wrapFocus : false;
      },
      set: function(value) {
        if (this.list) {
          this.list.wrapFocus = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "hasTypeahead", {
      /**
       * Sets whether the menu has typeahead functionality.
       * @param value Whether typeahead is enabled.
       */
      set: function(value) {
        if (this.list) {
          this.list.hasTypeahead = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "typeaheadInProgress", {
      /**
       * @return Whether typeahead logic is currently matching some user prefix.
       */
      get: function() {
        return this.list ? this.list.typeaheadInProgress : false;
      },
      enumerable: false,
      configurable: true
    });
    MDCMenu2.prototype.typeaheadMatchItem = function(nextChar, startingIndex) {
      if (this.list) {
        return this.list.typeaheadMatchItem(nextChar, startingIndex);
      }
      return -1;
    };
    MDCMenu2.prototype.layout = function() {
      if (this.list) {
        this.list.layout();
      }
    };
    Object.defineProperty(MDCMenu2.prototype, "items", {
      /**
       * Return the items within the menu. Note that this only contains the set of elements within
       * the items container that are proper list items, and not supplemental / presentational DOM
       * elements.
       */
      get: function() {
        return this.list ? this.list.listElements : [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "singleSelection", {
      /**
       * Turns on/off the underlying list's single selection mode. Used mainly
       * by select menu.
       *
       * @param singleSelection Whether to enable single selection mode.
       */
      set: function(singleSelection) {
        if (this.list) {
          this.list.singleSelection = singleSelection;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "selectedIndex", {
      /**
       * Retrieves the selected index. Only applicable to select menus.
       * @return The selected index, which is a number for single selection and
       *     radio lists, and an array of numbers for checkbox lists.
       */
      get: function() {
        return this.list ? this.list.selectedIndex : numbers.UNSET_INDEX;
      },
      /**
       * Sets the selected index of the list. Only applicable to select menus.
       * @param index The selected index, which is a number for single selection and
       *     radio lists, and an array of numbers for checkbox lists.
       */
      set: function(index) {
        if (this.list) {
          this.list.selectedIndex = index;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "quickOpen", {
      set: function(quickOpen) {
        this.menuSurface.quickOpen = quickOpen;
      },
      enumerable: false,
      configurable: true
    });
    MDCMenu2.prototype.setDefaultFocusState = function(focusState) {
      this.foundation.setDefaultFocusState(focusState);
    };
    MDCMenu2.prototype.setAnchorCorner = function(corner) {
      this.menuSurface.setAnchorCorner(corner);
    };
    MDCMenu2.prototype.setAnchorMargin = function(margin) {
      this.menuSurface.setAnchorMargin(margin);
    };
    MDCMenu2.prototype.setSelectedIndex = function(index) {
      this.foundation.setSelectedIndex(index);
    };
    MDCMenu2.prototype.setEnabled = function(index, isEnabled) {
      this.foundation.setEnabled(index, isEnabled);
    };
    MDCMenu2.prototype.getOptionByIndex = function(index) {
      var items = this.items;
      if (index < items.length) {
        return this.items[index];
      } else {
        return null;
      }
    };
    MDCMenu2.prototype.getPrimaryTextAtIndex = function(index) {
      var item = this.getOptionByIndex(index);
      if (item && this.list) {
        return this.list.getPrimaryText(item) || "";
      }
      return "";
    };
    MDCMenu2.prototype.setFixedPosition = function(isFixed) {
      this.menuSurface.setFixedPosition(isFixed);
    };
    MDCMenu2.prototype.setIsHoisted = function(isHoisted) {
      this.menuSurface.setIsHoisted(isHoisted);
    };
    MDCMenu2.prototype.setAbsolutePosition = function(x, y) {
      this.menuSurface.setAbsolutePosition(x, y);
    };
    MDCMenu2.prototype.setAnchorElement = function(element) {
      this.menuSurface.anchorElement = element;
    };
    MDCMenu2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClassToElementAtIndex: function(index, className) {
          var list = _this.items;
          list[index].classList.add(className);
        },
        removeClassFromElementAtIndex: function(index, className) {
          var list = _this.items;
          list[index].classList.remove(className);
        },
        addAttributeToElementAtIndex: function(index, attr, value) {
          var list = _this.items;
          list[index].setAttribute(attr, value);
        },
        removeAttributeFromElementAtIndex: function(index, attr) {
          var list = _this.items;
          list[index].removeAttribute(attr);
        },
        getAttributeFromElementAtIndex: function(index, attr) {
          var list = _this.items;
          return list[index].getAttribute(attr);
        },
        elementContainsClass: function(element, className) {
          return element.classList.contains(className);
        },
        closeSurface: function(skipRestoreFocus) {
          _this.menuSurface.close(skipRestoreFocus);
        },
        getElementIndex: function(element) {
          return _this.items.indexOf(element);
        },
        notifySelected: function(evtData) {
          _this.emit(strings.SELECTED_EVENT, {
            index: evtData.index,
            item: _this.items[evtData.index]
          });
        },
        getMenuItemCount: function() {
          return _this.items.length;
        },
        focusItemAtIndex: function(index) {
          _this.items[index].focus();
        },
        focusListRoot: function() {
          _this.root.querySelector(strings.LIST_SELECTOR).focus();
        },
        isSelectableItemAtIndex: function(index) {
          return !!closest(_this.items[index], "." + cssClasses2.MENU_SELECTION_GROUP);
        },
        getSelectedSiblingOfItemAtIndex: function(index) {
          var selectionGroupEl = closest(_this.items[index], "." + cssClasses2.MENU_SELECTION_GROUP);
          var selectedItemEl = selectionGroupEl.querySelector("." + cssClasses2.MENU_SELECTED_LIST_ITEM);
          return selectedItemEl ? _this.items.indexOf(selectedItemEl) : -1;
        }
      };
      return new MDCMenuFoundation(adapter);
    };
    return MDCMenu2;
  }(MDCComponent)
);

export {
  cssClasses2 as cssClasses,
  strings,
  numbers2 as numbers,
  DefaultFocusState,
  MDCMenuFoundation,
  MDCMenu
};
/*! Bundled license information:

@material/menu/constants.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu/foundation.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu/component.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)
*/
//# sourceMappingURL=chunk-V4XOZZYM.js.map
