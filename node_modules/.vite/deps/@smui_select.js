import {
  Graphic_default,
  Item_default,
  dist_default as dist_default2
} from "./chunk-57ZLKDNY.js";
import "./chunk-J7F4NX7A.js";
import {
  dist_default
} from "./chunk-Q2HAJ6KI.js";
import "./chunk-CTXZTH3U.js";
import {
  classAdderBuilder
} from "./chunk-MRX7WRPT.js";
import {
  MDCList,
  MDCListFoundation,
  cssClasses,
  numbers
} from "./chunk-676XXDVG.js";
import {
  getCorrectPropertyName
} from "./chunk-NQKK4KOY.js";
import "./chunk-DVQWFXPQ.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-DXJYLXNN.js";
import {
  MDCRipple,
  MDCRippleFoundation
} from "./chunk-MPGFDYUV.js";
import {
  MDCComponent,
  MDCFoundation
} from "./chunk-ODRA5LQH.js";
import {
  __assign,
  __extends,
  __values
} from "./chunk-X43LXICK.js";
import "./chunk-W4OU4FMO.js";
import "./chunk-OYKM6SV3.js";
import "./chunk-Y3XZ6UIT.js";
import {
  KEY,
  normalizeKey
} from "./chunk-RFTMRRON.js";
import {
  closest,
  estimateScrollWidth,
  ponyfill_exports
} from "./chunk-BT6PLM7B.js";
import "./chunk-ZB6PEJPW.js";
import {
  writable
} from "./chunk-FBWM3HWJ.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_flush_callback,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  bind,
  binding_callbacks,
  bubble,
  check_outros,
  children,
  claim_component,
  claim_element,
  claim_space,
  claim_svg_element,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  noop,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_data_maybe_contenteditable_dev,
  set_store_value,
  space,
  svg_element,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-NMMN3PC6.js";
import "./chunk-4DGM7FRE.js";
import "./chunk-7U33LM2Z.js";

// node_modules/@material/floating-label/constants.js
var cssClasses2 = {
  LABEL_FLOAT_ABOVE: "mdc-floating-label--float-above",
  LABEL_REQUIRED: "mdc-floating-label--required",
  LABEL_SHAKE: "mdc-floating-label--shake",
  ROOT: "mdc-floating-label"
};

// node_modules/@material/floating-label/foundation.js
var MDCFloatingLabelFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCFloatingLabelFoundation2, _super);
    function MDCFloatingLabelFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCFloatingLabelFoundation2.defaultAdapter), adapter)) || this;
      _this.shakeAnimationEndHandler = function() {
        _this.handleShakeAnimationEnd();
      };
      return _this;
    }
    Object.defineProperty(MDCFloatingLabelFoundation2, "cssClasses", {
      get: function() {
        return cssClasses2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCFloatingLabelFoundation2, "defaultAdapter", {
      /**
       * See {@link MDCFloatingLabelAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          getWidth: function() {
            return 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCFloatingLabelFoundation2.prototype.init = function() {
      this.adapter.registerInteractionHandler("animationend", this.shakeAnimationEndHandler);
    };
    MDCFloatingLabelFoundation2.prototype.destroy = function() {
      this.adapter.deregisterInteractionHandler("animationend", this.shakeAnimationEndHandler);
    };
    MDCFloatingLabelFoundation2.prototype.getWidth = function() {
      return this.adapter.getWidth();
    };
    MDCFloatingLabelFoundation2.prototype.shake = function(shouldShake) {
      var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
      if (shouldShake) {
        this.adapter.addClass(LABEL_SHAKE);
      } else {
        this.adapter.removeClass(LABEL_SHAKE);
      }
    };
    MDCFloatingLabelFoundation2.prototype.float = function(shouldFloat) {
      var _a = MDCFloatingLabelFoundation2.cssClasses, LABEL_FLOAT_ABOVE = _a.LABEL_FLOAT_ABOVE, LABEL_SHAKE = _a.LABEL_SHAKE;
      if (shouldFloat) {
        this.adapter.addClass(LABEL_FLOAT_ABOVE);
      } else {
        this.adapter.removeClass(LABEL_FLOAT_ABOVE);
        this.adapter.removeClass(LABEL_SHAKE);
      }
    };
    MDCFloatingLabelFoundation2.prototype.setRequired = function(isRequired) {
      var LABEL_REQUIRED = MDCFloatingLabelFoundation2.cssClasses.LABEL_REQUIRED;
      if (isRequired) {
        this.adapter.addClass(LABEL_REQUIRED);
      } else {
        this.adapter.removeClass(LABEL_REQUIRED);
      }
    };
    MDCFloatingLabelFoundation2.prototype.handleShakeAnimationEnd = function() {
      var LABEL_SHAKE = MDCFloatingLabelFoundation2.cssClasses.LABEL_SHAKE;
      this.adapter.removeClass(LABEL_SHAKE);
    };
    return MDCFloatingLabelFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/floating-label/component.js
var MDCFloatingLabel = (
  /** @class */
  function(_super) {
    __extends(MDCFloatingLabel2, _super);
    function MDCFloatingLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCFloatingLabel2.attachTo = function(root) {
      return new MDCFloatingLabel2(root);
    };
    MDCFloatingLabel2.prototype.shake = function(shouldShake) {
      this.foundation.shake(shouldShake);
    };
    MDCFloatingLabel2.prototype.float = function(shouldFloat) {
      this.foundation.float(shouldFloat);
    };
    MDCFloatingLabel2.prototype.setRequired = function(isRequired) {
      this.foundation.setRequired(isRequired);
    };
    MDCFloatingLabel2.prototype.getWidth = function() {
      return this.foundation.getWidth();
    };
    MDCFloatingLabel2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClass: function(className) {
          return _this.root.classList.add(className);
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        },
        getWidth: function() {
          return estimateScrollWidth(_this.root);
        },
        registerInteractionHandler: function(evtType, handler) {
          return _this.listen(evtType, handler);
        },
        deregisterInteractionHandler: function(evtType, handler) {
          return _this.unlisten(evtType, handler);
        }
      };
      return new MDCFloatingLabelFoundation(adapter);
    };
    return MDCFloatingLabel2;
  }(MDCComponent)
);

// node_modules/@material/line-ripple/constants.js
var cssClasses3 = {
  LINE_RIPPLE_ACTIVE: "mdc-line-ripple--active",
  LINE_RIPPLE_DEACTIVATING: "mdc-line-ripple--deactivating"
};

// node_modules/@material/line-ripple/foundation.js
var MDCLineRippleFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCLineRippleFoundation2, _super);
    function MDCLineRippleFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCLineRippleFoundation2.defaultAdapter), adapter)) || this;
      _this.transitionEndHandler = function(evt) {
        _this.handleTransitionEnd(evt);
      };
      return _this;
    }
    Object.defineProperty(MDCLineRippleFoundation2, "cssClasses", {
      get: function() {
        return cssClasses3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCLineRippleFoundation2, "defaultAdapter", {
      /**
       * See {@link MDCLineRippleAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return false;
          },
          setStyle: function() {
            return void 0;
          },
          registerEventHandler: function() {
            return void 0;
          },
          deregisterEventHandler: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCLineRippleFoundation2.prototype.init = function() {
      this.adapter.registerEventHandler("transitionend", this.transitionEndHandler);
    };
    MDCLineRippleFoundation2.prototype.destroy = function() {
      this.adapter.deregisterEventHandler("transitionend", this.transitionEndHandler);
    };
    MDCLineRippleFoundation2.prototype.activate = function() {
      this.adapter.removeClass(cssClasses3.LINE_RIPPLE_DEACTIVATING);
      this.adapter.addClass(cssClasses3.LINE_RIPPLE_ACTIVE);
    };
    MDCLineRippleFoundation2.prototype.setRippleCenter = function(xCoordinate) {
      this.adapter.setStyle("transform-origin", xCoordinate + "px center");
    };
    MDCLineRippleFoundation2.prototype.deactivate = function() {
      this.adapter.addClass(cssClasses3.LINE_RIPPLE_DEACTIVATING);
    };
    MDCLineRippleFoundation2.prototype.handleTransitionEnd = function(evt) {
      var isDeactivating = this.adapter.hasClass(cssClasses3.LINE_RIPPLE_DEACTIVATING);
      if (evt.propertyName === "opacity") {
        if (isDeactivating) {
          this.adapter.removeClass(cssClasses3.LINE_RIPPLE_ACTIVE);
          this.adapter.removeClass(cssClasses3.LINE_RIPPLE_DEACTIVATING);
        }
      }
    };
    return MDCLineRippleFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/line-ripple/component.js
var MDCLineRipple = (
  /** @class */
  function(_super) {
    __extends(MDCLineRipple2, _super);
    function MDCLineRipple2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCLineRipple2.attachTo = function(root) {
      return new MDCLineRipple2(root);
    };
    MDCLineRipple2.prototype.activate = function() {
      this.foundation.activate();
    };
    MDCLineRipple2.prototype.deactivate = function() {
      this.foundation.deactivate();
    };
    MDCLineRipple2.prototype.setRippleCenter = function(xCoordinate) {
      this.foundation.setRippleCenter(xCoordinate);
    };
    MDCLineRipple2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClass: function(className) {
          return _this.root.classList.add(className);
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        setStyle: function(propertyName, value) {
          return _this.root.style.setProperty(propertyName, value);
        },
        registerEventHandler: function(evtType, handler) {
          return _this.listen(evtType, handler);
        },
        deregisterEventHandler: function(evtType, handler) {
          return _this.unlisten(evtType, handler);
        }
      };
      return new MDCLineRippleFoundation(adapter);
    };
    return MDCLineRipple2;
  }(MDCComponent)
);

// node_modules/@material/menu-surface/constants.js
var cssClasses4 = {
  ANCHOR: "mdc-menu-surface--anchor",
  ANIMATING_CLOSED: "mdc-menu-surface--animating-closed",
  ANIMATING_OPEN: "mdc-menu-surface--animating-open",
  FIXED: "mdc-menu-surface--fixed",
  IS_OPEN_BELOW: "mdc-menu-surface--is-open-below",
  OPEN: "mdc-menu-surface--open",
  ROOT: "mdc-menu-surface"
};
var strings = {
  CLOSED_EVENT: "MDCMenuSurface:closed",
  CLOSING_EVENT: "MDCMenuSurface:closing",
  OPENED_EVENT: "MDCMenuSurface:opened",
  OPENING_EVENT: "MDCMenuSurface:opening",
  FOCUSABLE_ELEMENTS: [
    "button:not(:disabled)",
    '[href]:not([aria-disabled="true"])',
    "input:not(:disabled)",
    "select:not(:disabled)",
    "textarea:not(:disabled)",
    '[tabindex]:not([tabindex="-1"]):not([aria-disabled="true"])'
  ].join(", ")
};
var numbers2 = {
  /** Total duration of menu-surface open animation. */
  TRANSITION_OPEN_DURATION: 120,
  /** Total duration of menu-surface close animation. */
  TRANSITION_CLOSE_DURATION: 75,
  /**
   * Margin left to the edge of the viewport when menu-surface is at maximum
   * possible height. Also used as a viewport margin.
   */
  MARGIN_TO_EDGE: 32,
  /**
   * Ratio of anchor width to menu-surface width for switching from corner
   * positioning to center positioning.
   */
  ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO: 0.67,
  /**
   * Amount of time to wait before restoring focus when closing the menu
   * surface. This is important because if a touch event triggered the menu
   * close, and the subsequent mouse event occurs after focus is restored, then
   * the restored focus would be lost.
   */
  TOUCH_EVENT_WAIT_MS: 30
};
var CornerBit;
(function(CornerBit2) {
  CornerBit2[CornerBit2["BOTTOM"] = 1] = "BOTTOM";
  CornerBit2[CornerBit2["CENTER"] = 2] = "CENTER";
  CornerBit2[CornerBit2["RIGHT"] = 4] = "RIGHT";
  CornerBit2[CornerBit2["FLIP_RTL"] = 8] = "FLIP_RTL";
})(CornerBit || (CornerBit = {}));
var Corner;
(function(Corner2) {
  Corner2[Corner2["TOP_LEFT"] = 0] = "TOP_LEFT";
  Corner2[Corner2["TOP_RIGHT"] = 4] = "TOP_RIGHT";
  Corner2[Corner2["BOTTOM_LEFT"] = 1] = "BOTTOM_LEFT";
  Corner2[Corner2["BOTTOM_RIGHT"] = 5] = "BOTTOM_RIGHT";
  Corner2[Corner2["TOP_START"] = 8] = "TOP_START";
  Corner2[Corner2["TOP_END"] = 12] = "TOP_END";
  Corner2[Corner2["BOTTOM_START"] = 9] = "BOTTOM_START";
  Corner2[Corner2["BOTTOM_END"] = 13] = "BOTTOM_END";
})(Corner || (Corner = {}));

// node_modules/@material/menu-surface/foundation.js
var MDCMenuSurfaceFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCMenuSurfaceFoundation2, _super);
    function MDCMenuSurfaceFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCMenuSurfaceFoundation2.defaultAdapter), adapter)) || this;
      _this.isSurfaceOpen = false;
      _this.isQuickOpen = false;
      _this.isHoistedElement = false;
      _this.isFixedPosition = false;
      _this.isHorizontallyCenteredOnViewport = false;
      _this.maxHeight = 0;
      _this.openBottomBias = 0;
      _this.openAnimationEndTimerId = 0;
      _this.closeAnimationEndTimerId = 0;
      _this.animationRequestId = 0;
      _this.anchorCorner = Corner.TOP_START;
      _this.originCorner = Corner.TOP_START;
      _this.anchorMargin = { top: 0, right: 0, bottom: 0, left: 0 };
      _this.position = { x: 0, y: 0 };
      return _this;
    }
    Object.defineProperty(MDCMenuSurfaceFoundation2, "cssClasses", {
      get: function() {
        return cssClasses4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "strings", {
      get: function() {
        return strings;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "numbers", {
      get: function() {
        return numbers2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "Corner", {
      get: function() {
        return Corner;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuSurfaceFoundation2, "defaultAdapter", {
      /**
       * @see {@link MDCMenuSurfaceAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return false;
          },
          hasAnchor: function() {
            return false;
          },
          isElementInContainer: function() {
            return false;
          },
          isFocused: function() {
            return false;
          },
          isRtl: function() {
            return false;
          },
          getInnerDimensions: function() {
            return { height: 0, width: 0 };
          },
          getAnchorDimensions: function() {
            return null;
          },
          getWindowDimensions: function() {
            return { height: 0, width: 0 };
          },
          getBodyDimensions: function() {
            return { height: 0, width: 0 };
          },
          getWindowScroll: function() {
            return { x: 0, y: 0 };
          },
          setPosition: function() {
            return void 0;
          },
          setMaxHeight: function() {
            return void 0;
          },
          setTransformOrigin: function() {
            return void 0;
          },
          saveFocus: function() {
            return void 0;
          },
          restoreFocus: function() {
            return void 0;
          },
          notifyClose: function() {
            return void 0;
          },
          notifyClosing: function() {
            return void 0;
          },
          notifyOpen: function() {
            return void 0;
          },
          notifyOpening: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCMenuSurfaceFoundation2.prototype.init = function() {
      var _a = MDCMenuSurfaceFoundation2.cssClasses, ROOT = _a.ROOT, OPEN = _a.OPEN;
      if (!this.adapter.hasClass(ROOT)) {
        throw new Error(ROOT + " class required in root element.");
      }
      if (this.adapter.hasClass(OPEN)) {
        this.isSurfaceOpen = true;
      }
    };
    MDCMenuSurfaceFoundation2.prototype.destroy = function() {
      clearTimeout(this.openAnimationEndTimerId);
      clearTimeout(this.closeAnimationEndTimerId);
      cancelAnimationFrame(this.animationRequestId);
    };
    MDCMenuSurfaceFoundation2.prototype.setAnchorCorner = function(corner) {
      this.anchorCorner = corner;
    };
    MDCMenuSurfaceFoundation2.prototype.flipCornerHorizontally = function() {
      this.originCorner = this.originCorner ^ CornerBit.RIGHT;
    };
    MDCMenuSurfaceFoundation2.prototype.setAnchorMargin = function(margin) {
      this.anchorMargin.top = margin.top || 0;
      this.anchorMargin.right = margin.right || 0;
      this.anchorMargin.bottom = margin.bottom || 0;
      this.anchorMargin.left = margin.left || 0;
    };
    MDCMenuSurfaceFoundation2.prototype.setIsHoisted = function(isHoisted) {
      this.isHoistedElement = isHoisted;
    };
    MDCMenuSurfaceFoundation2.prototype.setFixedPosition = function(isFixedPosition) {
      this.isFixedPosition = isFixedPosition;
    };
    MDCMenuSurfaceFoundation2.prototype.isFixed = function() {
      return this.isFixedPosition;
    };
    MDCMenuSurfaceFoundation2.prototype.setAbsolutePosition = function(x, y) {
      this.position.x = this.isFinite(x) ? x : 0;
      this.position.y = this.isFinite(y) ? y : 0;
    };
    MDCMenuSurfaceFoundation2.prototype.setIsHorizontallyCenteredOnViewport = function(isCentered) {
      this.isHorizontallyCenteredOnViewport = isCentered;
    };
    MDCMenuSurfaceFoundation2.prototype.setQuickOpen = function(quickOpen) {
      this.isQuickOpen = quickOpen;
    };
    MDCMenuSurfaceFoundation2.prototype.setMaxHeight = function(maxHeight) {
      this.maxHeight = maxHeight;
    };
    MDCMenuSurfaceFoundation2.prototype.setOpenBottomBias = function(bias) {
      this.openBottomBias = bias;
    };
    MDCMenuSurfaceFoundation2.prototype.isOpen = function() {
      return this.isSurfaceOpen;
    };
    MDCMenuSurfaceFoundation2.prototype.open = function() {
      var _this = this;
      if (this.isSurfaceOpen) {
        return;
      }
      this.adapter.notifyOpening();
      this.adapter.saveFocus();
      if (this.isQuickOpen) {
        this.isSurfaceOpen = true;
        this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
        this.dimensions = this.adapter.getInnerDimensions();
        this.autoposition();
        this.adapter.notifyOpen();
      } else {
        this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_OPEN);
        this.animationRequestId = requestAnimationFrame(function() {
          _this.dimensions = _this.adapter.getInnerDimensions();
          _this.autoposition();
          _this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
          _this.openAnimationEndTimerId = setTimeout(function() {
            _this.openAnimationEndTimerId = 0;
            _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_OPEN);
            _this.adapter.notifyOpen();
          }, numbers2.TRANSITION_OPEN_DURATION);
        });
        this.isSurfaceOpen = true;
      }
    };
    MDCMenuSurfaceFoundation2.prototype.close = function(skipRestoreFocus) {
      var _this = this;
      if (skipRestoreFocus === void 0) {
        skipRestoreFocus = false;
      }
      if (!this.isSurfaceOpen) {
        return;
      }
      this.adapter.notifyClosing();
      if (this.isQuickOpen) {
        this.isSurfaceOpen = false;
        if (!skipRestoreFocus) {
          this.maybeRestoreFocus();
        }
        this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
        this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
        this.adapter.notifyClose();
        return;
      }
      this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_CLOSED);
      requestAnimationFrame(function() {
        _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.OPEN);
        _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
        _this.closeAnimationEndTimerId = setTimeout(function() {
          _this.closeAnimationEndTimerId = 0;
          _this.adapter.removeClass(MDCMenuSurfaceFoundation2.cssClasses.ANIMATING_CLOSED);
          _this.adapter.notifyClose();
        }, numbers2.TRANSITION_CLOSE_DURATION);
      });
      this.isSurfaceOpen = false;
      if (!skipRestoreFocus) {
        this.maybeRestoreFocus();
      }
    };
    MDCMenuSurfaceFoundation2.prototype.handleBodyClick = function(evt) {
      var el = evt.target;
      if (this.adapter.isElementInContainer(el)) {
        return;
      }
      this.close();
    };
    MDCMenuSurfaceFoundation2.prototype.handleKeydown = function(evt) {
      var keyCode = evt.keyCode, key = evt.key;
      var isEscape = key === "Escape" || keyCode === 27;
      if (isEscape) {
        this.close();
      }
    };
    MDCMenuSurfaceFoundation2.prototype.autoposition = function() {
      var _a;
      this.measurements = this.getAutoLayoutmeasurements();
      var corner = this.getoriginCorner();
      var maxMenuSurfaceHeight = this.getMenuSurfaceMaxHeight(corner);
      var verticalAlignment = this.hasBit(corner, CornerBit.BOTTOM) ? "bottom" : "top";
      var horizontalAlignment = this.hasBit(corner, CornerBit.RIGHT) ? "right" : "left";
      var horizontalOffset = this.getHorizontalOriginOffset(corner);
      var verticalOffset = this.getVerticalOriginOffset(corner);
      var _b = this.measurements, anchorSize = _b.anchorSize, surfaceSize = _b.surfaceSize;
      var position = (_a = {}, _a[horizontalAlignment] = horizontalOffset, _a[verticalAlignment] = verticalOffset, _a);
      if (anchorSize.width / surfaceSize.width > numbers2.ANCHOR_TO_MENU_SURFACE_WIDTH_RATIO) {
        horizontalAlignment = "center";
      }
      if (this.isHoistedElement || this.isFixedPosition) {
        this.adjustPositionForHoistedElement(position);
      }
      this.adapter.setTransformOrigin(horizontalAlignment + " " + verticalAlignment);
      this.adapter.setPosition(position);
      this.adapter.setMaxHeight(maxMenuSurfaceHeight ? maxMenuSurfaceHeight + "px" : "");
      if (!this.hasBit(corner, CornerBit.BOTTOM)) {
        this.adapter.addClass(MDCMenuSurfaceFoundation2.cssClasses.IS_OPEN_BELOW);
      }
    };
    MDCMenuSurfaceFoundation2.prototype.getAutoLayoutmeasurements = function() {
      var anchorRect = this.adapter.getAnchorDimensions();
      var bodySize = this.adapter.getBodyDimensions();
      var viewportSize = this.adapter.getWindowDimensions();
      var windowScroll = this.adapter.getWindowScroll();
      if (!anchorRect) {
        anchorRect = {
          top: this.position.y,
          right: this.position.x,
          bottom: this.position.y,
          left: this.position.x,
          width: 0,
          height: 0
        };
      }
      return {
        anchorSize: anchorRect,
        bodySize,
        surfaceSize: this.dimensions,
        viewportDistance: {
          // tslint:disable:object-literal-sort-keys Positional properties are more readable when they're grouped together
          top: anchorRect.top,
          right: viewportSize.width - anchorRect.right,
          bottom: viewportSize.height - anchorRect.bottom,
          left: anchorRect.left
          // tslint:enable:object-literal-sort-keys
        },
        viewportSize,
        windowScroll
      };
    };
    MDCMenuSurfaceFoundation2.prototype.getoriginCorner = function() {
      var corner = this.originCorner;
      var _a = this.measurements, viewportDistance = _a.viewportDistance, anchorSize = _a.anchorSize, surfaceSize = _a.surfaceSize;
      var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation2.numbers.MARGIN_TO_EDGE;
      var isAnchoredToBottom = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
      var availableTop;
      var availableBottom;
      if (isAnchoredToBottom) {
        availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.bottom;
        availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE - this.anchorMargin.bottom;
      } else {
        availableTop = viewportDistance.top - MARGIN_TO_EDGE + this.anchorMargin.top;
        availableBottom = viewportDistance.bottom - MARGIN_TO_EDGE + anchorSize.height - this.anchorMargin.top;
      }
      var isAvailableBottom = availableBottom - surfaceSize.height > 0;
      if (!isAvailableBottom && availableTop > availableBottom + this.openBottomBias) {
        corner = this.setBit(corner, CornerBit.BOTTOM);
      }
      var isRtl = this.adapter.isRtl();
      var isFlipRtl = this.hasBit(this.anchorCorner, CornerBit.FLIP_RTL);
      var hasRightBit = this.hasBit(this.anchorCorner, CornerBit.RIGHT) || this.hasBit(corner, CornerBit.RIGHT);
      var isAnchoredToRight = false;
      if (isRtl && isFlipRtl) {
        isAnchoredToRight = !hasRightBit;
      } else {
        isAnchoredToRight = hasRightBit;
      }
      var availableLeft;
      var availableRight;
      if (isAnchoredToRight) {
        availableLeft = viewportDistance.left + anchorSize.width + this.anchorMargin.right;
        availableRight = viewportDistance.right - this.anchorMargin.right;
      } else {
        availableLeft = viewportDistance.left + this.anchorMargin.left;
        availableRight = viewportDistance.right + anchorSize.width - this.anchorMargin.left;
      }
      var isAvailableLeft = availableLeft - surfaceSize.width > 0;
      var isAvailableRight = availableRight - surfaceSize.width > 0;
      var isOriginCornerAlignedToEnd = this.hasBit(corner, CornerBit.FLIP_RTL) && this.hasBit(corner, CornerBit.RIGHT);
      if (isAvailableRight && isOriginCornerAlignedToEnd && isRtl || !isAvailableLeft && isOriginCornerAlignedToEnd) {
        corner = this.unsetBit(corner, CornerBit.RIGHT);
      } else if (isAvailableLeft && isAnchoredToRight && isRtl || isAvailableLeft && !isAnchoredToRight && hasRightBit || !isAvailableRight && availableLeft >= availableRight) {
        corner = this.setBit(corner, CornerBit.RIGHT);
      }
      return corner;
    };
    MDCMenuSurfaceFoundation2.prototype.getMenuSurfaceMaxHeight = function(corner) {
      if (this.maxHeight > 0) {
        return this.maxHeight;
      }
      var viewportDistance = this.measurements.viewportDistance;
      var maxHeight = 0;
      var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
      var isBottomAnchored = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
      var MARGIN_TO_EDGE = MDCMenuSurfaceFoundation2.numbers.MARGIN_TO_EDGE;
      if (isBottomAligned) {
        maxHeight = viewportDistance.top + this.anchorMargin.top - MARGIN_TO_EDGE;
        if (!isBottomAnchored) {
          maxHeight += this.measurements.anchorSize.height;
        }
      } else {
        maxHeight = viewportDistance.bottom - this.anchorMargin.bottom + this.measurements.anchorSize.height - MARGIN_TO_EDGE;
        if (isBottomAnchored) {
          maxHeight -= this.measurements.anchorSize.height;
        }
      }
      return maxHeight;
    };
    MDCMenuSurfaceFoundation2.prototype.getHorizontalOriginOffset = function(corner) {
      var anchorSize = this.measurements.anchorSize;
      var isRightAligned = this.hasBit(corner, CornerBit.RIGHT);
      var avoidHorizontalOverlap = this.hasBit(this.anchorCorner, CornerBit.RIGHT);
      if (isRightAligned) {
        var rightOffset = avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.left : this.anchorMargin.right;
        if (this.isHoistedElement || this.isFixedPosition) {
          return rightOffset - (this.measurements.viewportSize.width - this.measurements.bodySize.width);
        }
        return rightOffset;
      }
      return avoidHorizontalOverlap ? anchorSize.width - this.anchorMargin.right : this.anchorMargin.left;
    };
    MDCMenuSurfaceFoundation2.prototype.getVerticalOriginOffset = function(corner) {
      var anchorSize = this.measurements.anchorSize;
      var isBottomAligned = this.hasBit(corner, CornerBit.BOTTOM);
      var avoidVerticalOverlap = this.hasBit(this.anchorCorner, CornerBit.BOTTOM);
      var y = 0;
      if (isBottomAligned) {
        y = avoidVerticalOverlap ? anchorSize.height - this.anchorMargin.top : -this.anchorMargin.bottom;
      } else {
        y = avoidVerticalOverlap ? anchorSize.height + this.anchorMargin.bottom : this.anchorMargin.top;
      }
      return y;
    };
    MDCMenuSurfaceFoundation2.prototype.adjustPositionForHoistedElement = function(position) {
      var e_1, _a;
      var _b = this.measurements, windowScroll = _b.windowScroll, viewportDistance = _b.viewportDistance, surfaceSize = _b.surfaceSize, viewportSize = _b.viewportSize;
      var props = Object.keys(position);
      try {
        for (var props_1 = __values(props), props_1_1 = props_1.next(); !props_1_1.done; props_1_1 = props_1.next()) {
          var prop = props_1_1.value;
          var value = position[prop] || 0;
          if (this.isHorizontallyCenteredOnViewport && (prop === "left" || prop === "right")) {
            position[prop] = (viewportSize.width - surfaceSize.width) / 2;
            continue;
          }
          value += viewportDistance[prop];
          if (!this.isFixedPosition) {
            if (prop === "top") {
              value += windowScroll.y;
            } else if (prop === "bottom") {
              value -= windowScroll.y;
            } else if (prop === "left") {
              value += windowScroll.x;
            } else {
              value -= windowScroll.x;
            }
          }
          position[prop] = value;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (props_1_1 && !props_1_1.done && (_a = props_1.return))
            _a.call(props_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    MDCMenuSurfaceFoundation2.prototype.maybeRestoreFocus = function() {
      var _this = this;
      var isRootFocused = this.adapter.isFocused();
      var ownerDocument = this.adapter.getOwnerDocument ? this.adapter.getOwnerDocument() : document;
      var childHasFocus = ownerDocument.activeElement && this.adapter.isElementInContainer(ownerDocument.activeElement);
      if (isRootFocused || childHasFocus) {
        setTimeout(function() {
          _this.adapter.restoreFocus();
        }, numbers2.TOUCH_EVENT_WAIT_MS);
      }
    };
    MDCMenuSurfaceFoundation2.prototype.hasBit = function(corner, bit) {
      return Boolean(corner & bit);
    };
    MDCMenuSurfaceFoundation2.prototype.setBit = function(corner, bit) {
      return corner | bit;
    };
    MDCMenuSurfaceFoundation2.prototype.unsetBit = function(corner, bit) {
      return corner ^ bit;
    };
    MDCMenuSurfaceFoundation2.prototype.isFinite = function(num) {
      return typeof num === "number" && isFinite(num);
    };
    return MDCMenuSurfaceFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/menu-surface/component.js
var MDCMenuSurface = (
  /** @class */
  function(_super) {
    __extends(MDCMenuSurface2, _super);
    function MDCMenuSurface2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCMenuSurface2.attachTo = function(root) {
      return new MDCMenuSurface2(root);
    };
    MDCMenuSurface2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      var parentEl = this.root.parentElement;
      this.anchorElement = parentEl && parentEl.classList.contains(cssClasses4.ANCHOR) ? parentEl : null;
      if (this.root.classList.contains(cssClasses4.FIXED)) {
        this.setFixedPosition(true);
      }
      this.handleKeydown = function(event) {
        _this.foundation.handleKeydown(event);
      };
      this.handleBodyClick = function(event) {
        _this.foundation.handleBodyClick(event);
      };
      this.registerBodyClickListener = function() {
        document.body.addEventListener("click", _this.handleBodyClick, { capture: true });
      };
      this.deregisterBodyClickListener = function() {
        document.body.removeEventListener("click", _this.handleBodyClick, { capture: true });
      };
      this.listen("keydown", this.handleKeydown);
      this.listen(strings.OPENED_EVENT, this.registerBodyClickListener);
      this.listen(strings.CLOSED_EVENT, this.deregisterBodyClickListener);
    };
    MDCMenuSurface2.prototype.destroy = function() {
      this.unlisten("keydown", this.handleKeydown);
      this.unlisten(strings.OPENED_EVENT, this.registerBodyClickListener);
      this.unlisten(strings.CLOSED_EVENT, this.deregisterBodyClickListener);
      _super.prototype.destroy.call(this);
    };
    MDCMenuSurface2.prototype.isOpen = function() {
      return this.foundation.isOpen();
    };
    MDCMenuSurface2.prototype.open = function() {
      this.foundation.open();
    };
    MDCMenuSurface2.prototype.close = function(skipRestoreFocus) {
      if (skipRestoreFocus === void 0) {
        skipRestoreFocus = false;
      }
      this.foundation.close(skipRestoreFocus);
    };
    Object.defineProperty(MDCMenuSurface2.prototype, "quickOpen", {
      set: function(quickOpen) {
        this.foundation.setQuickOpen(quickOpen);
      },
      enumerable: false,
      configurable: true
    });
    MDCMenuSurface2.prototype.setIsHoisted = function(isHoisted) {
      this.foundation.setIsHoisted(isHoisted);
    };
    MDCMenuSurface2.prototype.setMenuSurfaceAnchorElement = function(element2) {
      this.anchorElement = element2;
    };
    MDCMenuSurface2.prototype.setFixedPosition = function(isFixed) {
      if (isFixed) {
        this.root.classList.add(cssClasses4.FIXED);
      } else {
        this.root.classList.remove(cssClasses4.FIXED);
      }
      this.foundation.setFixedPosition(isFixed);
    };
    MDCMenuSurface2.prototype.setAbsolutePosition = function(x, y) {
      this.foundation.setAbsolutePosition(x, y);
      this.setIsHoisted(true);
    };
    MDCMenuSurface2.prototype.setAnchorCorner = function(corner) {
      this.foundation.setAnchorCorner(corner);
    };
    MDCMenuSurface2.prototype.setAnchorMargin = function(margin) {
      this.foundation.setAnchorMargin(margin);
    };
    MDCMenuSurface2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClass: function(className) {
          return _this.root.classList.add(className);
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        hasAnchor: function() {
          return !!_this.anchorElement;
        },
        notifyClose: function() {
          return _this.emit(MDCMenuSurfaceFoundation.strings.CLOSED_EVENT, {});
        },
        notifyClosing: function() {
          _this.emit(MDCMenuSurfaceFoundation.strings.CLOSING_EVENT, {});
        },
        notifyOpen: function() {
          return _this.emit(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, {});
        },
        notifyOpening: function() {
          return _this.emit(MDCMenuSurfaceFoundation.strings.OPENING_EVENT, {});
        },
        isElementInContainer: function(el) {
          return _this.root.contains(el);
        },
        isRtl: function() {
          return getComputedStyle(_this.root).getPropertyValue("direction") === "rtl";
        },
        setTransformOrigin: function(origin) {
          var propertyName = getCorrectPropertyName(window, "transform") + "-origin";
          _this.root.style.setProperty(propertyName, origin);
        },
        isFocused: function() {
          return document.activeElement === _this.root;
        },
        saveFocus: function() {
          _this.previousFocus = document.activeElement;
        },
        restoreFocus: function() {
          if (_this.root.contains(document.activeElement)) {
            if (_this.previousFocus && _this.previousFocus.focus) {
              _this.previousFocus.focus();
            }
          }
        },
        getInnerDimensions: function() {
          return {
            width: _this.root.offsetWidth,
            height: _this.root.offsetHeight
          };
        },
        getAnchorDimensions: function() {
          return _this.anchorElement ? _this.anchorElement.getBoundingClientRect() : null;
        },
        getWindowDimensions: function() {
          return { width: window.innerWidth, height: window.innerHeight };
        },
        getBodyDimensions: function() {
          return { width: document.body.clientWidth, height: document.body.clientHeight };
        },
        getWindowScroll: function() {
          return { x: window.pageXOffset, y: window.pageYOffset };
        },
        setPosition: function(position) {
          var rootHTML = _this.root;
          rootHTML.style.left = "left" in position ? position.left + "px" : "";
          rootHTML.style.right = "right" in position ? position.right + "px" : "";
          rootHTML.style.top = "top" in position ? position.top + "px" : "";
          rootHTML.style.bottom = "bottom" in position ? position.bottom + "px" : "";
        },
        setMaxHeight: function(height) {
          _this.root.style.maxHeight = height;
        }
      };
      return new MDCMenuSurfaceFoundation(adapter);
    };
    return MDCMenuSurface2;
  }(MDCComponent)
);

// node_modules/@material/menu/constants.js
var cssClasses5 = {
  MENU_SELECTED_LIST_ITEM: "mdc-menu-item--selected",
  MENU_SELECTION_GROUP: "mdc-menu__selection-group",
  ROOT: "mdc-menu"
};
var strings2 = {
  ARIA_CHECKED_ATTR: "aria-checked",
  ARIA_DISABLED_ATTR: "aria-disabled",
  CHECKBOX_SELECTOR: 'input[type="checkbox"]',
  LIST_SELECTOR: ".mdc-list,.mdc-deprecated-list",
  SELECTED_EVENT: "MDCMenu:selected",
  SKIP_RESTORE_FOCUS: "data-menu-item-skip-restore-focus"
};
var numbers3 = {
  FOCUS_ROOT_INDEX: -1
};
var DefaultFocusState;
(function(DefaultFocusState2) {
  DefaultFocusState2[DefaultFocusState2["NONE"] = 0] = "NONE";
  DefaultFocusState2[DefaultFocusState2["LIST_ROOT"] = 1] = "LIST_ROOT";
  DefaultFocusState2[DefaultFocusState2["FIRST_ITEM"] = 2] = "FIRST_ITEM";
  DefaultFocusState2[DefaultFocusState2["LAST_ITEM"] = 3] = "LAST_ITEM";
})(DefaultFocusState || (DefaultFocusState = {}));

// node_modules/@material/menu/foundation.js
var MDCMenuFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCMenuFoundation2, _super);
    function MDCMenuFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCMenuFoundation2.defaultAdapter), adapter)) || this;
      _this.closeAnimationEndTimerId = 0;
      _this.defaultFocusState = DefaultFocusState.LIST_ROOT;
      _this.selectedIndex = -1;
      return _this;
    }
    Object.defineProperty(MDCMenuFoundation2, "cssClasses", {
      get: function() {
        return cssClasses5;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "strings", {
      get: function() {
        return strings2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "numbers", {
      get: function() {
        return numbers3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenuFoundation2, "defaultAdapter", {
      /**
       * @see {@link MDCMenuAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClassToElementAtIndex: function() {
            return void 0;
          },
          removeClassFromElementAtIndex: function() {
            return void 0;
          },
          addAttributeToElementAtIndex: function() {
            return void 0;
          },
          removeAttributeFromElementAtIndex: function() {
            return void 0;
          },
          getAttributeFromElementAtIndex: function() {
            return null;
          },
          elementContainsClass: function() {
            return false;
          },
          closeSurface: function() {
            return void 0;
          },
          getElementIndex: function() {
            return -1;
          },
          notifySelected: function() {
            return void 0;
          },
          getMenuItemCount: function() {
            return 0;
          },
          focusItemAtIndex: function() {
            return void 0;
          },
          focusListRoot: function() {
            return void 0;
          },
          getSelectedSiblingOfItemAtIndex: function() {
            return -1;
          },
          isSelectableItemAtIndex: function() {
            return false;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCMenuFoundation2.prototype.destroy = function() {
      if (this.closeAnimationEndTimerId) {
        clearTimeout(this.closeAnimationEndTimerId);
      }
      this.adapter.closeSurface();
    };
    MDCMenuFoundation2.prototype.handleKeydown = function(evt) {
      var key = evt.key, keyCode = evt.keyCode;
      var isTab = key === "Tab" || keyCode === 9;
      if (isTab) {
        this.adapter.closeSurface(
          /** skipRestoreFocus */
          true
        );
      }
    };
    MDCMenuFoundation2.prototype.handleItemAction = function(listItem) {
      var _this = this;
      var index = this.adapter.getElementIndex(listItem);
      if (index < 0) {
        return;
      }
      this.adapter.notifySelected({ index });
      var skipRestoreFocus = this.adapter.getAttributeFromElementAtIndex(index, strings2.SKIP_RESTORE_FOCUS) === "true";
      this.adapter.closeSurface(skipRestoreFocus);
      this.closeAnimationEndTimerId = setTimeout(function() {
        var recomputedIndex = _this.adapter.getElementIndex(listItem);
        if (recomputedIndex >= 0 && _this.adapter.isSelectableItemAtIndex(recomputedIndex)) {
          _this.setSelectedIndex(recomputedIndex);
        }
      }, MDCMenuSurfaceFoundation.numbers.TRANSITION_CLOSE_DURATION);
    };
    MDCMenuFoundation2.prototype.handleMenuSurfaceOpened = function() {
      switch (this.defaultFocusState) {
        case DefaultFocusState.FIRST_ITEM:
          this.adapter.focusItemAtIndex(0);
          break;
        case DefaultFocusState.LAST_ITEM:
          this.adapter.focusItemAtIndex(this.adapter.getMenuItemCount() - 1);
          break;
        case DefaultFocusState.NONE:
          break;
        default:
          this.adapter.focusListRoot();
          break;
      }
    };
    MDCMenuFoundation2.prototype.setDefaultFocusState = function(focusState) {
      this.defaultFocusState = focusState;
    };
    MDCMenuFoundation2.prototype.getSelectedIndex = function() {
      return this.selectedIndex;
    };
    MDCMenuFoundation2.prototype.setSelectedIndex = function(index) {
      this.validatedIndex(index);
      if (!this.adapter.isSelectableItemAtIndex(index)) {
        throw new Error("MDCMenuFoundation: No selection group at specified index.");
      }
      var prevSelectedIndex = this.adapter.getSelectedSiblingOfItemAtIndex(index);
      if (prevSelectedIndex >= 0) {
        this.adapter.removeAttributeFromElementAtIndex(prevSelectedIndex, strings2.ARIA_CHECKED_ATTR);
        this.adapter.removeClassFromElementAtIndex(prevSelectedIndex, cssClasses5.MENU_SELECTED_LIST_ITEM);
      }
      this.adapter.addClassToElementAtIndex(index, cssClasses5.MENU_SELECTED_LIST_ITEM);
      this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_CHECKED_ATTR, "true");
      this.selectedIndex = index;
    };
    MDCMenuFoundation2.prototype.setEnabled = function(index, isEnabled) {
      this.validatedIndex(index);
      if (isEnabled) {
        this.adapter.removeClassFromElementAtIndex(index, cssClasses.LIST_ITEM_DISABLED_CLASS);
        this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_DISABLED_ATTR, "false");
      } else {
        this.adapter.addClassToElementAtIndex(index, cssClasses.LIST_ITEM_DISABLED_CLASS);
        this.adapter.addAttributeToElementAtIndex(index, strings2.ARIA_DISABLED_ATTR, "true");
      }
    };
    MDCMenuFoundation2.prototype.validatedIndex = function(index) {
      var menuSize = this.adapter.getMenuItemCount();
      var isIndexInRange = index >= 0 && index < menuSize;
      if (!isIndexInRange) {
        throw new Error("MDCMenuFoundation: No list item at specified index.");
      }
    };
    return MDCMenuFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/menu/component.js
var MDCMenu = (
  /** @class */
  function(_super) {
    __extends(MDCMenu2, _super);
    function MDCMenu2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCMenu2.attachTo = function(root) {
      return new MDCMenu2(root);
    };
    MDCMenu2.prototype.initialize = function(menuSurfaceFactory, listFactory) {
      if (menuSurfaceFactory === void 0) {
        menuSurfaceFactory = function(el) {
          return new MDCMenuSurface(el);
        };
      }
      if (listFactory === void 0) {
        listFactory = function(el) {
          return new MDCList(el);
        };
      }
      this.menuSurfaceFactory = menuSurfaceFactory;
      this.listFactory = listFactory;
    };
    MDCMenu2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.menuSurface = this.menuSurfaceFactory(this.root);
      var list = this.root.querySelector(strings2.LIST_SELECTOR);
      if (list) {
        this.list = this.listFactory(list);
        this.list.wrapFocus = true;
      } else {
        this.list = null;
      }
      this.handleKeydown = function(evt) {
        _this.foundation.handleKeydown(evt);
      };
      this.handleItemAction = function(evt) {
        _this.foundation.handleItemAction(_this.items[evt.detail.index]);
      };
      this.handleMenuSurfaceOpened = function() {
        _this.foundation.handleMenuSurfaceOpened();
      };
      this.menuSurface.listen(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened);
      this.listen("keydown", this.handleKeydown);
      this.listen(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction);
    };
    MDCMenu2.prototype.destroy = function() {
      if (this.list) {
        this.list.destroy();
      }
      this.menuSurface.destroy();
      this.menuSurface.unlisten(MDCMenuSurfaceFoundation.strings.OPENED_EVENT, this.handleMenuSurfaceOpened);
      this.unlisten("keydown", this.handleKeydown);
      this.unlisten(MDCListFoundation.strings.ACTION_EVENT, this.handleItemAction);
      _super.prototype.destroy.call(this);
    };
    Object.defineProperty(MDCMenu2.prototype, "open", {
      get: function() {
        return this.menuSurface.isOpen();
      },
      set: function(value) {
        if (value) {
          this.menuSurface.open();
        } else {
          this.menuSurface.close();
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "wrapFocus", {
      get: function() {
        return this.list ? this.list.wrapFocus : false;
      },
      set: function(value) {
        if (this.list) {
          this.list.wrapFocus = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "hasTypeahead", {
      /**
       * Sets whether the menu has typeahead functionality.
       * @param value Whether typeahead is enabled.
       */
      set: function(value) {
        if (this.list) {
          this.list.hasTypeahead = value;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "typeaheadInProgress", {
      /**
       * @return Whether typeahead logic is currently matching some user prefix.
       */
      get: function() {
        return this.list ? this.list.typeaheadInProgress : false;
      },
      enumerable: false,
      configurable: true
    });
    MDCMenu2.prototype.typeaheadMatchItem = function(nextChar, startingIndex) {
      if (this.list) {
        return this.list.typeaheadMatchItem(nextChar, startingIndex);
      }
      return -1;
    };
    MDCMenu2.prototype.layout = function() {
      if (this.list) {
        this.list.layout();
      }
    };
    Object.defineProperty(MDCMenu2.prototype, "items", {
      /**
       * Return the items within the menu. Note that this only contains the set of elements within
       * the items container that are proper list items, and not supplemental / presentational DOM
       * elements.
       */
      get: function() {
        return this.list ? this.list.listElements : [];
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "singleSelection", {
      /**
       * Turns on/off the underlying list's single selection mode. Used mainly
       * by select menu.
       *
       * @param singleSelection Whether to enable single selection mode.
       */
      set: function(singleSelection) {
        if (this.list) {
          this.list.singleSelection = singleSelection;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "selectedIndex", {
      /**
       * Retrieves the selected index. Only applicable to select menus.
       * @return The selected index, which is a number for single selection and
       *     radio lists, and an array of numbers for checkbox lists.
       */
      get: function() {
        return this.list ? this.list.selectedIndex : numbers.UNSET_INDEX;
      },
      /**
       * Sets the selected index of the list. Only applicable to select menus.
       * @param index The selected index, which is a number for single selection and
       *     radio lists, and an array of numbers for checkbox lists.
       */
      set: function(index) {
        if (this.list) {
          this.list.selectedIndex = index;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCMenu2.prototype, "quickOpen", {
      set: function(quickOpen) {
        this.menuSurface.quickOpen = quickOpen;
      },
      enumerable: false,
      configurable: true
    });
    MDCMenu2.prototype.setDefaultFocusState = function(focusState) {
      this.foundation.setDefaultFocusState(focusState);
    };
    MDCMenu2.prototype.setAnchorCorner = function(corner) {
      this.menuSurface.setAnchorCorner(corner);
    };
    MDCMenu2.prototype.setAnchorMargin = function(margin) {
      this.menuSurface.setAnchorMargin(margin);
    };
    MDCMenu2.prototype.setSelectedIndex = function(index) {
      this.foundation.setSelectedIndex(index);
    };
    MDCMenu2.prototype.setEnabled = function(index, isEnabled) {
      this.foundation.setEnabled(index, isEnabled);
    };
    MDCMenu2.prototype.getOptionByIndex = function(index) {
      var items = this.items;
      if (index < items.length) {
        return this.items[index];
      } else {
        return null;
      }
    };
    MDCMenu2.prototype.getPrimaryTextAtIndex = function(index) {
      var item = this.getOptionByIndex(index);
      if (item && this.list) {
        return this.list.getPrimaryText(item) || "";
      }
      return "";
    };
    MDCMenu2.prototype.setFixedPosition = function(isFixed) {
      this.menuSurface.setFixedPosition(isFixed);
    };
    MDCMenu2.prototype.setIsHoisted = function(isHoisted) {
      this.menuSurface.setIsHoisted(isHoisted);
    };
    MDCMenu2.prototype.setAbsolutePosition = function(x, y) {
      this.menuSurface.setAbsolutePosition(x, y);
    };
    MDCMenu2.prototype.setAnchorElement = function(element2) {
      this.menuSurface.anchorElement = element2;
    };
    MDCMenu2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClassToElementAtIndex: function(index, className) {
          var list = _this.items;
          list[index].classList.add(className);
        },
        removeClassFromElementAtIndex: function(index, className) {
          var list = _this.items;
          list[index].classList.remove(className);
        },
        addAttributeToElementAtIndex: function(index, attr, value) {
          var list = _this.items;
          list[index].setAttribute(attr, value);
        },
        removeAttributeFromElementAtIndex: function(index, attr) {
          var list = _this.items;
          list[index].removeAttribute(attr);
        },
        getAttributeFromElementAtIndex: function(index, attr) {
          var list = _this.items;
          return list[index].getAttribute(attr);
        },
        elementContainsClass: function(element2, className) {
          return element2.classList.contains(className);
        },
        closeSurface: function(skipRestoreFocus) {
          _this.menuSurface.close(skipRestoreFocus);
        },
        getElementIndex: function(element2) {
          return _this.items.indexOf(element2);
        },
        notifySelected: function(evtData) {
          _this.emit(strings2.SELECTED_EVENT, {
            index: evtData.index,
            item: _this.items[evtData.index]
          });
        },
        getMenuItemCount: function() {
          return _this.items.length;
        },
        focusItemAtIndex: function(index) {
          _this.items[index].focus();
        },
        focusListRoot: function() {
          _this.root.querySelector(strings2.LIST_SELECTOR).focus();
        },
        isSelectableItemAtIndex: function(index) {
          return !!closest(_this.items[index], "." + cssClasses5.MENU_SELECTION_GROUP);
        },
        getSelectedSiblingOfItemAtIndex: function(index) {
          var selectionGroupEl = closest(_this.items[index], "." + cssClasses5.MENU_SELECTION_GROUP);
          var selectedItemEl = selectionGroupEl.querySelector("." + cssClasses5.MENU_SELECTED_LIST_ITEM);
          return selectedItemEl ? _this.items.indexOf(selectedItemEl) : -1;
        }
      };
      return new MDCMenuFoundation(adapter);
    };
    return MDCMenu2;
  }(MDCComponent)
);

// node_modules/@material/notched-outline/constants.js
var strings3 = {
  NOTCH_ELEMENT_SELECTOR: ".mdc-notched-outline__notch"
};
var numbers4 = {
  // This should stay in sync with $mdc-notched-outline-padding * 2.
  NOTCH_ELEMENT_PADDING: 8
};
var cssClasses6 = {
  NO_LABEL: "mdc-notched-outline--no-label",
  OUTLINE_NOTCHED: "mdc-notched-outline--notched",
  OUTLINE_UPGRADED: "mdc-notched-outline--upgraded"
};

// node_modules/@material/notched-outline/foundation.js
var MDCNotchedOutlineFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCNotchedOutlineFoundation2, _super);
    function MDCNotchedOutlineFoundation2(adapter) {
      return _super.call(this, __assign(__assign({}, MDCNotchedOutlineFoundation2.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCNotchedOutlineFoundation2, "strings", {
      get: function() {
        return strings3;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation2, "cssClasses", {
      get: function() {
        return cssClasses6;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation2, "numbers", {
      get: function() {
        return numbers4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCNotchedOutlineFoundation2, "defaultAdapter", {
      /**
       * See {@link MDCNotchedOutlineAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          setNotchWidthProperty: function() {
            return void 0;
          },
          removeNotchWidthProperty: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCNotchedOutlineFoundation2.prototype.notch = function(notchWidth) {
      var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
      if (notchWidth > 0) {
        notchWidth += numbers4.NOTCH_ELEMENT_PADDING;
      }
      this.adapter.setNotchWidthProperty(notchWidth);
      this.adapter.addClass(OUTLINE_NOTCHED);
    };
    MDCNotchedOutlineFoundation2.prototype.closeNotch = function() {
      var OUTLINE_NOTCHED = MDCNotchedOutlineFoundation2.cssClasses.OUTLINE_NOTCHED;
      this.adapter.removeClass(OUTLINE_NOTCHED);
      this.adapter.removeNotchWidthProperty();
    };
    return MDCNotchedOutlineFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/notched-outline/component.js
var MDCNotchedOutline = (
  /** @class */
  function(_super) {
    __extends(MDCNotchedOutline2, _super);
    function MDCNotchedOutline2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCNotchedOutline2.attachTo = function(root) {
      return new MDCNotchedOutline2(root);
    };
    MDCNotchedOutline2.prototype.initialSyncWithDOM = function() {
      this.notchElement = this.root.querySelector(strings3.NOTCH_ELEMENT_SELECTOR);
      var label = this.root.querySelector("." + MDCFloatingLabelFoundation.cssClasses.ROOT);
      if (label) {
        label.style.transitionDuration = "0s";
        this.root.classList.add(cssClasses6.OUTLINE_UPGRADED);
        requestAnimationFrame(function() {
          label.style.transitionDuration = "";
        });
      } else {
        this.root.classList.add(cssClasses6.NO_LABEL);
      }
    };
    MDCNotchedOutline2.prototype.notch = function(notchWidth) {
      this.foundation.notch(notchWidth);
    };
    MDCNotchedOutline2.prototype.closeNotch = function() {
      this.foundation.closeNotch();
    };
    MDCNotchedOutline2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClass: function(className) {
          return _this.root.classList.add(className);
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        },
        setNotchWidthProperty: function(width) {
          _this.notchElement.style.setProperty("width", width + "px");
        },
        removeNotchWidthProperty: function() {
          _this.notchElement.style.removeProperty("width");
        }
      };
      return new MDCNotchedOutlineFoundation(adapter);
    };
    return MDCNotchedOutline2;
  }(MDCComponent)
);

// node_modules/@material/select/constants.js
var cssClasses7 = {
  ACTIVATED: "mdc-select--activated",
  DISABLED: "mdc-select--disabled",
  FOCUSED: "mdc-select--focused",
  INVALID: "mdc-select--invalid",
  MENU_INVALID: "mdc-select__menu--invalid",
  OUTLINED: "mdc-select--outlined",
  REQUIRED: "mdc-select--required",
  ROOT: "mdc-select",
  WITH_LEADING_ICON: "mdc-select--with-leading-icon"
};
var strings4 = {
  ARIA_CONTROLS: "aria-controls",
  ARIA_DESCRIBEDBY: "aria-describedby",
  ARIA_SELECTED_ATTR: "aria-selected",
  CHANGE_EVENT: "MDCSelect:change",
  HIDDEN_INPUT_SELECTOR: 'input[type="hidden"]',
  LABEL_SELECTOR: ".mdc-floating-label",
  LEADING_ICON_SELECTOR: ".mdc-select__icon",
  LINE_RIPPLE_SELECTOR: ".mdc-line-ripple",
  MENU_SELECTOR: ".mdc-select__menu",
  OUTLINE_SELECTOR: ".mdc-notched-outline",
  SELECTED_TEXT_SELECTOR: ".mdc-select__selected-text",
  SELECT_ANCHOR_SELECTOR: ".mdc-select__anchor",
  VALUE_ATTR: "data-value"
};
var numbers5 = {
  LABEL_SCALE: 0.75,
  UNSET_INDEX: -1,
  CLICK_DEBOUNCE_TIMEOUT_MS: 330
};

// node_modules/@material/select/foundation.js
var MDCSelectFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCSelectFoundation2, _super);
    function MDCSelectFoundation2(adapter, foundationMap) {
      if (foundationMap === void 0) {
        foundationMap = {};
      }
      var _this = _super.call(this, __assign(__assign({}, MDCSelectFoundation2.defaultAdapter), adapter)) || this;
      _this.disabled = false;
      _this.isMenuOpen = false;
      _this.useDefaultValidation = true;
      _this.customValidity = true;
      _this.lastSelectedIndex = numbers5.UNSET_INDEX;
      _this.clickDebounceTimeout = 0;
      _this.recentlyClicked = false;
      _this.leadingIcon = foundationMap.leadingIcon;
      _this.helperText = foundationMap.helperText;
      return _this;
    }
    Object.defineProperty(MDCSelectFoundation2, "cssClasses", {
      get: function() {
        return cssClasses7;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelectFoundation2, "numbers", {
      get: function() {
        return numbers5;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelectFoundation2, "strings", {
      get: function() {
        return strings4;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelectFoundation2, "defaultAdapter", {
      /**
       * See {@link MDCSelectAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return false;
          },
          activateBottomLine: function() {
            return void 0;
          },
          deactivateBottomLine: function() {
            return void 0;
          },
          getSelectedIndex: function() {
            return -1;
          },
          setSelectedIndex: function() {
            return void 0;
          },
          hasLabel: function() {
            return false;
          },
          floatLabel: function() {
            return void 0;
          },
          getLabelWidth: function() {
            return 0;
          },
          setLabelRequired: function() {
            return void 0;
          },
          hasOutline: function() {
            return false;
          },
          notchOutline: function() {
            return void 0;
          },
          closeOutline: function() {
            return void 0;
          },
          setRippleCenter: function() {
            return void 0;
          },
          notifyChange: function() {
            return void 0;
          },
          setSelectedText: function() {
            return void 0;
          },
          isSelectAnchorFocused: function() {
            return false;
          },
          getSelectAnchorAttr: function() {
            return "";
          },
          setSelectAnchorAttr: function() {
            return void 0;
          },
          removeSelectAnchorAttr: function() {
            return void 0;
          },
          addMenuClass: function() {
            return void 0;
          },
          removeMenuClass: function() {
            return void 0;
          },
          openMenu: function() {
            return void 0;
          },
          closeMenu: function() {
            return void 0;
          },
          getAnchorElement: function() {
            return null;
          },
          setMenuAnchorElement: function() {
            return void 0;
          },
          setMenuAnchorCorner: function() {
            return void 0;
          },
          setMenuWrapFocus: function() {
            return void 0;
          },
          focusMenuItemAtIndex: function() {
            return void 0;
          },
          getMenuItemCount: function() {
            return 0;
          },
          getMenuItemValues: function() {
            return [];
          },
          getMenuItemTextAtIndex: function() {
            return "";
          },
          isTypeaheadInProgress: function() {
            return false;
          },
          typeaheadMatchItem: function() {
            return -1;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCSelectFoundation2.prototype.getSelectedIndex = function() {
      return this.adapter.getSelectedIndex();
    };
    MDCSelectFoundation2.prototype.setSelectedIndex = function(index, closeMenu, skipNotify) {
      if (closeMenu === void 0) {
        closeMenu = false;
      }
      if (skipNotify === void 0) {
        skipNotify = false;
      }
      if (index >= this.adapter.getMenuItemCount()) {
        return;
      }
      if (index === numbers5.UNSET_INDEX) {
        this.adapter.setSelectedText("");
      } else {
        this.adapter.setSelectedText(this.adapter.getMenuItemTextAtIndex(index).trim());
      }
      this.adapter.setSelectedIndex(index);
      if (closeMenu) {
        this.adapter.closeMenu();
      }
      if (!skipNotify && this.lastSelectedIndex !== index) {
        this.handleChange();
      }
      this.lastSelectedIndex = index;
    };
    MDCSelectFoundation2.prototype.setValue = function(value, skipNotify) {
      if (skipNotify === void 0) {
        skipNotify = false;
      }
      var index = this.adapter.getMenuItemValues().indexOf(value);
      this.setSelectedIndex(
        index,
        /** closeMenu */
        false,
        skipNotify
      );
    };
    MDCSelectFoundation2.prototype.getValue = function() {
      var index = this.adapter.getSelectedIndex();
      var menuItemValues = this.adapter.getMenuItemValues();
      return index !== numbers5.UNSET_INDEX ? menuItemValues[index] : "";
    };
    MDCSelectFoundation2.prototype.getDisabled = function() {
      return this.disabled;
    };
    MDCSelectFoundation2.prototype.setDisabled = function(isDisabled) {
      this.disabled = isDisabled;
      if (this.disabled) {
        this.adapter.addClass(cssClasses7.DISABLED);
        this.adapter.closeMenu();
      } else {
        this.adapter.removeClass(cssClasses7.DISABLED);
      }
      if (this.leadingIcon) {
        this.leadingIcon.setDisabled(this.disabled);
      }
      if (this.disabled) {
        this.adapter.removeSelectAnchorAttr("tabindex");
      } else {
        this.adapter.setSelectAnchorAttr("tabindex", "0");
      }
      this.adapter.setSelectAnchorAttr("aria-disabled", this.disabled.toString());
    };
    MDCSelectFoundation2.prototype.openMenu = function() {
      this.adapter.addClass(cssClasses7.ACTIVATED);
      this.adapter.openMenu();
      this.isMenuOpen = true;
      this.adapter.setSelectAnchorAttr("aria-expanded", "true");
    };
    MDCSelectFoundation2.prototype.setHelperTextContent = function(content) {
      if (this.helperText) {
        this.helperText.setContent(content);
      }
    };
    MDCSelectFoundation2.prototype.layout = function() {
      if (this.adapter.hasLabel()) {
        var optionHasValue = this.getValue().length > 0;
        var isFocused = this.adapter.hasClass(cssClasses7.FOCUSED);
        var shouldFloatAndNotch = optionHasValue || isFocused;
        var isRequired = this.adapter.hasClass(cssClasses7.REQUIRED);
        this.notchOutline(shouldFloatAndNotch);
        this.adapter.floatLabel(shouldFloatAndNotch);
        this.adapter.setLabelRequired(isRequired);
      }
    };
    MDCSelectFoundation2.prototype.layoutOptions = function() {
      var menuItemValues = this.adapter.getMenuItemValues();
      var selectedIndex = menuItemValues.indexOf(this.getValue());
      this.setSelectedIndex(
        selectedIndex,
        /** closeMenu */
        false,
        /** skipNotify */
        true
      );
    };
    MDCSelectFoundation2.prototype.handleMenuOpened = function() {
      if (this.adapter.getMenuItemValues().length === 0) {
        return;
      }
      var selectedIndex = this.getSelectedIndex();
      var focusItemIndex = selectedIndex >= 0 ? selectedIndex : 0;
      this.adapter.focusMenuItemAtIndex(focusItemIndex);
    };
    MDCSelectFoundation2.prototype.handleMenuClosing = function() {
      this.adapter.setSelectAnchorAttr("aria-expanded", "false");
    };
    MDCSelectFoundation2.prototype.handleMenuClosed = function() {
      this.adapter.removeClass(cssClasses7.ACTIVATED);
      this.isMenuOpen = false;
      if (!this.adapter.isSelectAnchorFocused()) {
        this.blur();
      }
    };
    MDCSelectFoundation2.prototype.handleChange = function() {
      this.layout();
      this.adapter.notifyChange(this.getValue());
      var isRequired = this.adapter.hasClass(cssClasses7.REQUIRED);
      if (isRequired && this.useDefaultValidation) {
        this.setValid(this.isValid());
      }
    };
    MDCSelectFoundation2.prototype.handleMenuItemAction = function(index) {
      this.setSelectedIndex(
        index,
        /** closeMenu */
        true
      );
    };
    MDCSelectFoundation2.prototype.handleFocus = function() {
      this.adapter.addClass(cssClasses7.FOCUSED);
      this.layout();
      this.adapter.activateBottomLine();
    };
    MDCSelectFoundation2.prototype.handleBlur = function() {
      if (this.isMenuOpen) {
        return;
      }
      this.blur();
    };
    MDCSelectFoundation2.prototype.handleClick = function(normalizedX) {
      if (this.disabled || this.recentlyClicked) {
        return;
      }
      this.setClickDebounceTimeout();
      if (this.isMenuOpen) {
        this.adapter.closeMenu();
        return;
      }
      this.adapter.setRippleCenter(normalizedX);
      this.openMenu();
    };
    MDCSelectFoundation2.prototype.handleKeydown = function(event) {
      if (this.isMenuOpen || !this.adapter.hasClass(cssClasses7.FOCUSED)) {
        return;
      }
      var isEnter = normalizeKey(event) === KEY.ENTER;
      var isSpace = normalizeKey(event) === KEY.SPACEBAR;
      var arrowUp = normalizeKey(event) === KEY.ARROW_UP;
      var arrowDown = normalizeKey(event) === KEY.ARROW_DOWN;
      var isModifier = event.ctrlKey || event.metaKey;
      if (!isModifier && (!isSpace && event.key && event.key.length === 1 || isSpace && this.adapter.isTypeaheadInProgress())) {
        var key = isSpace ? " " : event.key;
        var typeaheadNextIndex = this.adapter.typeaheadMatchItem(key, this.getSelectedIndex());
        if (typeaheadNextIndex >= 0) {
          this.setSelectedIndex(typeaheadNextIndex);
        }
        event.preventDefault();
        return;
      }
      if (!isEnter && !isSpace && !arrowUp && !arrowDown) {
        return;
      }
      this.openMenu();
      event.preventDefault();
    };
    MDCSelectFoundation2.prototype.notchOutline = function(openNotch) {
      if (!this.adapter.hasOutline()) {
        return;
      }
      var isFocused = this.adapter.hasClass(cssClasses7.FOCUSED);
      if (openNotch) {
        var labelScale = numbers5.LABEL_SCALE;
        var labelWidth = this.adapter.getLabelWidth() * labelScale;
        this.adapter.notchOutline(labelWidth);
      } else if (!isFocused) {
        this.adapter.closeOutline();
      }
    };
    MDCSelectFoundation2.prototype.setLeadingIconAriaLabel = function(label) {
      if (this.leadingIcon) {
        this.leadingIcon.setAriaLabel(label);
      }
    };
    MDCSelectFoundation2.prototype.setLeadingIconContent = function(content) {
      if (this.leadingIcon) {
        this.leadingIcon.setContent(content);
      }
    };
    MDCSelectFoundation2.prototype.getUseDefaultValidation = function() {
      return this.useDefaultValidation;
    };
    MDCSelectFoundation2.prototype.setUseDefaultValidation = function(useDefaultValidation) {
      this.useDefaultValidation = useDefaultValidation;
    };
    MDCSelectFoundation2.prototype.setValid = function(isValid) {
      if (!this.useDefaultValidation) {
        this.customValidity = isValid;
      }
      this.adapter.setSelectAnchorAttr("aria-invalid", (!isValid).toString());
      if (isValid) {
        this.adapter.removeClass(cssClasses7.INVALID);
        this.adapter.removeMenuClass(cssClasses7.MENU_INVALID);
      } else {
        this.adapter.addClass(cssClasses7.INVALID);
        this.adapter.addMenuClass(cssClasses7.MENU_INVALID);
      }
      this.syncHelperTextValidity(isValid);
    };
    MDCSelectFoundation2.prototype.isValid = function() {
      if (this.useDefaultValidation && this.adapter.hasClass(cssClasses7.REQUIRED) && !this.adapter.hasClass(cssClasses7.DISABLED)) {
        return this.getSelectedIndex() !== numbers5.UNSET_INDEX && (this.getSelectedIndex() !== 0 || Boolean(this.getValue()));
      }
      return this.customValidity;
    };
    MDCSelectFoundation2.prototype.setRequired = function(isRequired) {
      if (isRequired) {
        this.adapter.addClass(cssClasses7.REQUIRED);
      } else {
        this.adapter.removeClass(cssClasses7.REQUIRED);
      }
      this.adapter.setSelectAnchorAttr("aria-required", isRequired.toString());
      this.adapter.setLabelRequired(isRequired);
    };
    MDCSelectFoundation2.prototype.getRequired = function() {
      return this.adapter.getSelectAnchorAttr("aria-required") === "true";
    };
    MDCSelectFoundation2.prototype.init = function() {
      var anchorEl = this.adapter.getAnchorElement();
      if (anchorEl) {
        this.adapter.setMenuAnchorElement(anchorEl);
        this.adapter.setMenuAnchorCorner(Corner.BOTTOM_START);
      }
      this.adapter.setMenuWrapFocus(false);
      this.setDisabled(this.adapter.hasClass(cssClasses7.DISABLED));
      this.syncHelperTextValidity(!this.adapter.hasClass(cssClasses7.INVALID));
      this.layout();
      this.layoutOptions();
    };
    MDCSelectFoundation2.prototype.blur = function() {
      this.adapter.removeClass(cssClasses7.FOCUSED);
      this.layout();
      this.adapter.deactivateBottomLine();
      var isRequired = this.adapter.hasClass(cssClasses7.REQUIRED);
      if (isRequired && this.useDefaultValidation) {
        this.setValid(this.isValid());
      }
    };
    MDCSelectFoundation2.prototype.syncHelperTextValidity = function(isValid) {
      if (!this.helperText) {
        return;
      }
      this.helperText.setValidity(isValid);
      var helperTextVisible = this.helperText.isVisible();
      var helperTextId = this.helperText.getId();
      if (helperTextVisible && helperTextId) {
        this.adapter.setSelectAnchorAttr(strings4.ARIA_DESCRIBEDBY, helperTextId);
      } else {
        this.adapter.removeSelectAnchorAttr(strings4.ARIA_DESCRIBEDBY);
      }
    };
    MDCSelectFoundation2.prototype.setClickDebounceTimeout = function() {
      var _this = this;
      clearTimeout(this.clickDebounceTimeout);
      this.clickDebounceTimeout = setTimeout(function() {
        _this.recentlyClicked = false;
      }, numbers5.CLICK_DEBOUNCE_TIMEOUT_MS);
      this.recentlyClicked = true;
    };
    return MDCSelectFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/select/helper-text/constants.js
var strings5 = {
  ARIA_HIDDEN: "aria-hidden",
  ROLE: "role"
};
var cssClasses8 = {
  HELPER_TEXT_VALIDATION_MSG: "mdc-select-helper-text--validation-msg",
  HELPER_TEXT_VALIDATION_MSG_PERSISTENT: "mdc-select-helper-text--validation-msg-persistent"
};

// node_modules/@material/select/helper-text/foundation.js
var MDCSelectHelperTextFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCSelectHelperTextFoundation2, _super);
    function MDCSelectHelperTextFoundation2(adapter) {
      return _super.call(this, __assign(__assign({}, MDCSelectHelperTextFoundation2.defaultAdapter), adapter)) || this;
    }
    Object.defineProperty(MDCSelectHelperTextFoundation2, "cssClasses", {
      get: function() {
        return cssClasses8;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelectHelperTextFoundation2, "strings", {
      get: function() {
        return strings5;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelectHelperTextFoundation2, "defaultAdapter", {
      /**
       * See {@link MDCSelectHelperTextAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          addClass: function() {
            return void 0;
          },
          removeClass: function() {
            return void 0;
          },
          hasClass: function() {
            return false;
          },
          setAttr: function() {
            return void 0;
          },
          getAttr: function() {
            return null;
          },
          removeAttr: function() {
            return void 0;
          },
          setContent: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCSelectHelperTextFoundation2.prototype.getId = function() {
      return this.adapter.getAttr("id");
    };
    MDCSelectHelperTextFoundation2.prototype.isVisible = function() {
      return this.adapter.getAttr(strings5.ARIA_HIDDEN) !== "true";
    };
    MDCSelectHelperTextFoundation2.prototype.setContent = function(content) {
      this.adapter.setContent(content);
    };
    MDCSelectHelperTextFoundation2.prototype.setValidation = function(isValidation) {
      if (isValidation) {
        this.adapter.addClass(cssClasses8.HELPER_TEXT_VALIDATION_MSG);
      } else {
        this.adapter.removeClass(cssClasses8.HELPER_TEXT_VALIDATION_MSG);
      }
    };
    MDCSelectHelperTextFoundation2.prototype.setValidationMsgPersistent = function(isPersistent) {
      if (isPersistent) {
        this.adapter.addClass(cssClasses8.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
      } else {
        this.adapter.removeClass(cssClasses8.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
      }
    };
    MDCSelectHelperTextFoundation2.prototype.getIsValidation = function() {
      return this.adapter.hasClass(cssClasses8.HELPER_TEXT_VALIDATION_MSG);
    };
    MDCSelectHelperTextFoundation2.prototype.getIsValidationMsgPersistent = function() {
      return this.adapter.hasClass(cssClasses8.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
    };
    MDCSelectHelperTextFoundation2.prototype.setValidity = function(selectIsValid) {
      var isValidationMsg = this.adapter.hasClass(cssClasses8.HELPER_TEXT_VALIDATION_MSG);
      if (!isValidationMsg) {
        return;
      }
      var isPersistentValidationMsg = this.adapter.hasClass(cssClasses8.HELPER_TEXT_VALIDATION_MSG_PERSISTENT);
      var msgShouldDisplay = !selectIsValid || isPersistentValidationMsg;
      if (msgShouldDisplay) {
        this.showToScreenReader();
        if (!selectIsValid) {
          this.adapter.setAttr(strings5.ROLE, "alert");
        } else {
          this.adapter.removeAttr(strings5.ROLE);
        }
        return;
      }
      this.adapter.removeAttr(strings5.ROLE);
      this.hide();
    };
    MDCSelectHelperTextFoundation2.prototype.showToScreenReader = function() {
      this.adapter.removeAttr(strings5.ARIA_HIDDEN);
    };
    MDCSelectHelperTextFoundation2.prototype.hide = function() {
      this.adapter.setAttr(strings5.ARIA_HIDDEN, "true");
    };
    return MDCSelectHelperTextFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/select/helper-text/component.js
var MDCSelectHelperText = (
  /** @class */
  function(_super) {
    __extends(MDCSelectHelperText2, _super);
    function MDCSelectHelperText2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSelectHelperText2.attachTo = function(root) {
      return new MDCSelectHelperText2(root);
    };
    Object.defineProperty(MDCSelectHelperText2.prototype, "foundationForSelect", {
      // Provided for access by MDCSelect component
      get: function() {
        return this.foundation;
      },
      enumerable: false,
      configurable: true
    });
    MDCSelectHelperText2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        addClass: function(className) {
          return _this.root.classList.add(className);
        },
        removeClass: function(className) {
          return _this.root.classList.remove(className);
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        getAttr: function(attr) {
          return _this.root.getAttribute(attr);
        },
        setAttr: function(attr, value) {
          return _this.root.setAttribute(attr, value);
        },
        removeAttr: function(attr) {
          return _this.root.removeAttribute(attr);
        },
        setContent: function(content) {
          _this.root.textContent = content;
        }
      };
      return new MDCSelectHelperTextFoundation(adapter);
    };
    return MDCSelectHelperText2;
  }(MDCComponent)
);

// node_modules/@material/select/icon/constants.js
var strings6 = {
  ICON_EVENT: "MDCSelect:icon",
  ICON_ROLE: "button"
};

// node_modules/@material/select/icon/foundation.js
var INTERACTION_EVENTS = ["click", "keydown"];
var MDCSelectIconFoundation = (
  /** @class */
  function(_super) {
    __extends(MDCSelectIconFoundation2, _super);
    function MDCSelectIconFoundation2(adapter) {
      var _this = _super.call(this, __assign(__assign({}, MDCSelectIconFoundation2.defaultAdapter), adapter)) || this;
      _this.savedTabIndex = null;
      _this.interactionHandler = function(evt) {
        _this.handleInteraction(evt);
      };
      return _this;
    }
    Object.defineProperty(MDCSelectIconFoundation2, "strings", {
      get: function() {
        return strings6;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelectIconFoundation2, "defaultAdapter", {
      /**
       * See {@link MDCSelectIconAdapter} for typing information on parameters and return types.
       */
      get: function() {
        return {
          getAttr: function() {
            return null;
          },
          setAttr: function() {
            return void 0;
          },
          removeAttr: function() {
            return void 0;
          },
          setContent: function() {
            return void 0;
          },
          registerInteractionHandler: function() {
            return void 0;
          },
          deregisterInteractionHandler: function() {
            return void 0;
          },
          notifyIconAction: function() {
            return void 0;
          }
        };
      },
      enumerable: false,
      configurable: true
    });
    MDCSelectIconFoundation2.prototype.init = function() {
      var e_1, _a;
      this.savedTabIndex = this.adapter.getAttr("tabindex");
      try {
        for (var INTERACTION_EVENTS_1 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next(); !INTERACTION_EVENTS_1_1.done; INTERACTION_EVENTS_1_1 = INTERACTION_EVENTS_1.next()) {
          var evtType = INTERACTION_EVENTS_1_1.value;
          this.adapter.registerInteractionHandler(evtType, this.interactionHandler);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (INTERACTION_EVENTS_1_1 && !INTERACTION_EVENTS_1_1.done && (_a = INTERACTION_EVENTS_1.return))
            _a.call(INTERACTION_EVENTS_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    };
    MDCSelectIconFoundation2.prototype.destroy = function() {
      var e_2, _a;
      try {
        for (var INTERACTION_EVENTS_2 = __values(INTERACTION_EVENTS), INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next(); !INTERACTION_EVENTS_2_1.done; INTERACTION_EVENTS_2_1 = INTERACTION_EVENTS_2.next()) {
          var evtType = INTERACTION_EVENTS_2_1.value;
          this.adapter.deregisterInteractionHandler(evtType, this.interactionHandler);
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (INTERACTION_EVENTS_2_1 && !INTERACTION_EVENTS_2_1.done && (_a = INTERACTION_EVENTS_2.return))
            _a.call(INTERACTION_EVENTS_2);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    };
    MDCSelectIconFoundation2.prototype.setDisabled = function(disabled) {
      if (!this.savedTabIndex) {
        return;
      }
      if (disabled) {
        this.adapter.setAttr("tabindex", "-1");
        this.adapter.removeAttr("role");
      } else {
        this.adapter.setAttr("tabindex", this.savedTabIndex);
        this.adapter.setAttr("role", strings6.ICON_ROLE);
      }
    };
    MDCSelectIconFoundation2.prototype.setAriaLabel = function(label) {
      this.adapter.setAttr("aria-label", label);
    };
    MDCSelectIconFoundation2.prototype.setContent = function(content) {
      this.adapter.setContent(content);
    };
    MDCSelectIconFoundation2.prototype.handleInteraction = function(evt) {
      var isEnterKey = evt.key === "Enter" || evt.keyCode === 13;
      if (evt.type === "click" || isEnterKey) {
        this.adapter.notifyIconAction();
      }
    };
    return MDCSelectIconFoundation2;
  }(MDCFoundation)
);

// node_modules/@material/select/icon/component.js
var MDCSelectIcon = (
  /** @class */
  function(_super) {
    __extends(MDCSelectIcon2, _super);
    function MDCSelectIcon2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSelectIcon2.attachTo = function(root) {
      return new MDCSelectIcon2(root);
    };
    Object.defineProperty(MDCSelectIcon2.prototype, "foundationForSelect", {
      // Provided for access by MDCSelect component
      get: function() {
        return this.foundation;
      },
      enumerable: false,
      configurable: true
    });
    MDCSelectIcon2.prototype.getDefaultFoundation = function() {
      var _this = this;
      var adapter = {
        getAttr: function(attr) {
          return _this.root.getAttribute(attr);
        },
        setAttr: function(attr, value) {
          return _this.root.setAttribute(attr, value);
        },
        removeAttr: function(attr) {
          return _this.root.removeAttribute(attr);
        },
        setContent: function(content) {
          _this.root.textContent = content;
        },
        registerInteractionHandler: function(evtType, handler) {
          return _this.listen(evtType, handler);
        },
        deregisterInteractionHandler: function(evtType, handler) {
          return _this.unlisten(evtType, handler);
        },
        notifyIconAction: function() {
          return _this.emit(
            MDCSelectIconFoundation.strings.ICON_EVENT,
            {},
            true
            /* shouldBubble */
          );
        }
      };
      return new MDCSelectIconFoundation(adapter);
    };
    return MDCSelectIcon2;
  }(MDCComponent)
);

// node_modules/@material/select/component.js
var MDCSelect = (
  /** @class */
  function(_super) {
    __extends(MDCSelect2, _super);
    function MDCSelect2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MDCSelect2.attachTo = function(root) {
      return new MDCSelect2(root);
    };
    MDCSelect2.prototype.initialize = function(labelFactory, lineRippleFactory, outlineFactory, menuFactory, iconFactory, helperTextFactory) {
      if (labelFactory === void 0) {
        labelFactory = function(el) {
          return new MDCFloatingLabel(el);
        };
      }
      if (lineRippleFactory === void 0) {
        lineRippleFactory = function(el) {
          return new MDCLineRipple(el);
        };
      }
      if (outlineFactory === void 0) {
        outlineFactory = function(el) {
          return new MDCNotchedOutline(el);
        };
      }
      if (menuFactory === void 0) {
        menuFactory = function(el) {
          return new MDCMenu(el);
        };
      }
      if (iconFactory === void 0) {
        iconFactory = function(el) {
          return new MDCSelectIcon(el);
        };
      }
      if (helperTextFactory === void 0) {
        helperTextFactory = function(el) {
          return new MDCSelectHelperText(el);
        };
      }
      this.selectAnchor = this.root.querySelector(strings4.SELECT_ANCHOR_SELECTOR);
      this.selectedText = this.root.querySelector(strings4.SELECTED_TEXT_SELECTOR);
      this.hiddenInput = this.root.querySelector(strings4.HIDDEN_INPUT_SELECTOR);
      if (!this.selectedText) {
        throw new Error("MDCSelect: Missing required element: The following selector must be present: " + ("'" + strings4.SELECTED_TEXT_SELECTOR + "'"));
      }
      if (this.selectAnchor.hasAttribute(strings4.ARIA_CONTROLS)) {
        var helperTextElement = document.getElementById(this.selectAnchor.getAttribute(strings4.ARIA_CONTROLS));
        if (helperTextElement) {
          this.helperText = helperTextFactory(helperTextElement);
        }
      }
      this.menuSetup(menuFactory);
      var labelElement = this.root.querySelector(strings4.LABEL_SELECTOR);
      this.label = labelElement ? labelFactory(labelElement) : null;
      var lineRippleElement = this.root.querySelector(strings4.LINE_RIPPLE_SELECTOR);
      this.lineRipple = lineRippleElement ? lineRippleFactory(lineRippleElement) : null;
      var outlineElement = this.root.querySelector(strings4.OUTLINE_SELECTOR);
      this.outline = outlineElement ? outlineFactory(outlineElement) : null;
      var leadingIcon = this.root.querySelector(strings4.LEADING_ICON_SELECTOR);
      if (leadingIcon) {
        this.leadingIcon = iconFactory(leadingIcon);
      }
      if (!this.root.classList.contains(cssClasses7.OUTLINED)) {
        this.ripple = this.createRipple();
      }
    };
    MDCSelect2.prototype.initialSyncWithDOM = function() {
      var _this = this;
      this.handleFocus = function() {
        _this.foundation.handleFocus();
      };
      this.handleBlur = function() {
        _this.foundation.handleBlur();
      };
      this.handleClick = function(evt) {
        _this.selectAnchor.focus();
        _this.foundation.handleClick(_this.getNormalizedXCoordinate(evt));
      };
      this.handleKeydown = function(evt) {
        _this.foundation.handleKeydown(evt);
      };
      this.handleMenuItemAction = function(evt) {
        _this.foundation.handleMenuItemAction(evt.detail.index);
      };
      this.handleMenuOpened = function() {
        _this.foundation.handleMenuOpened();
      };
      this.handleMenuClosed = function() {
        _this.foundation.handleMenuClosed();
      };
      this.handleMenuClosing = function() {
        _this.foundation.handleMenuClosing();
      };
      this.selectAnchor.addEventListener("focus", this.handleFocus);
      this.selectAnchor.addEventListener("blur", this.handleBlur);
      this.selectAnchor.addEventListener("click", this.handleClick);
      this.selectAnchor.addEventListener("keydown", this.handleKeydown);
      this.menu.listen(strings.CLOSED_EVENT, this.handleMenuClosed);
      this.menu.listen(strings.CLOSING_EVENT, this.handleMenuClosing);
      this.menu.listen(strings.OPENED_EVENT, this.handleMenuOpened);
      this.menu.listen(strings2.SELECTED_EVENT, this.handleMenuItemAction);
      if (this.hiddenInput) {
        if (this.hiddenInput.value) {
          this.foundation.setValue(
            this.hiddenInput.value,
            /** skipNotify */
            true
          );
          this.foundation.layout();
          return;
        }
        this.hiddenInput.value = this.value;
      }
    };
    MDCSelect2.prototype.destroy = function() {
      this.selectAnchor.removeEventListener("focus", this.handleFocus);
      this.selectAnchor.removeEventListener("blur", this.handleBlur);
      this.selectAnchor.removeEventListener("keydown", this.handleKeydown);
      this.selectAnchor.removeEventListener("click", this.handleClick);
      this.menu.unlisten(strings.CLOSED_EVENT, this.handleMenuClosed);
      this.menu.unlisten(strings.OPENED_EVENT, this.handleMenuOpened);
      this.menu.unlisten(strings2.SELECTED_EVENT, this.handleMenuItemAction);
      this.menu.destroy();
      if (this.ripple) {
        this.ripple.destroy();
      }
      if (this.outline) {
        this.outline.destroy();
      }
      if (this.leadingIcon) {
        this.leadingIcon.destroy();
      }
      if (this.helperText) {
        this.helperText.destroy();
      }
      _super.prototype.destroy.call(this);
    };
    Object.defineProperty(MDCSelect2.prototype, "value", {
      get: function() {
        return this.foundation.getValue();
      },
      set: function(value) {
        this.foundation.setValue(value);
      },
      enumerable: false,
      configurable: true
    });
    MDCSelect2.prototype.setValue = function(value, skipNotify) {
      if (skipNotify === void 0) {
        skipNotify = false;
      }
      this.foundation.setValue(value, skipNotify);
    };
    Object.defineProperty(MDCSelect2.prototype, "selectedIndex", {
      get: function() {
        return this.foundation.getSelectedIndex();
      },
      set: function(selectedIndex) {
        this.foundation.setSelectedIndex(
          selectedIndex,
          /* closeMenu */
          true
        );
      },
      enumerable: false,
      configurable: true
    });
    MDCSelect2.prototype.setSelectedIndex = function(selectedIndex, skipNotify) {
      if (skipNotify === void 0) {
        skipNotify = false;
      }
      this.foundation.setSelectedIndex(
        selectedIndex,
        /* closeMenu */
        true,
        skipNotify
      );
    };
    Object.defineProperty(MDCSelect2.prototype, "disabled", {
      get: function() {
        return this.foundation.getDisabled();
      },
      set: function(disabled) {
        this.foundation.setDisabled(disabled);
        if (this.hiddenInput) {
          this.hiddenInput.disabled = disabled;
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelect2.prototype, "leadingIconAriaLabel", {
      set: function(label) {
        this.foundation.setLeadingIconAriaLabel(label);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelect2.prototype, "leadingIconContent", {
      /**
       * Sets the text content of the leading icon.
       */
      set: function(content) {
        this.foundation.setLeadingIconContent(content);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelect2.prototype, "helperTextContent", {
      /**
       * Sets the text content of the helper text.
       */
      set: function(content) {
        this.foundation.setHelperTextContent(content);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelect2.prototype, "useDefaultValidation", {
      /**
       * Enables or disables the default validation scheme where a required select
       * must be non-empty. Set to false for custom validation.
       * @param useDefaultValidation Set this to false to ignore default
       *     validation scheme.
       */
      set: function(useDefaultValidation) {
        this.foundation.setUseDefaultValidation(useDefaultValidation);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelect2.prototype, "valid", {
      /**
       * Checks if the select is in a valid state.
       */
      get: function() {
        return this.foundation.isValid();
      },
      /**
       * Sets the current invalid state of the select.
       */
      set: function(isValid) {
        this.foundation.setValid(isValid);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(MDCSelect2.prototype, "required", {
      /**
       * Returns whether the select is required.
       */
      get: function() {
        return this.foundation.getRequired();
      },
      /**
       * Sets the control to the required state.
       */
      set: function(isRequired) {
        this.foundation.setRequired(isRequired);
      },
      enumerable: false,
      configurable: true
    });
    MDCSelect2.prototype.layout = function() {
      this.foundation.layout();
    };
    MDCSelect2.prototype.layoutOptions = function() {
      this.foundation.layoutOptions();
      this.menu.layout();
      this.menuItemValues = this.menu.items.map(function(el) {
        return el.getAttribute(strings4.VALUE_ATTR) || "";
      });
      if (this.hiddenInput) {
        this.hiddenInput.value = this.value;
      }
    };
    MDCSelect2.prototype.getDefaultFoundation = function() {
      var adapter = __assign(__assign(__assign(__assign({}, this.getSelectAdapterMethods()), this.getCommonAdapterMethods()), this.getOutlineAdapterMethods()), this.getLabelAdapterMethods());
      return new MDCSelectFoundation(adapter, this.getFoundationMap());
    };
    MDCSelect2.prototype.menuSetup = function(menuFactory) {
      this.menuElement = this.root.querySelector(strings4.MENU_SELECTOR);
      this.menu = menuFactory(this.menuElement);
      this.menu.hasTypeahead = true;
      this.menu.singleSelection = true;
      this.menuItemValues = this.menu.items.map(function(el) {
        return el.getAttribute(strings4.VALUE_ATTR) || "";
      });
    };
    MDCSelect2.prototype.createRipple = function() {
      var _this = this;
      var adapter = __assign(__assign({}, MDCRipple.createAdapter({ root: this.selectAnchor })), { registerInteractionHandler: function(evtType, handler) {
        _this.selectAnchor.addEventListener(evtType, handler);
      }, deregisterInteractionHandler: function(evtType, handler) {
        _this.selectAnchor.removeEventListener(evtType, handler);
      } });
      return new MDCRipple(this.selectAnchor, new MDCRippleFoundation(adapter));
    };
    MDCSelect2.prototype.getSelectAdapterMethods = function() {
      var _this = this;
      return {
        getMenuItemAttr: function(menuItem, attr) {
          return menuItem.getAttribute(attr);
        },
        setSelectedText: function(text2) {
          _this.selectedText.textContent = text2;
        },
        isSelectAnchorFocused: function() {
          return document.activeElement === _this.selectAnchor;
        },
        getSelectAnchorAttr: function(attr) {
          return _this.selectAnchor.getAttribute(attr);
        },
        setSelectAnchorAttr: function(attr, value) {
          _this.selectAnchor.setAttribute(attr, value);
        },
        removeSelectAnchorAttr: function(attr) {
          _this.selectAnchor.removeAttribute(attr);
        },
        addMenuClass: function(className) {
          _this.menuElement.classList.add(className);
        },
        removeMenuClass: function(className) {
          _this.menuElement.classList.remove(className);
        },
        openMenu: function() {
          _this.menu.open = true;
        },
        closeMenu: function() {
          _this.menu.open = false;
        },
        getAnchorElement: function() {
          return _this.root.querySelector(strings4.SELECT_ANCHOR_SELECTOR);
        },
        setMenuAnchorElement: function(anchorEl) {
          _this.menu.setAnchorElement(anchorEl);
        },
        setMenuAnchorCorner: function(anchorCorner) {
          _this.menu.setAnchorCorner(anchorCorner);
        },
        setMenuWrapFocus: function(wrapFocus) {
          _this.menu.wrapFocus = wrapFocus;
        },
        getSelectedIndex: function() {
          var index = _this.menu.selectedIndex;
          return index instanceof Array ? index[0] : index;
        },
        setSelectedIndex: function(index) {
          _this.menu.selectedIndex = index;
        },
        focusMenuItemAtIndex: function(index) {
          _this.menu.items[index].focus();
        },
        getMenuItemCount: function() {
          return _this.menu.items.length;
        },
        // Cache menu item values. layoutOptions() updates this cache.
        getMenuItemValues: function() {
          return _this.menuItemValues;
        },
        getMenuItemTextAtIndex: function(index) {
          return _this.menu.getPrimaryTextAtIndex(index);
        },
        isTypeaheadInProgress: function() {
          return _this.menu.typeaheadInProgress;
        },
        typeaheadMatchItem: function(nextChar, startingIndex) {
          return _this.menu.typeaheadMatchItem(nextChar, startingIndex);
        }
      };
    };
    MDCSelect2.prototype.getCommonAdapterMethods = function() {
      var _this = this;
      return {
        addClass: function(className) {
          _this.root.classList.add(className);
        },
        removeClass: function(className) {
          _this.root.classList.remove(className);
        },
        hasClass: function(className) {
          return _this.root.classList.contains(className);
        },
        setRippleCenter: function(normalizedX) {
          _this.lineRipple && _this.lineRipple.setRippleCenter(normalizedX);
        },
        activateBottomLine: function() {
          _this.lineRipple && _this.lineRipple.activate();
        },
        deactivateBottomLine: function() {
          _this.lineRipple && _this.lineRipple.deactivate();
        },
        notifyChange: function(value) {
          if (_this.hiddenInput) {
            _this.hiddenInput.value = value;
          }
          var index = _this.selectedIndex;
          _this.emit(
            strings4.CHANGE_EVENT,
            { value, index },
            true
            /* shouldBubble  */
          );
        }
      };
    };
    MDCSelect2.prototype.getOutlineAdapterMethods = function() {
      var _this = this;
      return {
        hasOutline: function() {
          return Boolean(_this.outline);
        },
        notchOutline: function(labelWidth) {
          _this.outline && _this.outline.notch(labelWidth);
        },
        closeOutline: function() {
          _this.outline && _this.outline.closeNotch();
        }
      };
    };
    MDCSelect2.prototype.getLabelAdapterMethods = function() {
      var _this = this;
      return {
        hasLabel: function() {
          return !!_this.label;
        },
        floatLabel: function(shouldFloat) {
          _this.label && _this.label.float(shouldFloat);
        },
        getLabelWidth: function() {
          return _this.label ? _this.label.getWidth() : 0;
        },
        setLabelRequired: function(isRequired) {
          _this.label && _this.label.setRequired(isRequired);
        }
      };
    };
    MDCSelect2.prototype.getNormalizedXCoordinate = function(evt) {
      var targetClientRect = evt.target.getBoundingClientRect();
      var xCoordinate = this.isTouchEvent(evt) ? evt.touches[0].clientX : evt.clientX;
      return xCoordinate - targetClientRect.left;
    };
    MDCSelect2.prototype.isTouchEvent = function(evt) {
      return Boolean(evt.touches);
    };
    MDCSelect2.prototype.getFoundationMap = function() {
      return {
        helperText: this.helperText ? this.helperText.foundationForSelect : void 0,
        leadingIcon: this.leadingIcon ? this.leadingIcon.foundationForSelect : void 0
      };
    };
    return MDCSelect2;
  }(MDCComponent)
);

// node_modules/@smui/menu-surface/dist/MenuSurface.svelte
var { document: document_1 } = globals;
var file = "node_modules/@smui/menu-surface/dist/MenuSurface.svelte";
function create_fragment(ctx) {
  let t;
  let div;
  let div_class_value;
  let div_style_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[34].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[33],
    null
  );
  let div_levels = [
    {
      class: div_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-menu-surface": true,
        "mdc-menu-surface--fixed": (
          /*fixed*/
          ctx[4]
        ),
        "mdc-menu-surface--open": (
          /*isStatic*/
          ctx[3]
        ),
        "smui-menu-surface--static": (
          /*isStatic*/
          ctx[3]
        ),
        "mdc-menu-surface--fullwidth": (
          /*fullWidth*/
          ctx[5]
        ),
        .../*internalClasses*/
        ctx[8]
      })
    },
    {
      style: div_style_value = Object.entries(
        /*internalStyles*/
        ctx[9]
      ).map(func).concat([
        /*style*/
        ctx[2]
      ]).join(" ")
    },
    { role: "dialog" },
    /*$$restProps*/
    ctx[12]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      t = space();
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      t = claim_space(nodes);
      div = claim_element(nodes, "DIV", { class: true, style: true, role: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file, 2, 0, 52);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      ctx[35](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen_dev(
            document_1.body,
            "click",
            /*handleBodyClick*/
            ctx[11],
            true,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[10].call(null, div)),
          listen_dev(
            div,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[7] && /*instance*/
                ctx[7].handleKeydown.bind(
                  /*instance*/
                  ctx[7]
                )
              ))
                /*instance*/
                (ctx[7] && /*instance*/
                ctx[7].handleKeydown.bind(
                  /*instance*/
                  ctx[7]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[33],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[33]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[33],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*className, fixed, isStatic, fullWidth, internalClasses*/
        314 && div_class_value !== (div_class_value = classMap({
          [
            /*className*/
            ctx[1]
          ]: true,
          "mdc-menu-surface": true,
          "mdc-menu-surface--fixed": (
            /*fixed*/
            ctx[4]
          ),
          "mdc-menu-surface--open": (
            /*isStatic*/
            ctx[3]
          ),
          "smui-menu-surface--static": (
            /*isStatic*/
            ctx[3]
          ),
          "mdc-menu-surface--fullwidth": (
            /*fullWidth*/
            ctx[5]
          ),
          .../*internalClasses*/
          ctx[8]
        }))) && { class: div_class_value },
        (!current || dirty[0] & /*internalStyles, style*/
        516 && div_style_value !== (div_style_value = Object.entries(
          /*internalStyles*/
          ctx[9]
        ).map(func).concat([
          /*style*/
          ctx[2]
        ]).join(" "))) && { style: div_style_value },
        { role: "dialog" },
        dirty[0] & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[35](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "static",
    "anchor",
    "fixed",
    "open",
    "managed",
    "fullWidth",
    "quickOpen",
    "anchorElement",
    "anchorCorner",
    "anchorMargin",
    "maxHeight",
    "horizontallyCenteredOnViewport",
    "openBottomBias",
    "neverRestoreFocus",
    "isOpen",
    "setOpen",
    "setAbsolutePosition",
    "setIsHoisted",
    "isFixed",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("MenuSurface", slots, ["default"]);
  var _a, _b, _c;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { static: isStatic = false } = $$props;
  let { anchor = true } = $$props;
  let { fixed = false } = $$props;
  let { open = isStatic } = $$props;
  let { managed = false } = $$props;
  let { fullWidth = false } = $$props;
  let { quickOpen = false } = $$props;
  let { anchorElement = void 0 } = $$props;
  let { anchorCorner = void 0 } = $$props;
  let { anchorMargin = { top: 0, right: 0, bottom: 0, left: 0 } } = $$props;
  let { maxHeight = 0 } = $$props;
  let { horizontallyCenteredOnViewport = false } = $$props;
  let { openBottomBias = 0 } = $$props;
  let { neverRestoreFocus = false } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalStyles = {};
  let previousFocus = void 0;
  setContext("SMUI:list:role", "menu");
  setContext("SMUI:list:item:role", "menuitem");
  const iCorner = Corner;
  onMount(() => {
    $$invalidate(7, instance2 = new MDCMenuSurfaceFoundation({
      addClass,
      removeClass,
      hasClass,
      hasAnchor: () => !!anchorElement,
      notifyClose: () => {
        if (!managed) {
          $$invalidate(13, open = isStatic);
        }
        if (!open) {
          dispatch(element2, "SMUIMenuSurface:closed", void 0, void 0, true);
        }
      },
      notifyClosing: () => {
        if (!managed) {
          $$invalidate(13, open = isStatic);
        }
        if (!open) {
          dispatch(element2, "SMUIMenuSurface:closing", void 0, void 0, true);
        }
      },
      notifyOpen: () => {
        if (!managed) {
          $$invalidate(13, open = true);
        }
        if (open) {
          dispatch(element2, "SMUIMenuSurface:opened", void 0, void 0, true);
        }
      },
      notifyOpening: () => {
        if (!open) {
          dispatch(element2, "SMUIMenuSurface:opening", void 0, void 0, true);
        }
      },
      isElementInContainer: (el) => element2.contains(el),
      isRtl: () => getComputedStyle(element2).getPropertyValue("direction") === "rtl",
      setTransformOrigin: (origin) => {
        $$invalidate(9, internalStyles["transform-origin"] = origin, internalStyles);
      },
      isFocused: () => document.activeElement === element2,
      saveFocus: () => {
        var _a2;
        previousFocus = (_a2 = document.activeElement) !== null && _a2 !== void 0 ? _a2 : void 0;
      },
      restoreFocus: () => {
        if (!neverRestoreFocus && (!element2 || element2.contains(document.activeElement)) && previousFocus && document.contains(previousFocus) && "focus" in previousFocus) {
          previousFocus.focus();
        }
      },
      getInnerDimensions: () => {
        return {
          width: element2.offsetWidth,
          height: element2.offsetHeight
        };
      },
      getAnchorDimensions: () => anchorElement ? anchorElement.getBoundingClientRect() : null,
      getWindowDimensions: () => {
        return {
          width: window.innerWidth,
          height: window.innerHeight
        };
      },
      getBodyDimensions: () => {
        return {
          width: document.body.clientWidth,
          height: document.body.clientHeight
        };
      },
      getWindowScroll: () => {
        return {
          x: window.pageXOffset,
          y: window.pageYOffset
        };
      },
      setPosition: (position) => {
        $$invalidate(9, internalStyles.left = "left" in position ? `${position.left}px` : "", internalStyles);
        $$invalidate(9, internalStyles.right = "right" in position ? `${position.right}px` : "", internalStyles);
        $$invalidate(9, internalStyles.top = "top" in position ? `${position.top}px` : "", internalStyles);
        $$invalidate(9, internalStyles.bottom = "bottom" in position ? `${position.bottom}px` : "", internalStyles);
      },
      setMaxHeight: (height) => {
        $$invalidate(9, internalStyles["max-height"] = height, internalStyles);
      }
    }));
    const accessor = {
      get open() {
        return open;
      },
      set open(value) {
        $$invalidate(13, open = value);
      },
      closeProgrammatic
    };
    dispatch(element2, "SMUIMenuSurface:mount", accessor);
    instance2.init();
    return () => {
      var _a2;
      const isHoisted = instance2.isHoistedElement;
      instance2.destroy();
      if (isHoisted) {
        (_a2 = element2.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(element2);
      }
    };
  });
  onDestroy(() => {
    var _a2;
    if (anchor) {
      element2 && ((_a2 = element2.parentElement) === null || _a2 === void 0 ? void 0 : _a2.classList.remove("mdc-menu-surface--anchor"));
    }
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = false, internalClasses);
    }
  }
  function closeProgrammatic(skipRestoreFocus) {
    instance2.close(skipRestoreFocus);
    $$invalidate(13, open = false);
  }
  function handleBodyClick(event) {
    if (instance2 && open && !managed) {
      instance2.handleBodyClick(event);
    }
  }
  function isOpen() {
    return open;
  }
  function setOpen(value) {
    $$invalidate(13, open = value);
  }
  function setAbsolutePosition(x, y) {
    return instance2.setAbsolutePosition(x, y);
  }
  function setIsHoisted(isHoisted) {
    return instance2.setIsHoisted(isHoisted);
  }
  function isFixed() {
    return instance2.isFixed();
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(6, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("static" in $$new_props)
      $$invalidate(3, isStatic = $$new_props.static);
    if ("anchor" in $$new_props)
      $$invalidate(15, anchor = $$new_props.anchor);
    if ("fixed" in $$new_props)
      $$invalidate(4, fixed = $$new_props.fixed);
    if ("open" in $$new_props)
      $$invalidate(13, open = $$new_props.open);
    if ("managed" in $$new_props)
      $$invalidate(16, managed = $$new_props.managed);
    if ("fullWidth" in $$new_props)
      $$invalidate(5, fullWidth = $$new_props.fullWidth);
    if ("quickOpen" in $$new_props)
      $$invalidate(17, quickOpen = $$new_props.quickOpen);
    if ("anchorElement" in $$new_props)
      $$invalidate(14, anchorElement = $$new_props.anchorElement);
    if ("anchorCorner" in $$new_props)
      $$invalidate(18, anchorCorner = $$new_props.anchorCorner);
    if ("anchorMargin" in $$new_props)
      $$invalidate(19, anchorMargin = $$new_props.anchorMargin);
    if ("maxHeight" in $$new_props)
      $$invalidate(20, maxHeight = $$new_props.maxHeight);
    if ("horizontallyCenteredOnViewport" in $$new_props)
      $$invalidate(21, horizontallyCenteredOnViewport = $$new_props.horizontallyCenteredOnViewport);
    if ("openBottomBias" in $$new_props)
      $$invalidate(22, openBottomBias = $$new_props.openBottomBias);
    if ("neverRestoreFocus" in $$new_props)
      $$invalidate(23, neverRestoreFocus = $$new_props.neverRestoreFocus);
    if ("$$scope" in $$new_props)
      $$invalidate(33, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    _b,
    _c,
    MDCMenuSurfaceFoundation,
    onMount,
    onDestroy,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    Corner,
    forwardEvents,
    use,
    className,
    style,
    isStatic,
    anchor,
    fixed,
    open,
    managed,
    fullWidth,
    quickOpen,
    anchorElement,
    anchorCorner,
    anchorMargin,
    maxHeight,
    horizontallyCenteredOnViewport,
    openBottomBias,
    neverRestoreFocus,
    element: element2,
    instance: instance2,
    internalClasses,
    internalStyles,
    previousFocus,
    iCorner,
    hasClass,
    addClass,
    removeClass,
    closeProgrammatic,
    handleBodyClick,
    isOpen,
    setOpen,
    setAbsolutePosition,
    setIsHoisted,
    isFixed,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      $$invalidate(30, _a = $$new_props._a);
    if ("_b" in $$props)
      $$invalidate(31, _b = $$new_props._b);
    if ("_c" in $$props)
      $$invalidate(32, _c = $$new_props._c);
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("isStatic" in $$props)
      $$invalidate(3, isStatic = $$new_props.isStatic);
    if ("anchor" in $$props)
      $$invalidate(15, anchor = $$new_props.anchor);
    if ("fixed" in $$props)
      $$invalidate(4, fixed = $$new_props.fixed);
    if ("open" in $$props)
      $$invalidate(13, open = $$new_props.open);
    if ("managed" in $$props)
      $$invalidate(16, managed = $$new_props.managed);
    if ("fullWidth" in $$props)
      $$invalidate(5, fullWidth = $$new_props.fullWidth);
    if ("quickOpen" in $$props)
      $$invalidate(17, quickOpen = $$new_props.quickOpen);
    if ("anchorElement" in $$props)
      $$invalidate(14, anchorElement = $$new_props.anchorElement);
    if ("anchorCorner" in $$props)
      $$invalidate(18, anchorCorner = $$new_props.anchorCorner);
    if ("anchorMargin" in $$props)
      $$invalidate(19, anchorMargin = $$new_props.anchorMargin);
    if ("maxHeight" in $$props)
      $$invalidate(20, maxHeight = $$new_props.maxHeight);
    if ("horizontallyCenteredOnViewport" in $$props)
      $$invalidate(21, horizontallyCenteredOnViewport = $$new_props.horizontallyCenteredOnViewport);
    if ("openBottomBias" in $$props)
      $$invalidate(22, openBottomBias = $$new_props.openBottomBias);
    if ("neverRestoreFocus" in $$props)
      $$invalidate(23, neverRestoreFocus = $$new_props.neverRestoreFocus);
    if ("element" in $$props)
      $$invalidate(6, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(7, instance2 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(8, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(9, internalStyles = $$new_props.internalStyles);
    if ("previousFocus" in $$props)
      previousFocus = $$new_props.previousFocus;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*element, anchor, _a*/
    1073774656 | $$self.$$.dirty[1] & /*_b, _c*/
    3) {
      $:
        if (element2 && anchor && !($$invalidate(30, _a = element2.parentElement) === null || _a === void 0 ? void 0 : _a.classList.contains("mdc-menu-surface--anchor"))) {
          $$invalidate(31, _b = element2.parentElement) === null || _b === void 0 ? void 0 : _b.classList.add("mdc-menu-surface--anchor");
          $$invalidate(14, anchorElement = $$invalidate(32, _c = element2.parentElement) !== null && _c !== void 0 ? _c : void 0);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, open*/
    8320) {
      $:
        if (instance2 && instance2.isOpen() !== open) {
          if (open) {
            instance2.open();
          } else {
            instance2.close();
          }
        }
    }
    if ($$self.$$.dirty[0] & /*instance, quickOpen*/
    131200) {
      $:
        if (instance2) {
          instance2.setQuickOpen(quickOpen);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, fixed*/
    144) {
      $:
        if (instance2) {
          instance2.setFixedPosition(fixed);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, maxHeight*/
    1048704) {
      $:
        if (instance2) {
          instance2.setMaxHeight(maxHeight);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, horizontallyCenteredOnViewport*/
    2097280) {
      $:
        if (instance2) {
          instance2.setIsHorizontallyCenteredOnViewport(horizontallyCenteredOnViewport);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, anchorCorner*/
    262272) {
      $:
        if (instance2 && anchorCorner != null) {
          if (typeof anchorCorner === "string") {
            instance2.setAnchorCorner(iCorner[anchorCorner]);
          } else {
            instance2.setAnchorCorner(anchorCorner);
          }
        }
    }
    if ($$self.$$.dirty[0] & /*instance, anchorMargin*/
    524416) {
      $:
        if (instance2) {
          instance2.setAnchorMargin(anchorMargin);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, openBottomBias*/
    4194432) {
      $:
        if (instance2) {
          instance2.setOpenBottomBias(openBottomBias);
        }
    }
  };
  return [
    use,
    className,
    style,
    isStatic,
    fixed,
    fullWidth,
    element2,
    instance2,
    internalClasses,
    internalStyles,
    forwardEvents,
    handleBodyClick,
    $$restProps,
    open,
    anchorElement,
    anchor,
    managed,
    quickOpen,
    anchorCorner,
    anchorMargin,
    maxHeight,
    horizontallyCenteredOnViewport,
    openBottomBias,
    neverRestoreFocus,
    isOpen,
    setOpen,
    setAbsolutePosition,
    setIsHoisted,
    isFixed,
    getElement,
    _a,
    _b,
    _c,
    $$scope,
    slots,
    div_binding
  ];
}
var MenuSurface = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        style: 2,
        static: 3,
        anchor: 15,
        fixed: 4,
        open: 13,
        managed: 16,
        fullWidth: 5,
        quickOpen: 17,
        anchorElement: 14,
        anchorCorner: 18,
        anchorMargin: 19,
        maxHeight: 20,
        horizontallyCenteredOnViewport: 21,
        openBottomBias: 22,
        neverRestoreFocus: 23,
        isOpen: 24,
        setOpen: 25,
        setAbsolutePosition: 26,
        setIsHoisted: 27,
        isFixed: 28,
        getElement: 29
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "MenuSurface",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get static() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set static(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fixed() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fixed(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get managed() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set managed(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fullWidth() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fullWidth(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get quickOpen() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set quickOpen(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorElement() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorElement(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorCorner() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorCorner(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchorMargin() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchorMargin(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get maxHeight() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set maxHeight(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get horizontallyCenteredOnViewport() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set horizontallyCenteredOnViewport(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get openBottomBias() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set openBottomBias(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get neverRestoreFocus() {
    throw new Error("<MenuSurface>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set neverRestoreFocus(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    return this.$$.ctx[24];
  }
  set isOpen(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOpen() {
    return this.$$.ctx[25];
  }
  set setOpen(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setAbsolutePosition() {
    return this.$$.ctx[26];
  }
  set setAbsolutePosition(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setIsHoisted() {
    return this.$$.ctx[27];
  }
  set setIsHoisted(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isFixed() {
    return this.$$.ctx[28];
  }
  set isFixed(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[29];
  }
  set getElement(value) {
    throw new Error("<MenuSurface>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var MenuSurface_default = MenuSurface;

// node_modules/@smui/menu-surface/dist/Anchor.js
function Anchor(node, { addClass = (className) => node.classList.add(className), removeClass = (className) => node.classList.remove(className) } = {}) {
  addClass("mdc-menu-surface--anchor");
  return {
    destroy() {
      removeClass("mdc-menu-surface--anchor");
    }
  };
}

// node_modules/@smui/menu-surface/dist/index.js
var dist_default3 = MenuSurface_default;

// node_modules/@smui/menu/dist/Menu.svelte
function create_default_slot(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[17].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(1:0) <MenuSurface   bind:this={element}   use={usePass}   class={classMap({     [className]: true,     'mdc-menu': true,   })}   bind:open   on:SMUIMenuSurface:mount={handleMenuSurfaceAccessor}   on:SMUIList:mount={handleListAccessor}   on:SMUIMenuSurface:opened={() =>     instance && instance.handleMenuSurfaceOpened()}   on:keydown={handleKeydown}   on:SMUIList:action={(event) =>     instance &&     instance.handleItemAction(       listAccessor.getOrderedList()[event.detail.index].element,     )}   {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let menusurface;
  let updating_open;
  let current;
  const menusurface_spread_levels = [
    { use: (
      /*usePass*/
      ctx[5]
    ) },
    {
      class: classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-menu": true
      })
    },
    /*$$restProps*/
    ctx[9]
  ];
  function menusurface_open_binding(value) {
    ctx[19](value);
  }
  let menusurface_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < menusurface_spread_levels.length; i += 1) {
    menusurface_props = assign(menusurface_props, menusurface_spread_levels[i]);
  }
  if (
    /*open*/
    ctx[0] !== void 0
  ) {
    menusurface_props.open = /*open*/
    ctx[0];
  }
  menusurface = new dist_default3({ props: menusurface_props, $$inline: true });
  ctx[18](menusurface);
  binding_callbacks.push(() => bind(menusurface, "open", menusurface_open_binding));
  menusurface.$on(
    "SMUIMenuSurface:mount",
    /*handleMenuSurfaceAccessor*/
    ctx[7]
  );
  menusurface.$on(
    "SMUIList:mount",
    /*handleListAccessor*/
    ctx[8]
  );
  menusurface.$on(
    "SMUIMenuSurface:opened",
    /*SMUIMenuSurface_opened_handler*/
    ctx[20]
  );
  menusurface.$on(
    "keydown",
    /*handleKeydown*/
    ctx[6]
  );
  menusurface.$on(
    "SMUIList:action",
    /*SMUIList_action_handler*/
    ctx[21]
  );
  const block = {
    c: function create() {
      create_component(menusurface.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(menusurface.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(menusurface, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const menusurface_changes = dirty & /*usePass, className, $$restProps*/
      546 ? get_spread_update(menusurface_spread_levels, [
        dirty & /*usePass*/
        32 && { use: (
          /*usePass*/
          ctx2[5]
        ) },
        dirty & /*className*/
        2 && {
          class: classMap({
            [
              /*className*/
              ctx2[1]
            ]: true,
            "mdc-menu": true
          })
        },
        dirty & /*$$restProps*/
        512 && get_spread_object(
          /*$$restProps*/
          ctx2[9]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      4194304) {
        menusurface_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_open && dirty & /*open*/
      1) {
        updating_open = true;
        menusurface_changes.open = /*open*/
        ctx2[0];
        add_flush_callback(() => updating_open = false);
      }
      menusurface.$set(menusurface_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(menusurface.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(menusurface.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[18](null);
      destroy_component(menusurface, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_12($$self, $$props, $$invalidate) {
  let usePass;
  const omit_props_names = [
    "use",
    "class",
    "open",
    "isOpen",
    "setOpen",
    "setDefaultFocusState",
    "getSelectedIndex",
    "getMenuSurface",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Menu", slots, ["default"]);
  const { closest: closest2 } = ponyfill_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { open = false } = $$props;
  let element2;
  let instance2;
  let menuSurfaceAccessor;
  let listAccessor;
  onMount(() => {
    $$invalidate(3, instance2 = new MDCMenuFoundation({
      addClassToElementAtIndex: (index, className2) => {
        listAccessor.addClassForElementIndex(index, className2);
      },
      removeClassFromElementAtIndex: (index, className2) => {
        listAccessor.removeClassForElementIndex(index, className2);
      },
      addAttributeToElementAtIndex: (index, attr, value) => {
        listAccessor.setAttributeForElementIndex(index, attr, value);
      },
      removeAttributeFromElementAtIndex: (index, attr) => {
        listAccessor.removeAttributeForElementIndex(index, attr);
      },
      getAttributeFromElementAtIndex: (index, attr) => listAccessor.getAttributeFromElementIndex(index, attr),
      elementContainsClass: (element3, className2) => element3.classList.contains(className2),
      closeSurface: (skipRestoreFocus) => {
        menuSurfaceAccessor.closeProgrammatic(skipRestoreFocus);
        dispatch(getElement(), "SMUIMenu:closedProgrammatically");
      },
      getElementIndex: (element3) => listAccessor.getOrderedList().map((accessor) => accessor.element).indexOf(element3),
      notifySelected: (evtData) => dispatch(
        getElement(),
        "SMUIMenu:selected",
        {
          index: evtData.index,
          item: listAccessor.getOrderedList()[evtData.index].element
        },
        void 0,
        true
      ),
      getMenuItemCount: () => listAccessor.items.length,
      focusItemAtIndex: (index) => listAccessor.focusItemAtIndex(index),
      focusListRoot: () => "focus" in listAccessor.element && listAccessor.element.focus(),
      isSelectableItemAtIndex: (index) => !!closest2(listAccessor.getOrderedList()[index].element, `.${cssClasses5.MENU_SELECTION_GROUP}`),
      getSelectedSiblingOfItemAtIndex: (index) => {
        const orderedList = listAccessor.getOrderedList();
        const selectionGroupEl = closest2(orderedList[index].element, `.${cssClasses5.MENU_SELECTION_GROUP}`);
        const selectedItemEl = selectionGroupEl === null || selectionGroupEl === void 0 ? void 0 : selectionGroupEl.querySelector(`.${cssClasses5.MENU_SELECTED_LIST_ITEM}`);
        return selectedItemEl ? orderedList.map((item) => item.element).indexOf(selectedItemEl) : -1;
      }
    }));
    dispatch(getElement(), "SMUIMenu:mount", instance2);
    instance2.init();
    return () => {
      instance2.destroy();
    };
  });
  function handleKeydown(event) {
    instance2 && instance2.handleKeydown(event);
  }
  function handleMenuSurfaceAccessor(event) {
    if (!menuSurfaceAccessor) {
      menuSurfaceAccessor = event.detail;
    }
  }
  function handleListAccessor(event) {
    if (!listAccessor) {
      $$invalidate(4, listAccessor = event.detail);
    }
  }
  function isOpen() {
    return open;
  }
  function setOpen(value) {
    $$invalidate(0, open = value);
  }
  function setDefaultFocusState(focusState) {
    instance2.setDefaultFocusState(focusState);
  }
  function getSelectedIndex() {
    return instance2.getSelectedIndex();
  }
  function getMenuSurface() {
    return element2;
  }
  function getElement() {
    return element2.getElement();
  }
  function menusurface_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  function menusurface_open_binding(value) {
    open = value;
    $$invalidate(0, open);
  }
  const SMUIMenuSurface_opened_handler = () => instance2 && instance2.handleMenuSurfaceOpened();
  const SMUIList_action_handler = (event) => instance2 && instance2.handleItemAction(listAccessor.getOrderedList()[event.detail.index].element);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(9, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(10, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("open" in $$new_props)
      $$invalidate(0, open = $$new_props.open);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCMenuFoundation,
    cssClasses: cssClasses5,
    ponyfill: ponyfill_exports,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    dispatch,
    MenuSurface: dist_default3,
    closest: closest2,
    forwardEvents,
    use,
    className,
    open,
    element: element2,
    instance: instance2,
    menuSurfaceAccessor,
    listAccessor,
    handleKeydown,
    handleMenuSurfaceAccessor,
    handleListAccessor,
    isOpen,
    setOpen,
    setDefaultFocusState,
    getSelectedIndex,
    getMenuSurface,
    getElement,
    usePass
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(10, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("open" in $$props)
      $$invalidate(0, open = $$new_props.open);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(3, instance2 = $$new_props.instance);
    if ("menuSurfaceAccessor" in $$props)
      menuSurfaceAccessor = $$new_props.menuSurfaceAccessor;
    if ("listAccessor" in $$props)
      $$invalidate(4, listAccessor = $$new_props.listAccessor);
    if ("usePass" in $$props)
      $$invalidate(5, usePass = $$new_props.usePass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*use*/
    1024) {
      $:
        $$invalidate(5, usePass = [forwardEvents, ...use]);
    }
  };
  return [
    open,
    className,
    element2,
    instance2,
    listAccessor,
    usePass,
    handleKeydown,
    handleMenuSurfaceAccessor,
    handleListAccessor,
    $$restProps,
    use,
    isOpen,
    setOpen,
    setDefaultFocusState,
    getSelectedIndex,
    getMenuSurface,
    getElement,
    slots,
    menusurface_binding,
    menusurface_open_binding,
    SMUIMenuSurface_opened_handler,
    SMUIList_action_handler,
    $$scope
  ];
}
var Menu = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_12, create_fragment2, safe_not_equal, {
      use: 10,
      class: 1,
      open: 0,
      isOpen: 11,
      setOpen: 12,
      setDefaultFocusState: 13,
      getSelectedIndex: 14,
      getMenuSurface: 15,
      getElement: 16
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Menu",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get open() {
    throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set open(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get isOpen() {
    return this.$$.ctx[11];
  }
  set isOpen(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setOpen() {
    return this.$$.ctx[12];
  }
  set setOpen(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setDefaultFocusState() {
    return this.$$.ctx[13];
  }
  set setDefaultFocusState(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getSelectedIndex() {
    return this.$$.ctx[14];
  }
  set getSelectedIndex(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getMenuSurface() {
    return this.$$.ctx[15];
  }
  set getMenuSurface(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[16];
  }
  set getElement(value) {
    throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Menu_default = Menu;

// node_modules/@smui/menu/dist/SelectionGroupIcon.js
var SelectionGroupIcon_default = classAdderBuilder({
  class: "mdc-menu__selection-group-icon",
  component: Graphic_default
});

// node_modules/@smui/menu/dist/index.js
var dist_default4 = Menu_default;

// node_modules/@smui/floating-label/dist/FloatingLabel.svelte
var file2 = "node_modules/@smui/floating-label/dist/FloatingLabel.svelte";
function create_else_block(ctx) {
  let label;
  let label_class_value;
  let label_style_value;
  let label_for_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  let label_levels = [
    {
      class: label_class_value = classMap({
        [
          /*className*/
          ctx[3]
        ]: true,
        "mdc-floating-label": true,
        "mdc-floating-label--float-above": (
          /*floatAbove*/
          ctx[0]
        ),
        "mdc-floating-label--required": (
          /*required*/
          ctx[1]
        ),
        .../*internalClasses*/
        ctx[8]
      })
    },
    {
      style: label_style_value = Object.entries(
        /*internalStyles*/
        ctx[9]
      ).map(func_1).concat([
        /*style*/
        ctx[4]
      ]).join(" ")
    },
    {
      for: label_for_value = /*forId*/
      ctx[5] || /*inputProps*/
      (ctx[11] ? (
        /*inputProps*/
        ctx[11].id
      ) : void 0)
    },
    /*$$restProps*/
    ctx[12]
  ];
  let label_data = {};
  for (let i = 0; i < label_levels.length; i += 1) {
    label_data = assign(label_data, label_levels[i]);
  }
  const block = {
    c: function create() {
      label = element("label");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      label = claim_element(nodes, "LABEL", { class: true, style: true, for: true });
      var label_nodes = children(label);
      if (default_slot)
        default_slot.l(label_nodes);
      label_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(label, label_data);
      add_location(label, file2, 19, 2, 494);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, label, anchor);
      if (default_slot) {
        default_slot.m(label, null);
      }
      ctx[24](label);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            label,
            /*use*/
            ctx[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[10].call(null, label))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(label, label_data = get_spread_update(label_levels, [
        (!current || dirty & /*className, floatAbove, required, internalClasses*/
        267 && label_class_value !== (label_class_value = classMap({
          [
            /*className*/
            ctx2[3]
          ]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": (
            /*floatAbove*/
            ctx2[0]
          ),
          "mdc-floating-label--required": (
            /*required*/
            ctx2[1]
          ),
          .../*internalClasses*/
          ctx2[8]
        }))) && { class: label_class_value },
        (!current || dirty & /*internalStyles, style*/
        528 && label_style_value !== (label_style_value = Object.entries(
          /*internalStyles*/
          ctx2[9]
        ).map(func_1).concat([
          /*style*/
          ctx2[4]
        ]).join(" "))) && { style: label_style_value },
        (!current || dirty & /*forId*/
        32 && label_for_value !== (label_for_value = /*forId*/
        ctx2[5] || /*inputProps*/
        (ctx2[11] ? (
          /*inputProps*/
          ctx2[11].id
        ) : void 0))) && { for: label_for_value },
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[2]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(label);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(19:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let span;
  let span_class_value;
  let span_style_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  let span_levels = [
    {
      class: span_class_value = classMap({
        [
          /*className*/
          ctx[3]
        ]: true,
        "mdc-floating-label": true,
        "mdc-floating-label--float-above": (
          /*floatAbove*/
          ctx[0]
        ),
        "mdc-floating-label--required": (
          /*required*/
          ctx[1]
        ),
        .../*internalClasses*/
        ctx[8]
      })
    },
    {
      style: span_style_value = Object.entries(
        /*internalStyles*/
        ctx[9]
      ).map(func2).concat([
        /*style*/
        ctx[4]
      ]).join(" ")
    },
    /*$$restProps*/
    ctx[12]
  ];
  let span_data = {};
  for (let i = 0; i < span_levels.length; i += 1) {
    span_data = assign(span_data, span_levels[i]);
  }
  const block = {
    c: function create() {
      span = element("span");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true, style: true });
      var span_nodes = children(span);
      if (default_slot)
        default_slot.l(span_nodes);
      span_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(span, span_data);
      add_location(span, file2, 1, 2, 16);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
      if (default_slot) {
        default_slot.m(span, null);
      }
      ctx[23](span);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span,
            /*use*/
            ctx[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[10].call(null, span))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(span, span_data = get_spread_update(span_levels, [
        (!current || dirty & /*className, floatAbove, required, internalClasses*/
        267 && span_class_value !== (span_class_value = classMap({
          [
            /*className*/
            ctx2[3]
          ]: true,
          "mdc-floating-label": true,
          "mdc-floating-label--float-above": (
            /*floatAbove*/
            ctx2[0]
          ),
          "mdc-floating-label--required": (
            /*required*/
            ctx2[1]
          ),
          .../*internalClasses*/
          ctx2[8]
        }))) && { class: span_class_value },
        (!current || dirty & /*internalStyles, style*/
        528 && span_style_value !== (span_style_value = Object.entries(
          /*internalStyles*/
          ctx2[9]
        ).map(func2).concat([
          /*style*/
          ctx2[4]
        ]).join(" "))) && { style: span_style_value },
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      4)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[2]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(1:0) {#if wrapped}",
    ctx
  });
  return block;
}
function create_fragment3(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*wrapped*/
      ctx2[6]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func2 = ([name, value]) => `${name}: ${value};`;
var func_1 = ([name, value]) => `${name}: ${value};`;
function instance_13($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "for",
    "floatAbove",
    "required",
    "wrapped",
    "shake",
    "float",
    "setRequired",
    "getWidth",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("FloatingLabel", slots, ["default"]);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { for: forId = void 0 } = $$props;
  let { floatAbove = false } = $$props;
  let { required = false } = $$props;
  let { wrapped = false } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalStyles = {};
  let inputProps = (_a = getContext("SMUI:generic:input:props")) !== null && _a !== void 0 ? _a : {};
  let previousFloatAbove = floatAbove;
  let previousRequired = required;
  onMount(() => {
    $$invalidate(18, instance2 = new MDCFloatingLabelFoundation({
      addClass,
      removeClass,
      getWidth: () => {
        var _a2, _b;
        const el = getElement();
        const clone = el.cloneNode(true);
        (_a2 = el.parentNode) === null || _a2 === void 0 ? void 0 : _a2.appendChild(clone);
        clone.classList.add("smui-floating-label--remove-transition");
        clone.classList.add("smui-floating-label--force-size");
        clone.classList.remove("mdc-floating-label--float-above");
        const scrollWidth = clone.scrollWidth;
        (_b = el.parentNode) === null || _b === void 0 ? void 0 : _b.removeChild(clone);
        return scrollWidth;
      },
      registerInteractionHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
      deregisterInteractionHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
    }));
    const accessor = {
      get element() {
        return getElement();
      },
      addStyle,
      removeStyle
    };
    dispatch(element2, "SMUIFloatingLabel:mount", accessor);
    instance2.init();
    return () => {
      dispatch(element2, "SMUIFloatingLabel:unmount", accessor);
      instance2.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(8, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(9, internalStyles);
      } else {
        $$invalidate(9, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function removeStyle(name) {
    if (name in internalStyles) {
      delete internalStyles[name];
      $$invalidate(9, internalStyles);
    }
  }
  function shake(shouldShake) {
    instance2.shake(shouldShake);
  }
  function float(shouldFloat) {
    $$invalidate(0, floatAbove = shouldFloat);
  }
  function setRequired(isRequired) {
    $$invalidate(1, required = isRequired);
  }
  function getWidth() {
    return instance2.getWidth();
  }
  function getElement() {
    return element2;
  }
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  function label_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("for" in $$new_props)
      $$invalidate(5, forId = $$new_props.for);
    if ("floatAbove" in $$new_props)
      $$invalidate(0, floatAbove = $$new_props.floatAbove);
    if ("required" in $$new_props)
      $$invalidate(1, required = $$new_props.required);
    if ("wrapped" in $$new_props)
      $$invalidate(6, wrapped = $$new_props.wrapped);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    _a,
    MDCFloatingLabelFoundation,
    onMount,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    forwardEvents,
    use,
    className,
    style,
    forId,
    floatAbove,
    required,
    wrapped,
    element: element2,
    instance: instance2,
    internalClasses,
    internalStyles,
    inputProps,
    previousFloatAbove,
    previousRequired,
    addClass,
    removeClass,
    addStyle,
    removeStyle,
    shake,
    float,
    setRequired,
    getWidth,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("forId" in $$props)
      $$invalidate(5, forId = $$new_props.forId);
    if ("floatAbove" in $$props)
      $$invalidate(0, floatAbove = $$new_props.floatAbove);
    if ("required" in $$props)
      $$invalidate(1, required = $$new_props.required);
    if ("wrapped" in $$props)
      $$invalidate(6, wrapped = $$new_props.wrapped);
    if ("element" in $$props)
      $$invalidate(7, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(18, instance2 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(8, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(9, internalStyles = $$new_props.internalStyles);
    if ("inputProps" in $$props)
      $$invalidate(11, inputProps = $$new_props.inputProps);
    if ("previousFloatAbove" in $$props)
      $$invalidate(19, previousFloatAbove = $$new_props.previousFloatAbove);
    if ("previousRequired" in $$props)
      $$invalidate(20, previousRequired = $$new_props.previousRequired);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*instance, previousFloatAbove, floatAbove*/
    786433) {
      $:
        if (instance2 && previousFloatAbove !== floatAbove) {
          $$invalidate(19, previousFloatAbove = floatAbove);
          instance2.float(floatAbove);
        }
    }
    if ($$self.$$.dirty & /*instance, previousRequired, required*/
    1310722) {
      $:
        if (instance2 && previousRequired !== required) {
          $$invalidate(20, previousRequired = required);
          instance2.setRequired(required);
        }
    }
  };
  return [
    floatAbove,
    required,
    use,
    className,
    style,
    forId,
    wrapped,
    element2,
    internalClasses,
    internalStyles,
    forwardEvents,
    inputProps,
    $$restProps,
    shake,
    float,
    setRequired,
    getWidth,
    getElement,
    instance2,
    previousFloatAbove,
    previousRequired,
    $$scope,
    slots,
    span_binding,
    label_binding
  ];
}
var FloatingLabel = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_13, create_fragment3, safe_not_equal, {
      use: 2,
      class: 3,
      style: 4,
      for: 5,
      floatAbove: 0,
      required: 1,
      wrapped: 6,
      shake: 13,
      float: 14,
      setRequired: 15,
      getWidth: 16,
      getElement: 17
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "FloatingLabel",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get for() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set for(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get floatAbove() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set floatAbove(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get wrapped() {
    throw new Error("<FloatingLabel>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set wrapped(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get shake() {
    return this.$$.ctx[13];
  }
  set shake(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get float() {
    return this.$$.ctx[14];
  }
  set float(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setRequired() {
    return this.$$.ctx[15];
  }
  set setRequired(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getWidth() {
    return this.$$.ctx[16];
  }
  set getWidth(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[17];
  }
  set getElement(value) {
    throw new Error("<FloatingLabel>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var FloatingLabel_default = FloatingLabel;

// node_modules/@smui/floating-label/dist/index.js
var dist_default5 = FloatingLabel_default;

// node_modules/@smui/line-ripple/dist/LineRipple.svelte
var file3 = "node_modules/@smui/line-ripple/dist/LineRipple.svelte";
function create_fragment4(ctx) {
  let div;
  let div_class_value;
  let div_style_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let div_levels = [
    {
      class: div_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-line-ripple": true,
        "mdc-line-ripple--active": (
          /*active*/
          ctx[3]
        ),
        .../*internalClasses*/
        ctx[5]
      })
    },
    {
      style: div_style_value = Object.entries(
        /*internalStyles*/
        ctx[6]
      ).map(func3).concat([
        /*style*/
        ctx[2]
      ]).join(" ")
    },
    /*$$restProps*/
    ctx[8]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      children(div).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file3, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      ctx[13](div);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[7].call(null, div))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_attributes(div, div_data = get_spread_update(div_levels, [
        dirty & /*className, active, internalClasses*/
        42 && div_class_value !== (div_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-line-ripple": true,
          "mdc-line-ripple--active": (
            /*active*/
            ctx2[3]
          ),
          .../*internalClasses*/
          ctx2[5]
        })) && { class: div_class_value },
        dirty & /*internalStyles, style*/
        68 && div_style_value !== (div_style_value = Object.entries(
          /*internalStyles*/
          ctx2[6]
        ).map(func3).concat([
          /*style*/
          ctx2[2]
        ]).join(" ")) && { style: div_style_value },
        dirty & /*$$restProps*/
        256 && /*$$restProps*/
        ctx2[8]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[13](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func3 = ([name, value]) => `${name}: ${value};`;
function instance_14($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "active",
    "activate",
    "deactivate",
    "setRippleCenter",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("LineRipple", slots, []);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { active = false } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalStyles = {};
  onMount(() => {
    instance2 = new MDCLineRippleFoundation({
      addClass,
      removeClass,
      hasClass,
      setStyle: addStyle,
      registerEventHandler: (evtType, handler) => getElement().addEventListener(evtType, handler),
      deregisterEventHandler: (evtType, handler) => getElement().removeEventListener(evtType, handler)
    });
    instance2.init();
    return () => {
      instance2.destroy();
    };
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(5, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(5, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value) {
    if (internalStyles[name] != value) {
      if (value === "" || value == null) {
        delete internalStyles[name];
        $$invalidate(6, internalStyles);
      } else {
        $$invalidate(6, internalStyles[name] = value, internalStyles);
      }
    }
  }
  function activate() {
    instance2.activate();
  }
  function deactivate() {
    instance2.deactivate();
  }
  function setRippleCenter(xCoordinate) {
    instance2.setRippleCenter(xCoordinate);
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(8, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(2, style = $$new_props.style);
    if ("active" in $$new_props)
      $$invalidate(3, active = $$new_props.active);
  };
  $$self.$capture_state = () => ({
    MDCLineRippleFoundation,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    style,
    active,
    element: element2,
    instance: instance2,
    internalClasses,
    internalStyles,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    activate,
    deactivate,
    setRippleCenter,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(2, style = $$new_props.style);
    if ("active" in $$props)
      $$invalidate(3, active = $$new_props.active);
    if ("element" in $$props)
      $$invalidate(4, element2 = $$new_props.element);
    if ("instance" in $$props)
      instance2 = $$new_props.instance;
    if ("internalClasses" in $$props)
      $$invalidate(5, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(6, internalStyles = $$new_props.internalStyles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    style,
    active,
    element2,
    internalClasses,
    internalStyles,
    forwardEvents,
    $$restProps,
    activate,
    deactivate,
    setRippleCenter,
    getElement,
    div_binding
  ];
}
var LineRipple = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_14, create_fragment4, safe_not_equal, {
      use: 0,
      class: 1,
      style: 2,
      active: 3,
      activate: 9,
      deactivate: 10,
      setRippleCenter: 11,
      getElement: 12
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "LineRipple",
      options,
      id: create_fragment4.name
    });
  }
  get use() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<LineRipple>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get activate() {
    return this.$$.ctx[9];
  }
  set activate(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get deactivate() {
    return this.$$.ctx[10];
  }
  set deactivate(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setRippleCenter() {
    return this.$$.ctx[11];
  }
  set setRippleCenter(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[12];
  }
  set getElement(value) {
    throw new Error("<LineRipple>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var LineRipple_default = LineRipple;

// node_modules/@smui/line-ripple/dist/index.js
var dist_default6 = LineRipple_default;

// node_modules/@smui/notched-outline/dist/NotchedOutline.svelte
var file4 = "node_modules/@smui/notched-outline/dist/NotchedOutline.svelte";
function create_if_block2(ctx) {
  let div;
  let div_style_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  const block = {
    c: function create() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, style: true });
      var div_nodes = children(div);
      if (default_slot)
        default_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "mdc-notched-outline__notch");
      attr_dev(div, "style", div_style_value = Object.entries(
        /*notchStyles*/
        ctx[7]
      ).map(func4).join(" "));
      add_location(div, file4, 17, 4, 479);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*notchStyles*/
      128 && div_style_value !== (div_style_value = Object.entries(
        /*notchStyles*/
        ctx2[7]
      ).map(func4).join(" "))) {
        attr_dev(div, "style", div_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(17:2) {#if !noLabel}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let div2;
  let div0;
  let t0;
  let t1;
  let div1;
  let div2_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block = !/*noLabel*/
  ctx[3] && create_if_block2(ctx);
  let div2_levels = [
    {
      class: div2_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-notched-outline": true,
        "mdc-notched-outline--notched": (
          /*notched*/
          ctx[2]
        ),
        "mdc-notched-outline--no-label": (
          /*noLabel*/
          ctx[3]
        ),
        .../*internalClasses*/
        ctx[6]
      })
    },
    /*$$restProps*/
    ctx[10]
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      div1 = element("div");
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t0 = claim_space(div2_nodes);
      if (if_block)
        if_block.l(div2_nodes);
      t1 = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      children(div1).forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "mdc-notched-outline__leading");
      add_location(div0, file4, 15, 2, 413);
      attr_dev(div1, "class", "mdc-notched-outline__trailing");
      add_location(div1, file4, 26, 2, 682);
      set_attributes(div2, div_data_2);
      add_location(div2, file4, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div2, t0);
      if (if_block)
        if_block.m(div2, null);
      append_hydration_dev(div2, t1);
      append_hydration_dev(div2, div1);
      ctx[16](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[8].call(null, div2)),
          listen_dev(
            div2,
            "SMUIFloatingLabel:mount",
            /*handleFloatingLabelMount*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div2,
            "SMUIFloatingLabel:unmount",
            /*SMUIFloatingLabel_unmount_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (!/*noLabel*/
      ctx2[3]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*noLabel*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        (!current || dirty & /*className, notched, noLabel, internalClasses*/
        78 && div2_class_value !== (div2_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-notched-outline": true,
          "mdc-notched-outline--notched": (
            /*notched*/
            ctx2[2]
          ),
          "mdc-notched-outline--no-label": (
            /*noLabel*/
            ctx2[3]
          ),
          .../*internalClasses*/
          ctx2[6]
        }))) && { class: div2_class_value },
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block)
        if_block.d();
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func4 = ([name, value]) => `${name}: ${value};`;
function instance_15($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "notched", "noLabel", "notch", "closeNotch", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("NotchedOutline", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { notched = false } = $$props;
  let { noLabel = false } = $$props;
  let element2;
  let instance2;
  let floatingLabel;
  let internalClasses = {};
  let notchStyles = {};
  onMount(() => {
    instance2 = new MDCNotchedOutlineFoundation({
      addClass,
      removeClass,
      setNotchWidthProperty: (width) => addNotchStyle("width", width + "px"),
      removeNotchWidthProperty: () => removeNotchStyle("width")
    });
    instance2.init();
    return () => {
      instance2.destroy();
    };
  });
  function handleFloatingLabelMount(event) {
    $$invalidate(4, floatingLabel = event.detail);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = false, internalClasses);
    }
  }
  function addNotchStyle(name, value) {
    if (notchStyles[name] != value) {
      if (value === "" || value == null) {
        delete notchStyles[name];
        $$invalidate(7, notchStyles);
      } else {
        $$invalidate(7, notchStyles[name] = value, notchStyles);
      }
    }
  }
  function removeNotchStyle(name) {
    if (name in notchStyles) {
      delete notchStyles[name];
      $$invalidate(7, notchStyles);
    }
  }
  function notch(notchWidth) {
    instance2.notch(notchWidth);
  }
  function closeNotch() {
    instance2.closeNotch();
  }
  function getElement() {
    return element2;
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  const SMUIFloatingLabel_unmount_handler = () => $$invalidate(4, floatingLabel = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("notched" in $$new_props)
      $$invalidate(2, notched = $$new_props.notched);
    if ("noLabel" in $$new_props)
      $$invalidate(3, noLabel = $$new_props.noLabel);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCNotchedOutlineFoundation,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    notched,
    noLabel,
    element: element2,
    instance: instance2,
    floatingLabel,
    internalClasses,
    notchStyles,
    handleFloatingLabelMount,
    addClass,
    removeClass,
    addNotchStyle,
    removeNotchStyle,
    notch,
    closeNotch,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("notched" in $$props)
      $$invalidate(2, notched = $$new_props.notched);
    if ("noLabel" in $$props)
      $$invalidate(3, noLabel = $$new_props.noLabel);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("instance" in $$props)
      instance2 = $$new_props.instance;
    if ("floatingLabel" in $$props)
      $$invalidate(4, floatingLabel = $$new_props.floatingLabel);
    if ("internalClasses" in $$props)
      $$invalidate(6, internalClasses = $$new_props.internalClasses);
    if ("notchStyles" in $$props)
      $$invalidate(7, notchStyles = $$new_props.notchStyles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*floatingLabel*/
    16) {
      $:
        if (floatingLabel) {
          floatingLabel.addStyle("transition-duration", "0s");
          addClass("mdc-notched-outline--upgraded");
          requestAnimationFrame(() => {
            if (floatingLabel) {
              floatingLabel.removeStyle("transition-duration");
            }
          });
        } else {
          removeClass("mdc-notched-outline--upgraded");
        }
    }
  };
  return [
    use,
    className,
    notched,
    noLabel,
    floatingLabel,
    element2,
    internalClasses,
    notchStyles,
    forwardEvents,
    handleFloatingLabelMount,
    $$restProps,
    notch,
    closeNotch,
    getElement,
    $$scope,
    slots,
    div2_binding,
    SMUIFloatingLabel_unmount_handler
  ];
}
var NotchedOutline = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_15, create_fragment5, safe_not_equal, {
      use: 0,
      class: 1,
      notched: 2,
      noLabel: 3,
      notch: 11,
      closeNotch: 12,
      getElement: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "NotchedOutline",
      options,
      id: create_fragment5.name
    });
  }
  get use() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notched() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set notched(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noLabel() {
    throw new Error("<NotchedOutline>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noLabel(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get notch() {
    return this.$$.ctx[11];
  }
  set notch(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closeNotch() {
    return this.$$.ctx[12];
  }
  set closeNotch(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[13];
  }
  set getElement(value) {
    throw new Error("<NotchedOutline>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var NotchedOutline_default = NotchedOutline;

// node_modules/@smui/notched-outline/dist/index.js
var dist_default7 = NotchedOutline_default;

// node_modules/@smui/select/dist/helper-text/HelperText.svelte
var file5 = "node_modules/@smui/select/dist/helper-text/HelperText.svelte";
function create_else_block2(ctx) {
  let t;
  const block = {
    c: function create() {
      t = text(
        /*content*/
        ctx[8]
      );
    },
    l: function claim(nodes) {
      t = claim_text(
        nodes,
        /*content*/
        ctx[8]
      );
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*content*/
      256)
        set_data_dev(
          t,
          /*content*/
          ctx2[8]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block2.name,
    type: "else",
    source: "(17:31) {:else}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[13].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[12],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4096)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[12],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[12]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[12],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(17:2) {#if content == null}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let div_class_value;
  let div_aria_hidden_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block3, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*content*/
      ctx2[8] == null
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let div_levels = [
    {
      class: div_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-select-helper-text": true,
        "mdc-select-helper-text--validation-msg": (
          /*validationMsg*/
          ctx[4]
        ),
        "mdc-select-helper-text--validation-msg-persistent": (
          /*persistent*/
          ctx[3]
        ),
        .../*internalClasses*/
        ctx[6]
      })
    },
    {
      "aria-hidden": div_aria_hidden_value = /*persistent*/
      ctx[3] ? void 0 : "true"
    },
    { id: (
      /*id*/
      ctx[2]
    ) },
    /*internalAttrs*/
    ctx[7],
    /*$$restProps*/
    ctx[10]
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", {
        class: true,
        "aria-hidden": true,
        id: true
      });
      var div_nodes = children(div);
      if_block.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file5, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[14](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[9].call(null, div))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty & /*className, validationMsg, persistent, internalClasses*/
        90 && div_class_value !== (div_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-select-helper-text": true,
          "mdc-select-helper-text--validation-msg": (
            /*validationMsg*/
            ctx2[4]
          ),
          "mdc-select-helper-text--validation-msg-persistent": (
            /*persistent*/
            ctx2[3]
          ),
          .../*internalClasses*/
          ctx2[6]
        }))) && { class: div_class_value },
        (!current || dirty & /*persistent*/
        8 && div_aria_hidden_value !== (div_aria_hidden_value = /*persistent*/
        ctx2[3] ? void 0 : "true")) && { "aria-hidden": div_aria_hidden_value },
        (!current || dirty & /*id*/
        4) && { id: (
          /*id*/
          ctx2[2]
        ) },
        dirty & /*internalAttrs*/
        128 && /*internalAttrs*/
        ctx2[7],
        dirty & /*$$restProps*/
        1024 && /*$$restProps*/
        ctx2[10]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if_blocks[current_block_type_index].d();
      ctx[14](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var counter = 0;
function instance_16($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "id", "persistent", "validationMsg", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("HelperText", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { id = "SMUI-select-helper-text-" + counter++ } = $$props;
  let { persistent = false } = $$props;
  let { validationMsg = false } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalAttrs = {};
  let content = void 0;
  onMount(() => {
    instance2 = new MDCSelectHelperTextFoundation({
      addClass,
      removeClass,
      hasClass,
      getAttr,
      setAttr: addAttr,
      removeAttr,
      setContent: (value) => {
        $$invalidate(8, content = value);
      }
    });
    if (id.startsWith("SMUI-select-helper-text-")) {
      dispatch(getElement(), "SMUISelectHelperText:id", id);
    }
    dispatch(getElement(), "SMUISelectHelperText:mount", instance2);
    instance2.init();
    return () => {
      dispatch(getElement(), "SMUISelectHelperText:unmount", instance2);
      instance2.destroy();
    };
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(6, internalClasses[className2] = false, internalClasses);
    }
  }
  function getAttr(name) {
    var _a;
    return name in internalAttrs ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(7, internalAttrs[name] = value, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(7, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function getElement() {
    return element2;
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(5, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(10, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("id" in $$new_props)
      $$invalidate(2, id = $$new_props.id);
    if ("persistent" in $$new_props)
      $$invalidate(3, persistent = $$new_props.persistent);
    if ("validationMsg" in $$new_props)
      $$invalidate(4, validationMsg = $$new_props.validationMsg);
    if ("$$scope" in $$new_props)
      $$invalidate(12, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    counter,
    MDCSelectHelperTextFoundation,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    forwardEvents,
    use,
    className,
    id,
    persistent,
    validationMsg,
    element: element2,
    instance: instance2,
    internalClasses,
    internalAttrs,
    content,
    hasClass,
    addClass,
    removeClass,
    getAttr,
    addAttr,
    removeAttr,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("id" in $$props)
      $$invalidate(2, id = $$new_props.id);
    if ("persistent" in $$props)
      $$invalidate(3, persistent = $$new_props.persistent);
    if ("validationMsg" in $$props)
      $$invalidate(4, validationMsg = $$new_props.validationMsg);
    if ("element" in $$props)
      $$invalidate(5, element2 = $$new_props.element);
    if ("instance" in $$props)
      instance2 = $$new_props.instance;
    if ("internalClasses" in $$props)
      $$invalidate(6, internalClasses = $$new_props.internalClasses);
    if ("internalAttrs" in $$props)
      $$invalidate(7, internalAttrs = $$new_props.internalAttrs);
    if ("content" in $$props)
      $$invalidate(8, content = $$new_props.content);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    id,
    persistent,
    validationMsg,
    element2,
    internalClasses,
    internalAttrs,
    content,
    forwardEvents,
    $$restProps,
    getElement,
    $$scope,
    slots,
    div_binding
  ];
}
var HelperText = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_16, create_fragment6, safe_not_equal, {
      use: 0,
      class: 1,
      id: 2,
      persistent: 3,
      validationMsg: 4,
      getElement: 11
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "HelperText",
      options,
      id: create_fragment6.name
    });
  }
  get use() {
    throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get id() {
    throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set id(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get persistent() {
    throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set persistent(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get validationMsg() {
    throw new Error("<HelperText>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set validationMsg(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[11];
  }
  set getElement(value) {
    throw new Error("<HelperText>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var HelperText_default = HelperText;

// node_modules/@smui/select/dist/Select.svelte
var file6 = "node_modules/@smui/select/dist/Select.svelte";
var get_helperText_slot_changes = (dirty) => ({});
var get_helperText_slot_context = (ctx) => ({});
var get_leadingIcon_slot_changes = (dirty) => ({});
var get_leadingIcon_slot_context = (ctx) => ({});
var get_label_slot_changes_1 = (dirty) => ({});
var get_label_slot_context_1 = (ctx) => ({});
var get_label_slot_changes = (dirty) => ({});
var get_label_slot_context = (ctx) => ({});
function create_if_block_6(ctx) {
  let input;
  let input_levels = [
    { type: "hidden" },
    { required: (
      /*required*/
      ctx[10]
    ) },
    { disabled: (
      /*disabled*/
      ctx[6]
    ) },
    { value: (
      /*value*/
      ctx[0]
    ) },
    prefixFilter(
      /*$$restProps*/
      ctx[53],
      "input$"
    )
  ];
  let input_data = {};
  for (let i = 0; i < input_levels.length; i += 1) {
    input_data = assign(input_data, input_levels[i]);
  }
  const block = {
    c: function create() {
      input = element("input");
      this.h();
    },
    l: function claim(nodes) {
      input = claim_element(nodes, "INPUT", { type: true });
      this.h();
    },
    h: function hydrate() {
      set_attributes(input, input_data);
      add_location(input, file6, 51, 4, 1440);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, input, anchor);
      if (input.autofocus)
        input.focus();
    },
    p: function update(ctx2, dirty) {
      set_attributes(input, input_data = get_spread_update(input_levels, [
        { type: "hidden" },
        dirty[0] & /*required*/
        1024 && { required: (
          /*required*/
          ctx2[10]
        ) },
        dirty[0] & /*disabled*/
        64 && { disabled: (
          /*disabled*/
          ctx2[6]
        ) },
        dirty[0] & /*value*/
        1 && { value: (
          /*value*/
          ctx2[0]
        ) },
        dirty[1] & /*$$restProps*/
        4194304 && prefixFilter(
          /*$$restProps*/
          ctx2[53],
          "input$"
        )
      ]));
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(input);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_6.name,
    type: "if",
    source: "(51:2) {#if hiddenInput}",
    ctx
  });
  return block;
}
function create_if_block_5(ctx) {
  let span;
  const block = {
    c: function create() {
      span = element("span");
      this.h();
    },
    l: function claim(nodes) {
      span = claim_element(nodes, "SPAN", { class: true });
      children(span).forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(span, "class", "mdc-select__ripple");
      add_location(span, file6, 88, 6, 2452);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, span, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(span);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_5.name,
    type: "if",
    source: "(88:4) {#if variant === 'filled'}",
    ctx
  });
  return block;
}
function create_if_block_4(ctx) {
  let floatinglabel;
  let current;
  const floatinglabel_spread_levels = [
    { id: (
      /*inputId*/
      ctx[11] + "-smui-label"
    ) },
    {
      floatAbove: (
        /*$selectedTextStore*/
        ctx[42] !== ""
      )
    },
    { required: (
      /*required*/
      ctx[10]
    ) },
    prefixFilter(
      /*$$restProps*/
      ctx[53],
      "label$"
    )
  ];
  let floatinglabel_props = {
    $$slots: { default: [create_default_slot_5] },
    $$scope: { ctx }
  };
  for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
  }
  floatinglabel = new dist_default5({
    props: floatinglabel_props,
    $$inline: true
  });
  ctx[67](floatinglabel);
  const block = {
    c: function create() {
      create_component(floatinglabel.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(floatinglabel.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(floatinglabel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const floatinglabel_changes = dirty[0] & /*inputId, required*/
      3072 | dirty[1] & /*$selectedTextStore, $$restProps*/
      4196352 ? get_spread_update(floatinglabel_spread_levels, [
        dirty[0] & /*inputId*/
        2048 && { id: (
          /*inputId*/
          ctx2[11] + "-smui-label"
        ) },
        dirty[1] & /*$selectedTextStore*/
        2048 && {
          floatAbove: (
            /*$selectedTextStore*/
            ctx2[42] !== ""
          )
        },
        dirty[0] & /*required*/
        1024 && { required: (
          /*required*/
          ctx2[10]
        ) },
        dirty[1] & /*$$restProps*/
        4194304 && get_spread_object(prefixFilter(
          /*$$restProps*/
          ctx2[53],
          "label$"
        ))
      ]) : {};
      if (dirty[0] & /*label*/
      512 | dirty[2] & /*$$scope*/
      33554432) {
        floatinglabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatinglabel.$set(floatinglabel_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(floatinglabel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(floatinglabel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[67](null);
      destroy_component(floatinglabel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_4.name,
    type: "if",
    source: "(91:4) {#if variant !== 'outlined' && !noLabel && (label != null || $$slots.label)}",
    ctx
  });
  return block;
}
function create_default_slot_5(ctx) {
  let t_value = (
    /*label*/
    (ctx[9] == null ? "" : (
      /*label*/
      ctx[9]
    )) + ""
  );
  let t;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[64].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[87],
    get_label_slot_context
  );
  const block = {
    c: function create() {
      t = text(t_value);
      if (label_slot)
        label_slot.c();
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
      if (label_slot)
        label_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*label*/
      512) && t_value !== (t_value = /*label*/
      (ctx2[9] == null ? "" : (
        /*label*/
        ctx2[9]
      )) + ""))
        set_data_dev(t, t_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & /*$$scope*/
        33554432)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[87],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[87]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[87],
              dirty,
              get_label_slot_changes
            ),
            get_label_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_5.name,
    type: "slot",
    source: "(92:6) <FloatingLabel         bind:this={floatingLabel}         id={inputId + '-smui-label'}         floatAbove={$selectedTextStore !== ''}         {required}         {...prefixFilter($$restProps, 'label$')}         >",
    ctx
  });
  return block;
}
function create_if_block_2(ctx) {
  let notchedoutline;
  let current;
  const notchedoutline_spread_levels = [
    {
      noLabel: (
        /*noLabel*/
        ctx[8] || /*label*/
        ctx[9] == null && !/*$$slots*/
        ctx[54].label
      )
    },
    prefixFilter(
      /*$$restProps*/
      ctx[53],
      "outline$"
    )
  ];
  let notchedoutline_props = {
    $$slots: { default: [create_default_slot_3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < notchedoutline_spread_levels.length; i += 1) {
    notchedoutline_props = assign(notchedoutline_props, notchedoutline_spread_levels[i]);
  }
  notchedoutline = new dist_default7({
    props: notchedoutline_props,
    $$inline: true
  });
  ctx[69](notchedoutline);
  const block = {
    c: function create() {
      create_component(notchedoutline.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(notchedoutline.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(notchedoutline, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const notchedoutline_changes = dirty[0] & /*noLabel, label*/
      768 | dirty[1] & /*$$slots, $$restProps*/
      12582912 ? get_spread_update(notchedoutline_spread_levels, [
        dirty[0] & /*noLabel, label*/
        768 | dirty[1] & /*$$slots*/
        8388608 && {
          noLabel: (
            /*noLabel*/
            ctx2[8] || /*label*/
            ctx2[9] == null && !/*$$slots*/
            ctx2[54].label
          )
        },
        dirty[1] & /*$$restProps*/
        4194304 && get_spread_object(prefixFilter(
          /*$$restProps*/
          ctx2[53],
          "outline$"
        ))
      ]) : {};
      if (dirty[0] & /*inputId, required, label, noLabel*/
      3840 | dirty[1] & /*$selectedTextStore, $$restProps, floatingLabel, $$slots*/
      12585216 | dirty[2] & /*$$scope*/
      33554432) {
        notchedoutline_changes.$$scope = { dirty, ctx: ctx2 };
      }
      notchedoutline.$set(notchedoutline_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(notchedoutline.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(notchedoutline.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[69](null);
      destroy_component(notchedoutline, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_2.name,
    type: "if",
    source: "(101:4) {#if variant === 'outlined'}",
    ctx
  });
  return block;
}
function create_if_block_3(ctx) {
  let floatinglabel;
  let current;
  const floatinglabel_spread_levels = [
    { id: (
      /*inputId*/
      ctx[11] + "-smui-label"
    ) },
    {
      floatAbove: (
        /*$selectedTextStore*/
        ctx[42] !== ""
      )
    },
    { required: (
      /*required*/
      ctx[10]
    ) },
    prefixFilter(
      /*$$restProps*/
      ctx[53],
      "label$"
    )
  ];
  let floatinglabel_props = {
    $$slots: { default: [create_default_slot_4] },
    $$scope: { ctx }
  };
  for (let i = 0; i < floatinglabel_spread_levels.length; i += 1) {
    floatinglabel_props = assign(floatinglabel_props, floatinglabel_spread_levels[i]);
  }
  floatinglabel = new dist_default5({
    props: floatinglabel_props,
    $$inline: true
  });
  ctx[68](floatinglabel);
  const block = {
    c: function create() {
      create_component(floatinglabel.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(floatinglabel.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(floatinglabel, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const floatinglabel_changes = dirty[0] & /*inputId, required*/
      3072 | dirty[1] & /*$selectedTextStore, $$restProps*/
      4196352 ? get_spread_update(floatinglabel_spread_levels, [
        dirty[0] & /*inputId*/
        2048 && { id: (
          /*inputId*/
          ctx2[11] + "-smui-label"
        ) },
        dirty[1] & /*$selectedTextStore*/
        2048 && {
          floatAbove: (
            /*$selectedTextStore*/
            ctx2[42] !== ""
          )
        },
        dirty[0] & /*required*/
        1024 && { required: (
          /*required*/
          ctx2[10]
        ) },
        dirty[1] & /*$$restProps*/
        4194304 && get_spread_object(prefixFilter(
          /*$$restProps*/
          ctx2[53],
          "label$"
        ))
      ]) : {};
      if (dirty[0] & /*label*/
      512 | dirty[2] & /*$$scope*/
      33554432) {
        floatinglabel_changes.$$scope = { dirty, ctx: ctx2 };
      }
      floatinglabel.$set(floatinglabel_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(floatinglabel.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(floatinglabel.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[68](null);
      destroy_component(floatinglabel, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_3.name,
    type: "if",
    source: "(107:8) {#if !noLabel && (label != null || $$slots.label)}",
    ctx
  });
  return block;
}
function create_default_slot_4(ctx) {
  let t_value = (
    /*label*/
    (ctx[9] == null ? "" : (
      /*label*/
      ctx[9]
    )) + ""
  );
  let t;
  let current;
  const label_slot_template = (
    /*#slots*/
    ctx[64].label
  );
  const label_slot = create_slot(
    label_slot_template,
    ctx,
    /*$$scope*/
    ctx[87],
    get_label_slot_context_1
  );
  const block = {
    c: function create() {
      t = text(t_value);
      if (label_slot)
        label_slot.c();
    },
    l: function claim(nodes) {
      t = claim_text(nodes, t_value);
      if (label_slot)
        label_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, t, anchor);
      if (label_slot) {
        label_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if ((!current || dirty[0] & /*label*/
      512) && t_value !== (t_value = /*label*/
      (ctx2[9] == null ? "" : (
        /*label*/
        ctx2[9]
      )) + ""))
        set_data_dev(t, t_value);
      if (label_slot) {
        if (label_slot.p && (!current || dirty[2] & /*$$scope*/
        33554432)) {
          update_slot_base(
            label_slot,
            label_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[87],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[87]
            ) : get_slot_changes(
              label_slot_template,
              /*$$scope*/
              ctx2[87],
              dirty,
              get_label_slot_changes_1
            ),
            get_label_slot_context_1
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(label_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(label_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(t);
      }
      if (label_slot)
        label_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_4.name,
    type: "slot",
    source: "(108:10) <FloatingLabel             bind:this={floatingLabel}             id={inputId + '-smui-label'}             floatAbove={$selectedTextStore !== ''}             {required}             {...prefixFilter($$restProps, 'label$')}             >",
    ctx
  });
  return block;
}
function create_default_slot_3(ctx) {
  let if_block_anchor;
  let current;
  let if_block = !/*noLabel*/
  ctx[8] && /*label*/
  (ctx[9] != null || /*$$slots*/
  ctx[54].label) && create_if_block_3(ctx);
  const block = {
    c: function create() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if (if_block)
        if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (!/*noLabel*/
      ctx2[8] && /*label*/
      (ctx2[9] != null || /*$$slots*/
      ctx2[54].label)) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*noLabel, label*/
          768 | dirty[1] & /*$$slots*/
          8388608) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_3.name,
    type: "slot",
    source: "(102:6) <NotchedOutline         bind:this={notchedOutline}         noLabel={noLabel || (label == null && !$$slots.label)}         {...prefixFilter($$restProps, 'outline$')}       >",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let lineripple;
  let current;
  const lineripple_spread_levels = [prefixFilter(
    /*$$restProps*/
    ctx[53],
    "ripple$"
  )];
  let lineripple_props = {};
  for (let i = 0; i < lineripple_spread_levels.length; i += 1) {
    lineripple_props = assign(lineripple_props, lineripple_spread_levels[i]);
  }
  lineripple = new dist_default6({ props: lineripple_props, $$inline: true });
  ctx[70](lineripple);
  const block = {
    c: function create() {
      create_component(lineripple.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(lineripple.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(lineripple, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const lineripple_changes = dirty[1] & /*$$restProps*/
      4194304 ? get_spread_update(lineripple_spread_levels, [get_spread_object(prefixFilter(
        /*$$restProps*/
        ctx2[53],
        "ripple$"
      ))]) : {};
      lineripple.$set(lineripple_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(lineripple.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(lineripple.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[70](null);
      destroy_component(lineripple, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(170:4) {#if variant !== 'outlined' && ripple}",
    ctx
  });
  return block;
}
function create_default_slot_2(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[64].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[87],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[2] & /*$$scope*/
        33554432)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[87],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[87]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[87],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_2.name,
    type: "slot",
    source: `(197:4) <List       role=\\"listbox\\"       {wrapFocus}       bind:selectedIndex       on:SMUIList:mount={(event) => (list = event.detail)}       {...prefixFilter($$restProps, 'list$')}>`,
    ctx
  });
  return block;
}
function create_default_slot_1(ctx) {
  let list_1;
  let updating_selectedIndex;
  let current;
  const list_1_spread_levels = [
    { role: "listbox" },
    { wrapFocus: (
      /*wrapFocus*/
      ctx[35]
    ) },
    prefixFilter(
      /*$$restProps*/
      ctx[53],
      "list$"
    )
  ];
  function list_1_selectedIndex_binding(value) {
    ctx[75](value);
  }
  let list_1_props = {
    $$slots: { default: [create_default_slot_2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < list_1_spread_levels.length; i += 1) {
    list_1_props = assign(list_1_props, list_1_spread_levels[i]);
  }
  if (
    /*selectedIndex*/
    ctx[24] !== void 0
  ) {
    list_1_props.selectedIndex = /*selectedIndex*/
    ctx[24];
  }
  list_1 = new dist_default2({ props: list_1_props, $$inline: true });
  binding_callbacks.push(() => bind(list_1, "selectedIndex", list_1_selectedIndex_binding));
  list_1.$on(
    "SMUIList:mount",
    /*SMUIList_mount_handler*/
    ctx[76]
  );
  const block = {
    c: function create() {
      create_component(list_1.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(list_1.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(list_1, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const list_1_changes = dirty[1] & /*wrapFocus, $$restProps*/
      4194320 ? get_spread_update(list_1_spread_levels, [
        list_1_spread_levels[0],
        dirty[1] & /*wrapFocus*/
        16 && { wrapFocus: (
          /*wrapFocus*/
          ctx2[35]
        ) },
        dirty[1] & /*$$restProps*/
        4194304 && get_spread_object(prefixFilter(
          /*$$restProps*/
          ctx2[53],
          "list$"
        ))
      ]) : {};
      if (dirty[2] & /*$$scope*/
      33554432) {
        list_1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_selectedIndex && dirty[0] & /*selectedIndex*/
      16777216) {
        updating_selectedIndex = true;
        list_1_changes.selectedIndex = /*selectedIndex*/
        ctx2[24];
        add_flush_callback(() => updating_selectedIndex = false);
      }
      list_1.$set(list_1_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(list_1.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(list_1.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(list_1, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot_1.name,
    type: "slot",
    source: "(178:2) <Menu     class={classMap({       [menu$class]: true,       'mdc-select__menu': true,       ...menuClasses,     })}     id={menuId}     fullWidth     anchor={false}     {anchorElement}     {anchorCorner}     bind:open={menuOpen}     on:SMUIMenu:selected={(event) =>       instance && instance.handleMenuItemAction(event.detail.index)}     on:SMUIMenuSurface:closing={() => instance && instance.handleMenuClosing()}     on:SMUIMenuSurface:closed={() => instance && instance.handleMenuClosed()}     on:SMUIMenuSurface:opened={() => instance && instance.handleMenuOpened()}     {...prefixFilter($$restProps, 'menu$')}   >",
    ctx
  });
  return block;
}
function create_if_block4(ctx) {
  let helpertext;
  let current;
  const helpertext_spread_levels = [prefixFilter(
    /*$$restProps*/
    ctx[53],
    "helperText$"
  )];
  let helpertext_props = {
    $$slots: { default: [create_default_slot2] },
    $$scope: { ctx }
  };
  for (let i = 0; i < helpertext_spread_levels.length; i += 1) {
    helpertext_props = assign(helpertext_props, helpertext_spread_levels[i]);
  }
  helpertext = new HelperText_default({ props: helpertext_props, $$inline: true });
  helpertext.$on(
    "SMUISelectHelperText:id",
    /*SMUISelectHelperText_id_handler*/
    ctx[84]
  );
  helpertext.$on(
    "SMUISelectHelperText:mount",
    /*SMUISelectHelperText_mount_handler*/
    ctx[85]
  );
  helpertext.$on(
    "SMUISelectHelperText:unmount",
    /*SMUISelectHelperText_unmount_handler*/
    ctx[86]
  );
  const block = {
    c: function create() {
      create_component(helpertext.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(helpertext.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(helpertext, target, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      const helpertext_changes = dirty[1] & /*$$restProps*/
      4194304 ? get_spread_update(helpertext_spread_levels, [get_spread_object(prefixFilter(
        /*$$restProps*/
        ctx2[53],
        "helperText$"
      ))]) : {};
      if (dirty[2] & /*$$scope*/
      33554432) {
        helpertext_changes.$$scope = { dirty, ctx: ctx2 };
      }
      helpertext.$set(helpertext_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(helpertext.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(helpertext.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(helpertext, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block4.name,
    type: "if",
    source: "(206:0) {#if $$slots.helperText}",
    ctx
  });
  return block;
}
function create_default_slot2(ctx) {
  let current;
  const helperText_slot_template = (
    /*#slots*/
    ctx[64].helperText
  );
  const helperText_slot = create_slot(
    helperText_slot_template,
    ctx,
    /*$$scope*/
    ctx[87],
    get_helperText_slot_context
  );
  const block = {
    c: function create() {
      if (helperText_slot)
        helperText_slot.c();
    },
    l: function claim(nodes) {
      if (helperText_slot)
        helperText_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (helperText_slot) {
        helperText_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (helperText_slot) {
        if (helperText_slot.p && (!current || dirty[2] & /*$$scope*/
        33554432)) {
          update_slot_base(
            helperText_slot,
            helperText_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[87],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[87]
            ) : get_slot_changes(
              helperText_slot_template,
              /*$$scope*/
              ctx2[87],
              dirty,
              get_helperText_slot_changes
            ),
            get_helperText_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(helperText_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(helperText_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (helperText_slot)
        helperText_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot2.name,
    type: "slot",
    source: "(207:2) <HelperText     on:SMUISelectHelperText:id={(event) => (helperId = event.detail)}     on:SMUISelectHelperText:mount={(event) => (helperText = event.detail)}     on:SMUISelectHelperText:unmount={() => {       helperId = undefined;       helperText = undefined;     }}     {...prefixFilter($$restProps, 'helperText$')}     >",
    ctx
  });
  return block;
}
function create_fragment7(ctx) {
  let div1;
  let t0;
  let div0;
  let t1;
  let t2;
  let t3;
  let t4;
  let span1;
  let span0;
  let t5;
  let span0_id_value;
  let span0_class_value;
  let span0_aria_labelledby_value;
  let useActions_action;
  let span1_class_value;
  let useActions_action_1;
  let t6;
  let span2;
  let svg;
  let polygon0;
  let polygon1;
  let span2_class_value;
  let useActions_action_2;
  let t7;
  let div0_class_value;
  let div0_aria_required_value;
  let div0_aria_disabled_value;
  let div0_aria_expanded_value;
  let useActions_action_3;
  let t8;
  let menu;
  let updating_open;
  let div1_class_value;
  let div1_style_value;
  let Ripple_action;
  let Anchor_action;
  let useActions_action_4;
  let forwardEvents_action;
  let t9;
  let if_block5_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*hiddenInput*/
    ctx[12] && create_if_block_6(ctx)
  );
  let if_block1 = (
    /*variant*/
    ctx[7] === "filled" && create_if_block_5(ctx)
  );
  let if_block2 = (
    /*variant*/
    ctx[7] !== "outlined" && !/*noLabel*/
    ctx[8] && /*label*/
    (ctx[9] != null || /*$$slots*/
    ctx[54].label) && create_if_block_4(ctx)
  );
  let if_block3 = (
    /*variant*/
    ctx[7] === "outlined" && create_if_block_2(ctx)
  );
  const leadingIcon_slot_template = (
    /*#slots*/
    ctx[64].leadingIcon
  );
  const leadingIcon_slot = create_slot(
    leadingIcon_slot_template,
    ctx,
    /*$$scope*/
    ctx[87],
    get_leadingIcon_slot_context
  );
  let span0_levels = [
    {
      id: span0_id_value = /*inputId*/
      ctx[11] + "-smui-selected-text"
    },
    {
      class: span0_class_value = classMap({
        [
          /*selectedText$class*/
          ctx[19]
        ]: true,
        "mdc-select__selected-text": true
      })
    },
    { role: "button" },
    { "aria-haspopup": "listbox" },
    {
      "aria-labelledby": span0_aria_labelledby_value = /*inputId*/
      ctx[11] + "-smui-label"
    },
    prefixFilter(
      /*$$restProps*/
      ctx[53],
      "selectedText$"
    )
  ];
  let span_data_1 = {};
  for (let i = 0; i < span0_levels.length; i += 1) {
    span_data_1 = assign(span_data_1, span0_levels[i]);
  }
  let span1_levels = [
    {
      class: span1_class_value = classMap({
        [
          /*selectedTextContainer$class*/
          ctx[17]
        ]: true,
        "mdc-select__selected-text-container": true
      })
    },
    prefixFilter(
      /*$$restProps*/
      ctx[53],
      "selectedTextContainer$"
    )
  ];
  let span_data_2 = {};
  for (let i = 0; i < span1_levels.length; i += 1) {
    span_data_2 = assign(span_data_2, span1_levels[i]);
  }
  let span2_levels = [
    {
      class: span2_class_value = classMap({
        [
          /*dropdownIcon$class*/
          ctx[21]
        ]: true,
        "mdc-select__dropdown-icon": true
      })
    },
    prefixFilter(
      /*$$restProps*/
      ctx[53],
      "dropdownIcon$"
    )
  ];
  let span_data = {};
  for (let i = 0; i < span2_levels.length; i += 1) {
    span_data = assign(span_data, span2_levels[i]);
  }
  let if_block4 = (
    /*variant*/
    ctx[7] !== "outlined" && /*ripple*/
    ctx[5] && create_if_block_1(ctx)
  );
  let div0_levels = [
    {
      class: div0_class_value = classMap({
        [
          /*anchor$class*/
          ctx[15]
        ]: true,
        "mdc-select__anchor": true
      })
    },
    {
      "aria-required": div0_aria_required_value = /*required*/
      ctx[10] ? "true" : void 0
    },
    {
      "aria-disabled": div0_aria_disabled_value = /*disabled*/
      ctx[6] ? "true" : void 0
    },
    { "aria-controls": (
      /*menuId*/
      ctx[45]
    ) },
    {
      "aria-expanded": div0_aria_expanded_value = /*menuOpen*/
      ctx[31] ? "true" : "false"
    },
    { "aria-describedby": (
      /*helperId*/
      ctx[30]
    ) },
    { role: "combobox" },
    { tabindex: "0" },
    /*selectAnchorAttrs*/
    ctx[29],
    prefixFilter(
      /*$$restProps*/
      ctx[53],
      "anchor$"
    )
  ];
  let div_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data = assign(div_data, div0_levels[i]);
  }
  const menu_spread_levels = [
    {
      class: classMap({
        [
          /*menu$class*/
          ctx[22]
        ]: true,
        "mdc-select__menu": true,
        .../*menuClasses*/
        ctx[32]
      })
    },
    { id: (
      /*menuId*/
      ctx[45]
    ) },
    { fullWidth: true },
    { anchor: false },
    { anchorElement: (
      /*anchorElement*/
      ctx[33]
    ) },
    { anchorCorner: (
      /*anchorCorner*/
      ctx[34]
    ) },
    prefixFilter(
      /*$$restProps*/
      ctx[53],
      "menu$"
    )
  ];
  function menu_open_binding(value) {
    ctx[77](value);
  }
  let menu_props = {
    $$slots: { default: [create_default_slot_1] },
    $$scope: { ctx }
  };
  for (let i = 0; i < menu_spread_levels.length; i += 1) {
    menu_props = assign(menu_props, menu_spread_levels[i]);
  }
  if (
    /*menuOpen*/
    ctx[31] !== void 0
  ) {
    menu_props.open = /*menuOpen*/
    ctx[31];
  }
  menu = new dist_default4({ props: menu_props, $$inline: true });
  binding_callbacks.push(() => bind(menu, "open", menu_open_binding));
  menu.$on(
    "SMUIMenu:selected",
    /*SMUIMenu_selected_handler*/
    ctx[78]
  );
  menu.$on(
    "SMUIMenuSurface:closing",
    /*SMUIMenuSurface_closing_handler*/
    ctx[79]
  );
  menu.$on(
    "SMUIMenuSurface:closed",
    /*SMUIMenuSurface_closed_handler*/
    ctx[80]
  );
  menu.$on(
    "SMUIMenuSurface:opened",
    /*SMUIMenuSurface_opened_handler*/
    ctx[81]
  );
  let div1_levels = [
    {
      class: div1_class_value = classMap({
        [
          /*className*/
          ctx[3]
        ]: true,
        "mdc-select": true,
        "mdc-select--required": (
          /*required*/
          ctx[10]
        ),
        "mdc-select--disabled": (
          /*disabled*/
          ctx[6]
        ),
        "mdc-select--filled": (
          /*variant*/
          ctx[7] === "filled"
        ),
        "mdc-select--outlined": (
          /*variant*/
          ctx[7] === "outlined"
        ),
        "smui-select--standard": (
          /*variant*/
          ctx[7] === "standard"
        ),
        "mdc-select--with-leading-icon": (
          /*isUninitializedValue*/
          ctx[44](
            /*withLeadingIcon*/
            ctx[13]
          ) ? (
            /*$$slots*/
            ctx[54].leadingIcon
          ) : (
            /*withLeadingIcon*/
            ctx[13]
          )
        ),
        "mdc-select--no-label": (
          /*noLabel*/
          ctx[8] || /*label*/
          ctx[9] == null && !/*$$slots*/
          ctx[54].label
        ),
        "mdc-select--invalid": (
          /*invalid*/
          ctx[1]
        ),
        "mdc-select--activated": (
          /*menuOpen*/
          ctx[31]
        ),
        "mdc-data-table__pagination-rows-per-page-select": (
          /*context*/
          ctx[46] === "data-table:pagination"
        ),
        .../*internalClasses*/
        ctx[26]
      })
    },
    {
      style: div1_style_value = Object.entries(
        /*internalStyles*/
        ctx[27]
      ).map(func5).concat([
        /*style*/
        ctx[4]
      ]).join(" ")
    },
    exclude(
      /*$$restProps*/
      ctx[53],
      [
        "input$",
        "anchor$",
        "label$",
        "outline$",
        "selectedTextContainer$",
        "selectedText$",
        "dropdownIcon$",
        "ripple$",
        "menu$",
        "list$",
        "helperText$"
      ]
    )
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  let if_block5 = (
    /*$$slots*/
    ctx[54].helperText && create_if_block4(ctx)
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (leadingIcon_slot)
        leadingIcon_slot.c();
      t4 = space();
      span1 = element("span");
      span0 = element("span");
      t5 = text(
        /*$selectedTextStore*/
        ctx[42]
      );
      t6 = space();
      span2 = element("span");
      svg = svg_element("svg");
      polygon0 = svg_element("polygon");
      polygon1 = svg_element("polygon");
      t7 = space();
      if (if_block4)
        if_block4.c();
      t8 = space();
      create_component(menu.$$.fragment);
      t9 = space();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        "aria-required": true,
        "aria-disabled": true,
        "aria-controls": true,
        "aria-expanded": true,
        "aria-describedby": true,
        role: true,
        tabindex: true
      });
      var div0_nodes = children(div0);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (if_block2)
        if_block2.l(div0_nodes);
      t2 = claim_space(div0_nodes);
      if (if_block3)
        if_block3.l(div0_nodes);
      t3 = claim_space(div0_nodes);
      if (leadingIcon_slot)
        leadingIcon_slot.l(div0_nodes);
      t4 = claim_space(div0_nodes);
      span1 = claim_element(div0_nodes, "SPAN", { class: true });
      var span1_nodes = children(span1);
      span0 = claim_element(span1_nodes, "SPAN", {
        id: true,
        class: true,
        role: true,
        "aria-haspopup": true,
        "aria-labelledby": true
      });
      var span0_nodes = children(span0);
      t5 = claim_text(
        span0_nodes,
        /*$selectedTextStore*/
        ctx[42]
      );
      span0_nodes.forEach(detach_dev);
      span1_nodes.forEach(detach_dev);
      t6 = claim_space(div0_nodes);
      span2 = claim_element(div0_nodes, "SPAN", { class: true });
      var span2_nodes = children(span2);
      svg = claim_svg_element(span2_nodes, "svg", {
        class: true,
        viewBox: true,
        focusable: true
      });
      var svg_nodes = children(svg);
      polygon0 = claim_svg_element(svg_nodes, "polygon", {
        class: true,
        stroke: true,
        "fill-rule": true,
        points: true
      });
      children(polygon0).forEach(detach_dev);
      polygon1 = claim_svg_element(svg_nodes, "polygon", {
        class: true,
        stroke: true,
        "fill-rule": true,
        points: true
      });
      children(polygon1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      span2_nodes.forEach(detach_dev);
      t7 = claim_space(div0_nodes);
      if (if_block4)
        if_block4.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      t8 = claim_space(div1_nodes);
      claim_component(menu.$$.fragment, div1_nodes);
      div1_nodes.forEach(detach_dev);
      t9 = claim_space(nodes);
      if (if_block5)
        if_block5.l(nodes);
      if_block5_anchor = empty();
      this.h();
    },
    h: function hydrate() {
      set_attributes(span0, span_data_1);
      add_location(span0, file6, 127, 6, 3816);
      set_attributes(span1, span_data_2);
      add_location(span1, file6, 119, 4, 3554);
      attr_dev(polygon0, "class", "mdc-select__dropdown-icon-inactive");
      attr_dev(polygon0, "stroke", "none");
      attr_dev(polygon0, "fill-rule", "evenodd");
      attr_dev(polygon0, "points", "7 10 12 15 17 10");
      add_location(polygon0, file6, 155, 8, 4607);
      attr_dev(polygon1, "class", "mdc-select__dropdown-icon-active");
      attr_dev(polygon1, "stroke", "none");
      attr_dev(polygon1, "fill-rule", "evenodd");
      attr_dev(polygon1, "points", "7 15 12 10 17 15");
      add_location(polygon1, file6, 161, 8, 4778);
      attr_dev(svg, "class", "mdc-select__dropdown-icon-graphic");
      attr_dev(svg, "viewBox", "7 10 10 5");
      attr_dev(svg, "focusable", "false");
      add_location(svg, file6, 150, 6, 4482);
      set_attributes(span2, span_data);
      add_location(span2, file6, 142, 4, 4257);
      set_attributes(div0, div_data);
      add_location(div0, file6, 59, 2, 1579);
      set_attributes(div1, div_data_1);
      add_location(div1, file6, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div0, t1);
      if (if_block2)
        if_block2.m(div0, null);
      append_hydration_dev(div0, t2);
      if (if_block3)
        if_block3.m(div0, null);
      append_hydration_dev(div0, t3);
      if (leadingIcon_slot) {
        leadingIcon_slot.m(div0, null);
      }
      append_hydration_dev(div0, t4);
      append_hydration_dev(div0, span1);
      append_hydration_dev(span1, span0);
      append_hydration_dev(span0, t5);
      append_hydration_dev(div0, t6);
      append_hydration_dev(div0, span2);
      append_hydration_dev(span2, svg);
      append_hydration_dev(svg, polygon0);
      append_hydration_dev(svg, polygon1);
      append_hydration_dev(div0, t7);
      if (if_block4)
        if_block4.m(div0, null);
      ctx[71](div0);
      append_hydration_dev(div1, t8);
      mount_component(menu, div1, null);
      ctx[82](div1);
      insert_hydration_dev(target, t9, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert_hydration_dev(target, if_block5_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            span0,
            /*selectedText$use*/
            ctx[18]
          )),
          action_destroyer(useActions_action_1 = useActions.call(
            null,
            span1,
            /*selectedTextContainer$use*/
            ctx[16]
          )),
          action_destroyer(useActions_action_2 = useActions.call(
            null,
            span2,
            /*dropdownIcon$use*/
            ctx[20]
          )),
          action_destroyer(useActions_action_3 = useActions.call(
            null,
            div0,
            /*anchor$use*/
            ctx[14]
          )),
          listen_dev(
            div0,
            "focus",
            /*focus_handler_1*/
            ctx[72],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "blur",
            /*blur_handler_1*/
            ctx[73],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "click",
            /*click_handler*/
            ctx[74],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[23] && /*instance*/
                ctx[23].handleKeydown.bind(
                  /*instance*/
                  ctx[23]
                )
              ))
                /*instance*/
                (ctx[23] && /*instance*/
                ctx[23].handleKeydown.bind(
                  /*instance*/
                  ctx[23]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "focus",
            /*focus_handler*/
            ctx[65],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div0,
            "blur",
            /*blur_handler*/
            ctx[66],
            false,
            false,
            false,
            false
          ),
          action_destroyer(Ripple_action = dist_default.call(null, div1, {
            ripple: (
              /*variant*/
              ctx[7] === "filled"
            ),
            unbounded: false,
            addClass: (
              /*addClass*/
              ctx[50]
            ),
            removeClass: (
              /*removeClass*/
              ctx[51]
            ),
            addStyle: (
              /*addStyle*/
              ctx[52]
            )
          })),
          action_destroyer(Anchor_action = Anchor.call(null, div1, {
            addClass: (
              /*addClass*/
              ctx[50]
            ),
            removeClass: (
              /*removeClass*/
              ctx[51]
            )
          })),
          action_destroyer(useActions_action_4 = useActions.call(
            null,
            div1,
            /*use*/
            ctx[2]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[43].call(null, div1)),
          listen_dev(
            div1,
            "SMUISelectLeadingIcon:mount",
            /*handleLeadingIconMount*/
            ctx[49],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "SMUISelectLeadingIcon:unmount",
            /*SMUISelectLeadingIcon_unmount_handler*/
            ctx[83],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*hiddenInput*/
        ctx[12]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_6(ctx);
          if_block0.c();
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*variant*/
        ctx[7] === "filled"
      ) {
        if (if_block1) {
        } else {
          if_block1 = create_if_block_5(ctx);
          if_block1.c();
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*variant*/
        ctx[7] !== "outlined" && !/*noLabel*/
        ctx[8] && /*label*/
        (ctx[9] != null || /*$$slots*/
        ctx[54].label)
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
          if (dirty[0] & /*variant, noLabel, label*/
          896 | dirty[1] & /*$$slots*/
          8388608) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4(ctx);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div0, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*variant*/
        ctx[7] === "outlined"
      ) {
        if (if_block3) {
          if_block3.p(ctx, dirty);
          if (dirty[0] & /*variant*/
          128) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2(ctx);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div0, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (leadingIcon_slot) {
        if (leadingIcon_slot.p && (!current || dirty[2] & /*$$scope*/
        33554432)) {
          update_slot_base(
            leadingIcon_slot,
            leadingIcon_slot_template,
            ctx,
            /*$$scope*/
            ctx[87],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[87]
            ) : get_slot_changes(
              leadingIcon_slot_template,
              /*$$scope*/
              ctx[87],
              dirty,
              get_leadingIcon_slot_changes
            ),
            get_leadingIcon_slot_context
          );
        }
      }
      if (!current || dirty[1] & /*$selectedTextStore*/
      2048)
        set_data_maybe_contenteditable_dev(
          t5,
          /*$selectedTextStore*/
          ctx[42],
          span_data_1["contenteditable"]
        );
      set_attributes(span0, span_data_1 = get_spread_update(span0_levels, [
        (!current || dirty[0] & /*inputId*/
        2048 && span0_id_value !== (span0_id_value = /*inputId*/
        ctx[11] + "-smui-selected-text")) && { id: span0_id_value },
        (!current || dirty[0] & /*selectedText$class*/
        524288 && span0_class_value !== (span0_class_value = classMap({
          [
            /*selectedText$class*/
            ctx[19]
          ]: true,
          "mdc-select__selected-text": true
        }))) && { class: span0_class_value },
        { role: "button" },
        { "aria-haspopup": "listbox" },
        (!current || dirty[0] & /*inputId*/
        2048 && span0_aria_labelledby_value !== (span0_aria_labelledby_value = /*inputId*/
        ctx[11] + "-smui-label")) && {
          "aria-labelledby": span0_aria_labelledby_value
        },
        dirty[1] & /*$$restProps*/
        4194304 && prefixFilter(
          /*$$restProps*/
          ctx[53],
          "selectedText$"
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*selectedText$use*/
      262144)
        useActions_action.update.call(
          null,
          /*selectedText$use*/
          ctx[18]
        );
      set_attributes(span1, span_data_2 = get_spread_update(span1_levels, [
        (!current || dirty[0] & /*selectedTextContainer$class*/
        131072 && span1_class_value !== (span1_class_value = classMap({
          [
            /*selectedTextContainer$class*/
            ctx[17]
          ]: true,
          "mdc-select__selected-text-container": true
        }))) && { class: span1_class_value },
        dirty[1] & /*$$restProps*/
        4194304 && prefixFilter(
          /*$$restProps*/
          ctx[53],
          "selectedTextContainer$"
        )
      ]));
      if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & /*selectedTextContainer$use*/
      65536)
        useActions_action_1.update.call(
          null,
          /*selectedTextContainer$use*/
          ctx[16]
        );
      set_attributes(span2, span_data = get_spread_update(span2_levels, [
        (!current || dirty[0] & /*dropdownIcon$class*/
        2097152 && span2_class_value !== (span2_class_value = classMap({
          [
            /*dropdownIcon$class*/
            ctx[21]
          ]: true,
          "mdc-select__dropdown-icon": true
        }))) && { class: span2_class_value },
        dirty[1] & /*$$restProps*/
        4194304 && prefixFilter(
          /*$$restProps*/
          ctx[53],
          "dropdownIcon$"
        )
      ]));
      if (useActions_action_2 && is_function(useActions_action_2.update) && dirty[0] & /*dropdownIcon$use*/
      1048576)
        useActions_action_2.update.call(
          null,
          /*dropdownIcon$use*/
          ctx[20]
        );
      if (
        /*variant*/
        ctx[7] !== "outlined" && /*ripple*/
        ctx[5]
      ) {
        if (if_block4) {
          if_block4.p(ctx, dirty);
          if (dirty[0] & /*variant, ripple*/
          160) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_1(ctx);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div0, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      set_attributes(div0, div_data = get_spread_update(div0_levels, [
        (!current || dirty[0] & /*anchor$class*/
        32768 && div0_class_value !== (div0_class_value = classMap({
          [
            /*anchor$class*/
            ctx[15]
          ]: true,
          "mdc-select__anchor": true
        }))) && { class: div0_class_value },
        (!current || dirty[0] & /*required*/
        1024 && div0_aria_required_value !== (div0_aria_required_value = /*required*/
        ctx[10] ? "true" : void 0)) && {
          "aria-required": div0_aria_required_value
        },
        (!current || dirty[0] & /*disabled*/
        64 && div0_aria_disabled_value !== (div0_aria_disabled_value = /*disabled*/
        ctx[6] ? "true" : void 0)) && {
          "aria-disabled": div0_aria_disabled_value
        },
        { "aria-controls": (
          /*menuId*/
          ctx[45]
        ) },
        (!current || dirty[1] & /*menuOpen*/
        1 && div0_aria_expanded_value !== (div0_aria_expanded_value = /*menuOpen*/
        ctx[31] ? "true" : "false")) && {
          "aria-expanded": div0_aria_expanded_value
        },
        (!current || dirty[0] & /*helperId*/
        1073741824) && { "aria-describedby": (
          /*helperId*/
          ctx[30]
        ) },
        { role: "combobox" },
        { tabindex: "0" },
        dirty[0] & /*selectAnchorAttrs*/
        536870912 && /*selectAnchorAttrs*/
        ctx[29],
        dirty[1] & /*$$restProps*/
        4194304 && prefixFilter(
          /*$$restProps*/
          ctx[53],
          "anchor$"
        )
      ]));
      if (useActions_action_3 && is_function(useActions_action_3.update) && dirty[0] & /*anchor$use*/
      16384)
        useActions_action_3.update.call(
          null,
          /*anchor$use*/
          ctx[14]
        );
      const menu_changes = dirty[0] & /*menu$class*/
      4194304 | dirty[1] & /*menuClasses, menuId, anchorElement, anchorCorner, $$restProps*/
      4210702 ? get_spread_update(menu_spread_levels, [
        dirty[0] & /*menu$class*/
        4194304 | dirty[1] & /*menuClasses*/
        2 && {
          class: classMap({
            [
              /*menu$class*/
              ctx[22]
            ]: true,
            "mdc-select__menu": true,
            .../*menuClasses*/
            ctx[32]
          })
        },
        dirty[1] & /*menuId*/
        16384 && { id: (
          /*menuId*/
          ctx[45]
        ) },
        menu_spread_levels[2],
        menu_spread_levels[3],
        dirty[1] & /*anchorElement*/
        4 && { anchorElement: (
          /*anchorElement*/
          ctx[33]
        ) },
        dirty[1] & /*anchorCorner*/
        8 && { anchorCorner: (
          /*anchorCorner*/
          ctx[34]
        ) },
        dirty[1] & /*$$restProps*/
        4194304 && get_spread_object(prefixFilter(
          /*$$restProps*/
          ctx[53],
          "menu$"
        ))
      ]) : {};
      if (dirty[0] & /*selectedIndex*/
      16777216 | dirty[1] & /*wrapFocus, $$restProps, list*/
      4194352 | dirty[2] & /*$$scope*/
      33554432) {
        menu_changes.$$scope = { dirty, ctx };
      }
      if (!updating_open && dirty[1] & /*menuOpen*/
      1) {
        updating_open = true;
        menu_changes.open = /*menuOpen*/
        ctx[31];
        add_flush_callback(() => updating_open = false);
      }
      menu.$set(menu_changes);
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*className, required, disabled, variant, withLeadingIcon, noLabel, label, invalid, internalClasses*/
        67119050 | dirty[1] & /*$$slots, menuOpen*/
        8388609 && div1_class_value !== (div1_class_value = classMap({
          [
            /*className*/
            ctx[3]
          ]: true,
          "mdc-select": true,
          "mdc-select--required": (
            /*required*/
            ctx[10]
          ),
          "mdc-select--disabled": (
            /*disabled*/
            ctx[6]
          ),
          "mdc-select--filled": (
            /*variant*/
            ctx[7] === "filled"
          ),
          "mdc-select--outlined": (
            /*variant*/
            ctx[7] === "outlined"
          ),
          "smui-select--standard": (
            /*variant*/
            ctx[7] === "standard"
          ),
          "mdc-select--with-leading-icon": (
            /*isUninitializedValue*/
            ctx[44](
              /*withLeadingIcon*/
              ctx[13]
            ) ? (
              /*$$slots*/
              ctx[54].leadingIcon
            ) : (
              /*withLeadingIcon*/
              ctx[13]
            )
          ),
          "mdc-select--no-label": (
            /*noLabel*/
            ctx[8] || /*label*/
            ctx[9] == null && !/*$$slots*/
            ctx[54].label
          ),
          "mdc-select--invalid": (
            /*invalid*/
            ctx[1]
          ),
          "mdc-select--activated": (
            /*menuOpen*/
            ctx[31]
          ),
          "mdc-data-table__pagination-rows-per-page-select": (
            /*context*/
            ctx[46] === "data-table:pagination"
          ),
          .../*internalClasses*/
          ctx[26]
        }))) && { class: div1_class_value },
        (!current || dirty[0] & /*internalStyles, style*/
        134217744 && div1_style_value !== (div1_style_value = Object.entries(
          /*internalStyles*/
          ctx[27]
        ).map(func5).concat([
          /*style*/
          ctx[4]
        ]).join(" "))) && { style: div1_style_value },
        dirty[1] & /*$$restProps*/
        4194304 && exclude(
          /*$$restProps*/
          ctx[53],
          [
            "input$",
            "anchor$",
            "label$",
            "outline$",
            "selectedTextContainer$",
            "selectedText$",
            "dropdownIcon$",
            "ripple$",
            "menu$",
            "list$",
            "helperText$"
          ]
        )
      ]));
      if (Ripple_action && is_function(Ripple_action.update) && dirty[0] & /*variant*/
      128)
        Ripple_action.update.call(null, {
          ripple: (
            /*variant*/
            ctx[7] === "filled"
          ),
          unbounded: false,
          addClass: (
            /*addClass*/
            ctx[50]
          ),
          removeClass: (
            /*removeClass*/
            ctx[51]
          ),
          addStyle: (
            /*addStyle*/
            ctx[52]
          )
        });
      if (useActions_action_4 && is_function(useActions_action_4.update) && dirty[0] & /*use*/
      4)
        useActions_action_4.update.call(
          null,
          /*use*/
          ctx[2]
        );
      if (
        /*$$slots*/
        ctx[54].helperText
      ) {
        if (if_block5) {
          if_block5.p(ctx, dirty);
          if (dirty[1] & /*$$slots*/
          8388608) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block4(ctx);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(leadingIcon_slot, local);
      transition_in(if_block4);
      transition_in(menu.$$.fragment, local);
      transition_in(if_block5);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(leadingIcon_slot, local);
      transition_out(if_block4);
      transition_out(menu.$$.fragment, local);
      transition_out(if_block5);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
        detach_dev(t9);
        detach_dev(if_block5_anchor);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (leadingIcon_slot)
        leadingIcon_slot.d(detaching);
      if (if_block4)
        if_block4.d();
      ctx[71](null);
      destroy_component(menu);
      ctx[82](null);
      if (if_block5)
        if_block5.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment7.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var counter2 = 0;
function getNormalizedXCoordinate(evt) {
  const targetClientRect = evt.currentTarget.getBoundingClientRect();
  const xCoordinate = isTouchEvent(evt) ? evt.touches[0].clientX : evt.clientX;
  return xCoordinate - targetClientRect.left;
}
function isTouchEvent(evt) {
  return "touches" in evt;
}
var func5 = ([name, value]) => `${name}: ${value};`;
function instance_17($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "style",
    "ripple",
    "disabled",
    "variant",
    "noLabel",
    "label",
    "value",
    "key",
    "dirty",
    "invalid",
    "updateInvalid",
    "required",
    "inputId",
    "hiddenInput",
    "withLeadingIcon",
    "anchor$use",
    "anchor$class",
    "selectedTextContainer$use",
    "selectedTextContainer$class",
    "selectedText$use",
    "selectedText$class",
    "dropdownIcon$use",
    "dropdownIcon$class",
    "menu$class",
    "getUseDefaultValidation",
    "setUseDefaultValidation",
    "focus",
    "layout",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedTextStore;
  let $valueStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Select", slots, ["label", "leadingIcon", "default", "helperText"]);
  const $$slots = compute_slots(slots);
  var _a;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let uninitializedValue = () => {
  };
  function isUninitializedValue(value2) {
    return value2 === uninitializedValue;
  }
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { style = "" } = $$props;
  let { ripple = true } = $$props;
  let { disabled = false } = $$props;
  let { variant = "standard" } = $$props;
  let { noLabel = false } = $$props;
  let { label = void 0 } = $$props;
  let { value = "" } = $$props;
  let { key = (item) => item } = $$props;
  let { dirty = false } = $$props;
  let { invalid = uninitializedValue } = $$props;
  let { updateInvalid = isUninitializedValue(invalid) } = $$props;
  const useDefaultValidation = isUninitializedValue(invalid);
  if (isUninitializedValue(invalid)) {
    invalid = false;
  }
  let { required = false } = $$props;
  let { inputId = "SMUI-select-" + counter2++ } = $$props;
  let { hiddenInput = false } = $$props;
  let { withLeadingIcon = uninitializedValue } = $$props;
  let { anchor$use = [] } = $$props;
  let { anchor$class = "" } = $$props;
  let { selectedTextContainer$use = [] } = $$props;
  let { selectedTextContainer$class = "" } = $$props;
  let { selectedText$use = [] } = $$props;
  let { selectedText$class = "" } = $$props;
  let { dropdownIcon$use = [] } = $$props;
  let { dropdownIcon$class = "" } = $$props;
  let { menu$class = "" } = $$props;
  let element2;
  let instance2;
  let internalClasses = {};
  let internalStyles = {};
  let selectAnchor;
  let selectAnchorAttrs = {};
  let selectedIndex = -1;
  let menuId = (_a = $$restProps["menu$id"]) !== null && _a !== void 0 ? _a : inputId + "-menu";
  let helperId = void 0;
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let menuOpen = false;
  let menuClasses = {};
  let anchorElement = void 0;
  let anchorCorner = void 0;
  let wrapFocus = false;
  let list;
  let context = getContext("SMUI:select:context");
  let leadingIcon = void 0;
  let helperText = void 0;
  let floatingLabel = void 0;
  let lineRipple = void 0;
  let notchedOutline = void 0;
  setContext("SMUI:list:role", "");
  setContext("SMUI:list:nav", false);
  const selectedTextStore = writable("");
  validate_store(selectedTextStore, "selectedTextStore");
  component_subscribe($$self, selectedTextStore, (value2) => $$invalidate(42, $selectedTextStore = value2));
  setContext("SMUI:select:selectedText", selectedTextStore);
  const valueStore = writable(value);
  validate_store(valueStore, "valueStore");
  component_subscribe($$self, valueStore, (value2) => $$invalidate(90, $valueStore = value2));
  setContext("SMUI:select:value", valueStore);
  let previousSelectedIndex = selectedIndex;
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  onMount(() => {
    $$invalidate(23, instance2 = new MDCSelectFoundation(
      {
        // getSelectAdapterMethods
        // getMenuItemAttr: (menuItem: Element, attr: string) =>
        //   menuItem.getAttribute(attr),
        setSelectedText: (text2) => {
          set_store_value(selectedTextStore, $selectedTextStore = text2, $selectedTextStore);
        },
        isSelectAnchorFocused: () => document.activeElement === selectAnchor,
        getSelectAnchorAttr,
        setSelectAnchorAttr: addSelectAnchorAttr,
        removeSelectAnchorAttr,
        addMenuClass,
        removeMenuClass,
        openMenu: () => {
          $$invalidate(31, menuOpen = true);
        },
        closeMenu: () => {
          $$invalidate(31, menuOpen = false);
        },
        getAnchorElement: () => selectAnchor,
        setMenuAnchorElement: (value2) => {
          $$invalidate(33, anchorElement = value2);
        },
        setMenuAnchorCorner: (value2) => {
          $$invalidate(34, anchorCorner = value2);
        },
        setMenuWrapFocus: (value2) => {
          $$invalidate(35, wrapFocus = value2);
        },
        getSelectedIndex: () => selectedIndex,
        setSelectedIndex: (index) => {
          $$invalidate(63, previousSelectedIndex = index);
          $$invalidate(24, selectedIndex = index);
          $$invalidate(0, value = getMenuItemValues()[selectedIndex]);
        },
        focusMenuItemAtIndex: (index) => {
          list.focusItemAtIndex(index);
        },
        getMenuItemCount: () => list.items.length,
        getMenuItemValues: () => getMenuItemValues().map(key),
        getMenuItemTextAtIndex: (index) => list.getPrimaryTextAtIndex(index),
        isTypeaheadInProgress: () => list.typeaheadInProgress,
        typeaheadMatchItem: (nextChar, startingIndex) => list.typeaheadMatchItem(nextChar, startingIndex),
        // getCommonAdapterMethods
        addClass,
        removeClass,
        hasClass,
        setRippleCenter: (normalizedX) => lineRipple && lineRipple.setRippleCenter(normalizedX),
        activateBottomLine: () => lineRipple && lineRipple.activate(),
        deactivateBottomLine: () => lineRipple && lineRipple.deactivate(),
        notifyChange: (_selectedValue) => {
          $$invalidate(55, dirty = true);
          if (updateInvalid) {
            $$invalidate(1, invalid = !instance2.isValid());
          }
          dispatch(getElement(), "SMUISelect:change", { value, index: selectedIndex }, void 0, true);
        },
        // getOutlineAdapterMethods
        hasOutline: () => !!notchedOutline,
        notchOutline: (labelWidth) => notchedOutline && notchedOutline.notch(labelWidth),
        closeOutline: () => notchedOutline && notchedOutline.closeNotch(),
        // getLabelAdapterMethods
        hasLabel: () => !!floatingLabel,
        floatLabel: (shouldFloat) => floatingLabel && floatingLabel.float(shouldFloat),
        getLabelWidth: () => floatingLabel ? floatingLabel.getWidth() : 0,
        setLabelRequired: (isRequired) => floatingLabel && floatingLabel.setRequired(isRequired)
      },
      {
        get helperText() {
          return helperText;
        },
        get leadingIcon() {
          return leadingIcon;
        }
      }
    ));
    $$invalidate(24, selectedIndex = getMenuItemValues().indexOf(value));
    instance2.init();
    setUseDefaultValidation(useDefaultValidation);
    return () => {
      instance2.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function handleLeadingIconMount(event) {
    $$invalidate(37, leadingIcon = event.detail);
  }
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(26, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(26, internalClasses[className2] = false, internalClasses);
    }
  }
  function addStyle(name, value2) {
    if (internalStyles[name] != value2) {
      if (value2 === "" || value2 == null) {
        delete internalStyles[name];
        $$invalidate(27, internalStyles);
      } else {
        $$invalidate(27, internalStyles[name] = value2, internalStyles);
      }
    }
  }
  function addMenuClass(className2) {
    if (!menuClasses[className2]) {
      $$invalidate(32, menuClasses[className2] = true, menuClasses);
    }
  }
  function removeMenuClass(className2) {
    if (!(className2 in menuClasses) || menuClasses[className2]) {
      $$invalidate(32, menuClasses[className2] = false, menuClasses);
    }
  }
  function getSelectAnchorAttr(name) {
    var _a2;
    return name in selectAnchorAttrs ? (_a2 = selectAnchorAttrs[name]) !== null && _a2 !== void 0 ? _a2 : null : getElement().getAttribute(name);
  }
  function addSelectAnchorAttr(name, value2) {
    if (selectAnchorAttrs[name] !== value2) {
      $$invalidate(29, selectAnchorAttrs[name] = value2, selectAnchorAttrs);
    }
  }
  function removeSelectAnchorAttr(name) {
    if (!(name in selectAnchorAttrs) || selectAnchorAttrs[name] != null) {
      $$invalidate(29, selectAnchorAttrs[name] = void 0, selectAnchorAttrs);
    }
  }
  function getMenuItemValues() {
    return list.getOrderedList().map((accessor) => accessor.getValue());
  }
  function getUseDefaultValidation() {
    return instance2.getUseDefaultValidation();
  }
  function setUseDefaultValidation(useDefaultValidation2) {
    instance2.setUseDefaultValidation(useDefaultValidation2);
  }
  function focus() {
    selectAnchor.focus();
  }
  function layout() {
    instance2.layout();
  }
  function getElement() {
    return element2;
  }
  function focus_handler(event) {
    bubble.call(this, $$self, event);
  }
  function blur_handler(event) {
    bubble.call(this, $$self, event);
  }
  function floatinglabel_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      floatingLabel = $$value;
      $$invalidate(39, floatingLabel);
    });
  }
  function floatinglabel_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      floatingLabel = $$value;
      $$invalidate(39, floatingLabel);
    });
  }
  function notchedoutline_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      notchedOutline = $$value;
      $$invalidate(41, notchedOutline);
    });
  }
  function lineripple_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      lineRipple = $$value;
      $$invalidate(40, lineRipple);
    });
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      selectAnchor = $$value;
      $$invalidate(28, selectAnchor);
    });
  }
  const focus_handler_1 = () => instance2 && instance2.handleFocus();
  const blur_handler_1 = () => instance2 && instance2.handleBlur();
  const click_handler = (event) => {
    selectAnchor.focus();
    if (instance2) {
      instance2.handleClick(getNormalizedXCoordinate(event));
    }
  };
  function list_1_selectedIndex_binding(value2) {
    selectedIndex = value2;
    $$invalidate(24, selectedIndex);
  }
  const SMUIList_mount_handler = (event) => $$invalidate(36, list = event.detail);
  function menu_open_binding(value2) {
    menuOpen = value2;
    $$invalidate(31, menuOpen);
  }
  const SMUIMenu_selected_handler = (event) => instance2 && instance2.handleMenuItemAction(event.detail.index);
  const SMUIMenuSurface_closing_handler = () => instance2 && instance2.handleMenuClosing();
  const SMUIMenuSurface_closed_handler = () => instance2 && instance2.handleMenuClosed();
  const SMUIMenuSurface_opened_handler = () => instance2 && instance2.handleMenuOpened();
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(25, element2);
    });
  }
  const SMUISelectLeadingIcon_unmount_handler = () => $$invalidate(37, leadingIcon = void 0);
  const SMUISelectHelperText_id_handler = (event) => $$invalidate(30, helperId = event.detail);
  const SMUISelectHelperText_mount_handler = (event) => $$invalidate(38, helperText = event.detail);
  const SMUISelectHelperText_unmount_handler = () => {
    $$invalidate(30, helperId = void 0);
    $$invalidate(38, helperText = void 0);
  };
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(53, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(2, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(3, className = $$new_props.class);
    if ("style" in $$new_props)
      $$invalidate(4, style = $$new_props.style);
    if ("ripple" in $$new_props)
      $$invalidate(5, ripple = $$new_props.ripple);
    if ("disabled" in $$new_props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("variant" in $$new_props)
      $$invalidate(7, variant = $$new_props.variant);
    if ("noLabel" in $$new_props)
      $$invalidate(8, noLabel = $$new_props.noLabel);
    if ("label" in $$new_props)
      $$invalidate(9, label = $$new_props.label);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("key" in $$new_props)
      $$invalidate(56, key = $$new_props.key);
    if ("dirty" in $$new_props)
      $$invalidate(55, dirty = $$new_props.dirty);
    if ("invalid" in $$new_props)
      $$invalidate(1, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$new_props)
      $$invalidate(57, updateInvalid = $$new_props.updateInvalid);
    if ("required" in $$new_props)
      $$invalidate(10, required = $$new_props.required);
    if ("inputId" in $$new_props)
      $$invalidate(11, inputId = $$new_props.inputId);
    if ("hiddenInput" in $$new_props)
      $$invalidate(12, hiddenInput = $$new_props.hiddenInput);
    if ("withLeadingIcon" in $$new_props)
      $$invalidate(13, withLeadingIcon = $$new_props.withLeadingIcon);
    if ("anchor$use" in $$new_props)
      $$invalidate(14, anchor$use = $$new_props.anchor$use);
    if ("anchor$class" in $$new_props)
      $$invalidate(15, anchor$class = $$new_props.anchor$class);
    if ("selectedTextContainer$use" in $$new_props)
      $$invalidate(16, selectedTextContainer$use = $$new_props.selectedTextContainer$use);
    if ("selectedTextContainer$class" in $$new_props)
      $$invalidate(17, selectedTextContainer$class = $$new_props.selectedTextContainer$class);
    if ("selectedText$use" in $$new_props)
      $$invalidate(18, selectedText$use = $$new_props.selectedText$use);
    if ("selectedText$class" in $$new_props)
      $$invalidate(19, selectedText$class = $$new_props.selectedText$class);
    if ("dropdownIcon$use" in $$new_props)
      $$invalidate(20, dropdownIcon$use = $$new_props.dropdownIcon$use);
    if ("dropdownIcon$class" in $$new_props)
      $$invalidate(21, dropdownIcon$class = $$new_props.dropdownIcon$class);
    if ("menu$class" in $$new_props)
      $$invalidate(22, menu$class = $$new_props.menu$class);
    if ("$$scope" in $$new_props)
      $$invalidate(87, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    counter: counter2,
    _a,
    MDCSelectFoundation,
    onMount,
    onDestroy,
    getContext,
    setContext,
    writable,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    Ripple: dist_default,
    Anchor,
    Menu: dist_default4,
    List: dist_default2,
    FloatingLabel: dist_default5,
    LineRipple: dist_default6,
    NotchedOutline: dist_default7,
    HelperText: HelperText_default,
    forwardEvents,
    uninitializedValue,
    isUninitializedValue,
    use,
    className,
    style,
    ripple,
    disabled,
    variant,
    noLabel,
    label,
    value,
    key,
    dirty,
    invalid,
    updateInvalid,
    useDefaultValidation,
    required,
    inputId,
    hiddenInput,
    withLeadingIcon,
    anchor$use,
    anchor$class,
    selectedTextContainer$use,
    selectedTextContainer$class,
    selectedText$use,
    selectedText$class,
    dropdownIcon$use,
    dropdownIcon$class,
    menu$class,
    element: element2,
    instance: instance2,
    internalClasses,
    internalStyles,
    selectAnchor,
    selectAnchorAttrs,
    selectedIndex,
    menuId,
    helperId,
    addLayoutListener,
    removeLayoutListener,
    menuOpen,
    menuClasses,
    anchorElement,
    anchorCorner,
    wrapFocus,
    list,
    context,
    leadingIcon,
    helperText,
    floatingLabel,
    lineRipple,
    notchedOutline,
    selectedTextStore,
    valueStore,
    previousSelectedIndex,
    handleLeadingIconMount,
    hasClass,
    addClass,
    removeClass,
    addStyle,
    addMenuClass,
    removeMenuClass,
    getSelectAnchorAttr,
    addSelectAnchorAttr,
    removeSelectAnchorAttr,
    getMenuItemValues,
    getNormalizedXCoordinate,
    isTouchEvent,
    getUseDefaultValidation,
    setUseDefaultValidation,
    focus,
    layout,
    getElement,
    $selectedTextStore,
    $valueStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("_a" in $$props)
      _a = $$new_props._a;
    if ("uninitializedValue" in $$props)
      uninitializedValue = $$new_props.uninitializedValue;
    if ("use" in $$props)
      $$invalidate(2, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(3, className = $$new_props.className);
    if ("style" in $$props)
      $$invalidate(4, style = $$new_props.style);
    if ("ripple" in $$props)
      $$invalidate(5, ripple = $$new_props.ripple);
    if ("disabled" in $$props)
      $$invalidate(6, disabled = $$new_props.disabled);
    if ("variant" in $$props)
      $$invalidate(7, variant = $$new_props.variant);
    if ("noLabel" in $$props)
      $$invalidate(8, noLabel = $$new_props.noLabel);
    if ("label" in $$props)
      $$invalidate(9, label = $$new_props.label);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("key" in $$props)
      $$invalidate(56, key = $$new_props.key);
    if ("dirty" in $$props)
      $$invalidate(55, dirty = $$new_props.dirty);
    if ("invalid" in $$props)
      $$invalidate(1, invalid = $$new_props.invalid);
    if ("updateInvalid" in $$props)
      $$invalidate(57, updateInvalid = $$new_props.updateInvalid);
    if ("required" in $$props)
      $$invalidate(10, required = $$new_props.required);
    if ("inputId" in $$props)
      $$invalidate(11, inputId = $$new_props.inputId);
    if ("hiddenInput" in $$props)
      $$invalidate(12, hiddenInput = $$new_props.hiddenInput);
    if ("withLeadingIcon" in $$props)
      $$invalidate(13, withLeadingIcon = $$new_props.withLeadingIcon);
    if ("anchor$use" in $$props)
      $$invalidate(14, anchor$use = $$new_props.anchor$use);
    if ("anchor$class" in $$props)
      $$invalidate(15, anchor$class = $$new_props.anchor$class);
    if ("selectedTextContainer$use" in $$props)
      $$invalidate(16, selectedTextContainer$use = $$new_props.selectedTextContainer$use);
    if ("selectedTextContainer$class" in $$props)
      $$invalidate(17, selectedTextContainer$class = $$new_props.selectedTextContainer$class);
    if ("selectedText$use" in $$props)
      $$invalidate(18, selectedText$use = $$new_props.selectedText$use);
    if ("selectedText$class" in $$props)
      $$invalidate(19, selectedText$class = $$new_props.selectedText$class);
    if ("dropdownIcon$use" in $$props)
      $$invalidate(20, dropdownIcon$use = $$new_props.dropdownIcon$use);
    if ("dropdownIcon$class" in $$props)
      $$invalidate(21, dropdownIcon$class = $$new_props.dropdownIcon$class);
    if ("menu$class" in $$props)
      $$invalidate(22, menu$class = $$new_props.menu$class);
    if ("element" in $$props)
      $$invalidate(25, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(23, instance2 = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(26, internalClasses = $$new_props.internalClasses);
    if ("internalStyles" in $$props)
      $$invalidate(27, internalStyles = $$new_props.internalStyles);
    if ("selectAnchor" in $$props)
      $$invalidate(28, selectAnchor = $$new_props.selectAnchor);
    if ("selectAnchorAttrs" in $$props)
      $$invalidate(29, selectAnchorAttrs = $$new_props.selectAnchorAttrs);
    if ("selectedIndex" in $$props)
      $$invalidate(24, selectedIndex = $$new_props.selectedIndex);
    if ("menuId" in $$props)
      $$invalidate(45, menuId = $$new_props.menuId);
    if ("helperId" in $$props)
      $$invalidate(30, helperId = $$new_props.helperId);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("menuOpen" in $$props)
      $$invalidate(31, menuOpen = $$new_props.menuOpen);
    if ("menuClasses" in $$props)
      $$invalidate(32, menuClasses = $$new_props.menuClasses);
    if ("anchorElement" in $$props)
      $$invalidate(33, anchorElement = $$new_props.anchorElement);
    if ("anchorCorner" in $$props)
      $$invalidate(34, anchorCorner = $$new_props.anchorCorner);
    if ("wrapFocus" in $$props)
      $$invalidate(35, wrapFocus = $$new_props.wrapFocus);
    if ("list" in $$props)
      $$invalidate(36, list = $$new_props.list);
    if ("context" in $$props)
      $$invalidate(46, context = $$new_props.context);
    if ("leadingIcon" in $$props)
      $$invalidate(37, leadingIcon = $$new_props.leadingIcon);
    if ("helperText" in $$props)
      $$invalidate(38, helperText = $$new_props.helperText);
    if ("floatingLabel" in $$props)
      $$invalidate(39, floatingLabel = $$new_props.floatingLabel);
    if ("lineRipple" in $$props)
      $$invalidate(40, lineRipple = $$new_props.lineRipple);
    if ("notchedOutline" in $$props)
      $$invalidate(41, notchedOutline = $$new_props.notchedOutline);
    if ("previousSelectedIndex" in $$props)
      $$invalidate(63, previousSelectedIndex = $$new_props.previousSelectedIndex);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*selectedIndex, instance, value*/
    25165825 | $$self.$$.dirty[2] & /*previousSelectedIndex*/
    2) {
      $:
        if (previousSelectedIndex !== selectedIndex) {
          $$invalidate(63, previousSelectedIndex = selectedIndex);
          if (instance2) {
            instance2.setSelectedIndex(
              selectedIndex,
              /* closeMenu */
              false,
              /* skipNotify */
              true
            );
          } else {
            const values = getMenuItemValues();
            if (value !== values[selectedIndex]) {
              $$invalidate(0, value = values[selectedIndex]);
            }
          }
        }
    }
    if ($$self.$$.dirty[0] & /*value*/
    1) {
      $:
        set_store_value(valueStore, $valueStore = value, $valueStore);
    }
    if ($$self.$$.dirty[0] & /*instance, value*/
    8388609 | $$self.$$.dirty[1] & /*key*/
    33554432) {
      $:
        if (instance2 && instance2.getValue() !== key(value)) {
          instance2.setValue(key(value));
        }
    }
    if ($$self.$$.dirty[0] & /*instance, disabled*/
    8388672) {
      $:
        if (instance2 && instance2.getDisabled() !== disabled) {
          instance2.setDisabled(disabled);
        }
    }
    if ($$self.$$.dirty[0] & /*instance, invalid*/
    8388610 | $$self.$$.dirty[1] & /*dirty, updateInvalid*/
    83886080) {
      $:
        if (instance2 && dirty && instance2.isValid() !== !invalid) {
          if (updateInvalid) {
            $$invalidate(1, invalid = !instance2.isValid());
          } else {
            instance2.setValid(!invalid);
          }
        }
    }
    if ($$self.$$.dirty[0] & /*instance, required*/
    8389632) {
      $:
        if (instance2 && instance2.getRequired() !== required) {
          instance2.setRequired(required);
        }
    }
  };
  return [
    value,
    invalid,
    use,
    className,
    style,
    ripple,
    disabled,
    variant,
    noLabel,
    label,
    required,
    inputId,
    hiddenInput,
    withLeadingIcon,
    anchor$use,
    anchor$class,
    selectedTextContainer$use,
    selectedTextContainer$class,
    selectedText$use,
    selectedText$class,
    dropdownIcon$use,
    dropdownIcon$class,
    menu$class,
    instance2,
    selectedIndex,
    element2,
    internalClasses,
    internalStyles,
    selectAnchor,
    selectAnchorAttrs,
    helperId,
    menuOpen,
    menuClasses,
    anchorElement,
    anchorCorner,
    wrapFocus,
    list,
    leadingIcon,
    helperText,
    floatingLabel,
    lineRipple,
    notchedOutline,
    $selectedTextStore,
    forwardEvents,
    isUninitializedValue,
    menuId,
    context,
    selectedTextStore,
    valueStore,
    handleLeadingIconMount,
    addClass,
    removeClass,
    addStyle,
    $$restProps,
    $$slots,
    dirty,
    key,
    updateInvalid,
    getUseDefaultValidation,
    setUseDefaultValidation,
    focus,
    layout,
    getElement,
    previousSelectedIndex,
    slots,
    focus_handler,
    blur_handler,
    floatinglabel_binding,
    floatinglabel_binding_1,
    notchedoutline_binding,
    lineripple_binding,
    div0_binding,
    focus_handler_1,
    blur_handler_1,
    click_handler,
    list_1_selectedIndex_binding,
    SMUIList_mount_handler,
    menu_open_binding,
    SMUIMenu_selected_handler,
    SMUIMenuSurface_closing_handler,
    SMUIMenuSurface_closed_handler,
    SMUIMenuSurface_opened_handler,
    div1_binding,
    SMUISelectLeadingIcon_unmount_handler,
    SMUISelectHelperText_id_handler,
    SMUISelectHelperText_mount_handler,
    SMUISelectHelperText_unmount_handler,
    $$scope
  ];
}
var Select = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_17,
      create_fragment7,
      safe_not_equal,
      {
        use: 2,
        class: 3,
        style: 4,
        ripple: 5,
        disabled: 6,
        variant: 7,
        noLabel: 8,
        label: 9,
        value: 0,
        key: 56,
        dirty: 55,
        invalid: 1,
        updateInvalid: 57,
        required: 10,
        inputId: 11,
        hiddenInput: 12,
        withLeadingIcon: 13,
        anchor$use: 14,
        anchor$class: 15,
        selectedTextContainer$use: 16,
        selectedTextContainer$class: 17,
        selectedText$use: 18,
        selectedText$class: 19,
        dropdownIcon$use: 20,
        dropdownIcon$class: 21,
        menu$class: 22,
        getUseDefaultValidation: 58,
        setUseDefaultValidation: 59,
        focus: 60,
        layout: 61,
        getElement: 62
      },
      null,
      [-1, -1, -1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Select",
      options,
      id: create_fragment7.name
    });
  }
  get use() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get style() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set style(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get ripple() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set ripple(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get disabled() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set disabled(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get variant() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set variant(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get noLabel() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set noLabel(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get label() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set label(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dirty() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dirty(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get invalid() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set invalid(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get updateInvalid() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set updateInvalid(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get required() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set required(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get inputId() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set inputId(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get hiddenInput() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set hiddenInput(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get withLeadingIcon() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set withLeadingIcon(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor$use() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor$use(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get anchor$class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set anchor$class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedTextContainer$use() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedTextContainer$use(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedTextContainer$class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedTextContainer$class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedText$use() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedText$use(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get selectedText$class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set selectedText$class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdownIcon$use() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdownIcon$use(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get dropdownIcon$class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set dropdownIcon$class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get menu$class() {
    throw new Error("<Select>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set menu$class(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getUseDefaultValidation() {
    return this.$$.ctx[58];
  }
  set getUseDefaultValidation(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get setUseDefaultValidation() {
    return this.$$.ctx[59];
  }
  set setUseDefaultValidation(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focus() {
    return this.$$.ctx[60];
  }
  set focus(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[61];
  }
  set layout(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[62];
  }
  set getElement(value) {
    throw new Error("<Select>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Select_default = Select;

// node_modules/@smui/select/dist/Option.svelte
function create_default_slot3(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[13],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8192)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[13],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[13]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[13],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot3.name,
    type: "slot",
    source: "(1:0) <Item   bind:this={element}   use={usePass}   data-value={value}   {value}   {selected}   {...$$restProps}>",
    ctx
  });
  return block;
}
function create_fragment8(ctx) {
  let item;
  let current;
  const item_spread_levels = [
    { use: (
      /*usePass*/
      ctx[3]
    ) },
    { "data-value": (
      /*value*/
      ctx[0]
    ) },
    { value: (
      /*value*/
      ctx[0]
    ) },
    { selected: (
      /*selected*/
      ctx[2]
    ) },
    /*$$restProps*/
    ctx[6]
  ];
  let item_props = {
    $$slots: { default: [create_default_slot3] },
    $$scope: { ctx }
  };
  for (let i = 0; i < item_spread_levels.length; i += 1) {
    item_props = assign(item_props, item_spread_levels[i]);
  }
  item = new Item_default({ props: item_props, $$inline: true });
  ctx[12](item);
  const block = {
    c: function create() {
      create_component(item.$$.fragment);
    },
    l: function claim(nodes) {
      claim_component(item.$$.fragment, nodes);
    },
    m: function mount(target, anchor) {
      mount_component(item, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const item_changes = dirty & /*usePass, value, selected, $$restProps*/
      77 ? get_spread_update(item_spread_levels, [
        dirty & /*usePass*/
        8 && { use: (
          /*usePass*/
          ctx2[3]
        ) },
        dirty & /*value*/
        1 && { "data-value": (
          /*value*/
          ctx2[0]
        ) },
        dirty & /*value*/
        1 && { value: (
          /*value*/
          ctx2[0]
        ) },
        dirty & /*selected*/
        4 && { selected: (
          /*selected*/
          ctx2[2]
        ) },
        dirty & /*$$restProps*/
        64 && get_spread_object(
          /*$$restProps*/
          ctx2[6]
        )
      ]) : {};
      if (dirty & /*$$scope*/
      8192) {
        item_changes.$$scope = { dirty, ctx: ctx2 };
      }
      item.$set(item_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(item.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      ctx[12](null);
      destroy_component(item, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment8.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let usePass;
  let selected;
  const omit_props_names = ["use", "class", "value", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $selectedText;
  let $selectedValue;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Option", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  const className = "";
  let { value = "" } = $$props;
  let element2;
  const selectedText = getContext("SMUI:select:selectedText");
  validate_store(selectedText, "selectedText");
  component_subscribe($$self, selectedText, (value2) => $$invalidate(14, $selectedText = value2));
  const selectedValue = getContext("SMUI:select:value");
  validate_store(selectedValue, "selectedValue");
  component_subscribe($$self, selectedValue, (value2) => $$invalidate(10, $selectedValue = value2));
  setContext("SMUI:list:item:role", "option");
  onMount(setSelectedText);
  onDestroy(setSelectedText);
  function setSelectedText() {
    if (selected && element2) {
      set_store_value(selectedText, $selectedText = element2.getPrimaryText(), $selectedText);
    }
  }
  function getElement() {
    return element2.getElement();
  }
  function item_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(7, use = $$new_props.use);
    if ("value" in $$new_props)
      $$invalidate(0, value = $$new_props.value);
    if ("$$scope" in $$new_props)
      $$invalidate(13, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    onDestroy,
    getContext,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    Item: Item_default,
    forwardEvents,
    use,
    className,
    value,
    element: element2,
    selectedText,
    selectedValue,
    setSelectedText,
    getElement,
    selected,
    usePass,
    $selectedText,
    $selectedValue
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(7, use = $$new_props.use);
    if ("value" in $$props)
      $$invalidate(0, value = $$new_props.value);
    if ("element" in $$props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("selected" in $$props)
      $$invalidate(2, selected = $$new_props.selected);
    if ("usePass" in $$props)
      $$invalidate(3, usePass = $$new_props.usePass);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*use*/
    128) {
      $:
        $$invalidate(3, usePass = [forwardEvents, ...use]);
    }
    if ($$self.$$.dirty & /*value, $selectedValue*/
    1025) {
      $:
        $$invalidate(2, selected = value != null && value !== "" && $selectedValue === value);
    }
  };
  return [
    value,
    element2,
    selected,
    usePass,
    selectedText,
    selectedValue,
    $$restProps,
    use,
    className,
    getElement,
    $selectedValue,
    slots,
    item_binding,
    $$scope
  ];
}
var Option = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment8, safe_not_equal, {
      use: 7,
      class: 8,
      value: 0,
      getElement: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Option",
      options,
      id: create_fragment8.name
    });
  }
  get use() {
    throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    return this.$$.ctx[8];
  }
  set class(value) {
    throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get value() {
    throw new Error("<Option>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set value(value) {
    throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[9];
  }
  set getElement(value) {
    throw new Error("<Option>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Option_default = Option;

// node_modules/@smui/select/dist/index.js
var dist_default8 = Select_default;
export {
  DefaultFocusState,
  Option_default as Option,
  dist_default8 as default
};
/*! Bundled license information:

@material/select/adapter.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/floating-label/constants.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/floating-label/foundation.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/floating-label/component.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/line-ripple/constants.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/line-ripple/foundation.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/line-ripple/component.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu-surface/constants.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu-surface/foundation.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu-surface/component.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu/constants.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu/foundation.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu/component.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/notched-outline/constants.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/notched-outline/foundation.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/notched-outline/component.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/constants.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/foundation.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/helper-text/constants.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/helper-text/foundation.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/helper-text/component.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/icon/constants.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/icon/foundation.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/icon/component.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/component.js:
  (**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/types.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/helper-text/adapter.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/helper-text/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/icon/adapter.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/icon/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/select/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu-surface/adapter.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu-surface/types.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu-surface/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu/adapter.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu/types.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/menu/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/floating-label/adapter.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/floating-label/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/line-ripple/adapter.js:
  (**
   * @license
   * Copyright 2018 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/line-ripple/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/notched-outline/adapter.js:
  (**
   * @license
   * Copyright 2017 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)

@material/notched-outline/index.js:
  (**
   * @license
   * Copyright 2019 Google Inc.
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in
   * all copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
   * THE SOFTWARE.
   *)
*/
//# sourceMappingURL=@smui_select.js.map
