import {
  MDCTabBarFoundation
} from "./chunk-IJLKUFYW.js";
import "./chunk-HVADMH5W.js";
import {
  MDCTabScrollerFoundation,
  util_exports
} from "./chunk-D25CXERY.js";
import "./chunk-RE7Q5LHZ.js";
import "./chunk-AXHAKLPO.js";
import "./chunk-W4OU4FMO.js";
import "./chunk-Y3XZ6UIT.js";
import "./chunk-7EMQ2XW3.js";
import "./chunk-HIFDM6WQ.js";
import "./chunk-OYKM6SV3.js";
import "./chunk-ZJSI6DXQ.js";
import "./chunk-2YJBFMWA.js";
import {
  ponyfill_exports
} from "./chunk-RJY55RCX.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-GGS237SP.js";
import "./chunk-X7HCJ7ZS.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  assign,
  binding_callbacks,
  check_outros,
  children,
  claim_component,
  claim_element,
  compute_rest_props,
  create_component,
  create_slot,
  destroy_component,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  ensure_array_like_dev,
  exclude_internal_props,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_object,
  get_spread_update,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  mount_component,
  onMount,
  outro_and_destroy_block,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  transition_in,
  transition_out,
  update_keyed_each,
  update_slot_base,
  validate_each_keys,
  validate_slots
} from "./chunk-NMMN3PC6.js";
import "./chunk-ZB6PEJPW.js";
import "./chunk-4DGM7FRE.js";
import "./chunk-7U33LM2Z.js";

// node_modules/@smui/tab-scroller/dist/TabScroller.svelte
var file = "node_modules/@smui/tab-scroller/dist/TabScroller.svelte";
function create_fragment(ctx) {
  let div2;
  let div1;
  let div0;
  let div0_class_value;
  let div0_style_value;
  let useActions_action;
  let div1_class_value;
  let div1_style_value;
  let useActions_action_1;
  let div2_class_value;
  let useActions_action_2;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[23].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[22],
    null
  );
  let div0_levels = [
    {
      class: div0_class_value = classMap({
        [
          /*scrollContent$class*/
          ctx[6]
        ]: true,
        "mdc-tab-scroller__scroll-content": true
      })
    },
    {
      style: div0_style_value = Object.entries(
        /*scrollContentStyles*/
        ctx[14]
      ).map(func).join(" ")
    },
    prefixFilter(
      /*$$restProps*/
      ctx[16],
      "scrollContent$"
    )
  ];
  let div_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data = assign(div_data, div0_levels[i]);
  }
  let div1_levels = [
    {
      class: div1_class_value = classMap({
        [
          /*scrollArea$class*/
          ctx[4]
        ]: true,
        "mdc-tab-scroller__scroll-area": true,
        .../*scrollAreaClasses*/
        ctx[12]
      })
    },
    {
      style: div1_style_value = Object.entries(
        /*scrollAreaStyles*/
        ctx[13]
      ).map(func_1).join(" ")
    },
    prefixFilter(
      /*$$restProps*/
      ctx[16],
      "scrollArea$"
    )
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  let div2_levels = [
    {
      class: div2_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-tab-scroller": true,
        "mdc-tab-scroller--align-start": (
          /*align*/
          ctx[2] === "start"
        ),
        "mdc-tab-scroller--align-end": (
          /*align*/
          ctx[2] === "end"
        ),
        "mdc-tab-scroller--align-center": (
          /*align*/
          ctx[2] === "center"
        ),
        .../*internalClasses*/
        ctx[11]
      })
    },
    exclude(
      /*$$restProps*/
      ctx[16],
      ["scrollArea$", "scrollContent$"]
    )
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true, style: true });
      var div0_nodes = children(div0);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div0, div_data);
      add_location(div0, file, 32, 4, 1108);
      set_attributes(div1, div_data_1);
      add_location(div1, file, 14, 2, 406);
      set_attributes(div2, div_data_2);
      add_location(div2, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      append_hydration_dev(div1, div0);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[24](div0);
      ctx[26](div1);
      ctx[32](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div0,
            /*scrollContent$use*/
            ctx[5]
          )),
          listen_dev(
            div0,
            "transitionend",
            /*transitionend_handler*/
            ctx[25],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action_1 = useActions.call(
            null,
            div1,
            /*scrollArea$use*/
            ctx[3]
          )),
          listen_dev(
            div1,
            "wheel",
            /*wheel_handler*/
            ctx[27],
            { passive: true },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "touchstart",
            /*touchstart_handler*/
            ctx[28],
            { passive: true },
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "pointerdown",
            /*pointerdown_handler*/
            ctx[29],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "mousedown",
            /*mousedown_handler*/
            ctx[30],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "keydown",
            /*keydown_handler*/
            ctx[31],
            false,
            false,
            false,
            false
          ),
          action_destroyer(useActions_action_2 = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[15].call(null, div2))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope*/
        4194304)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[22],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[22]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[22],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div0, div_data = get_spread_update(div0_levels, [
        (!current || dirty[0] & /*scrollContent$class*/
        64 && div0_class_value !== (div0_class_value = classMap({
          [
            /*scrollContent$class*/
            ctx2[6]
          ]: true,
          "mdc-tab-scroller__scroll-content": true
        }))) && { class: div0_class_value },
        (!current || dirty[0] & /*scrollContentStyles*/
        16384 && div0_style_value !== (div0_style_value = Object.entries(
          /*scrollContentStyles*/
          ctx2[14]
        ).map(func).join(" "))) && { style: div0_style_value },
        dirty[0] & /*$$restProps*/
        65536 && prefixFilter(
          /*$$restProps*/
          ctx2[16],
          "scrollContent$"
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*scrollContent$use*/
      32)
        useActions_action.update.call(
          null,
          /*scrollContent$use*/
          ctx2[5]
        );
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*scrollArea$class, scrollAreaClasses*/
        4112 && div1_class_value !== (div1_class_value = classMap({
          [
            /*scrollArea$class*/
            ctx2[4]
          ]: true,
          "mdc-tab-scroller__scroll-area": true,
          .../*scrollAreaClasses*/
          ctx2[12]
        }))) && { class: div1_class_value },
        (!current || dirty[0] & /*scrollAreaStyles*/
        8192 && div1_style_value !== (div1_style_value = Object.entries(
          /*scrollAreaStyles*/
          ctx2[13]
        ).map(func_1).join(" "))) && { style: div1_style_value },
        dirty[0] & /*$$restProps*/
        65536 && prefixFilter(
          /*$$restProps*/
          ctx2[16],
          "scrollArea$"
        )
      ]));
      if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & /*scrollArea$use*/
      8)
        useActions_action_1.update.call(
          null,
          /*scrollArea$use*/
          ctx2[3]
        );
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        (!current || dirty[0] & /*className, align, internalClasses*/
        2054 && div2_class_value !== (div2_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-tab-scroller": true,
          "mdc-tab-scroller--align-start": (
            /*align*/
            ctx2[2] === "start"
          ),
          "mdc-tab-scroller--align-end": (
            /*align*/
            ctx2[2] === "end"
          ),
          "mdc-tab-scroller--align-center": (
            /*align*/
            ctx2[2] === "center"
          ),
          .../*internalClasses*/
          ctx2[11]
        }))) && { class: div2_class_value },
        dirty[0] & /*$$restProps*/
        65536 && exclude(
          /*$$restProps*/
          ctx2[16],
          ["scrollArea$", "scrollContent$"]
        )
      ]));
      if (useActions_action_2 && is_function(useActions_action_2.update) && dirty[0] & /*use*/
      1)
        useActions_action_2.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[24](null);
      ctx[26](null);
      ctx[32](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
var func_1 = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "align",
    "scrollArea$use",
    "scrollArea$class",
    "scrollContent$use",
    "scrollContent$class",
    "getScrollPosition",
    "getScrollContentWidth",
    "incrementScroll",
    "scrollTo",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabScroller", slots, ["default"]);
  const { matches } = ponyfill_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { align = void 0 } = $$props;
  let { scrollArea$use = [] } = $$props;
  let { scrollArea$class = "" } = $$props;
  let { scrollContent$use = [] } = $$props;
  let { scrollContent$class = "" } = $$props;
  let element2;
  let instance;
  let scrollArea;
  let scrollContent;
  let internalClasses = {};
  let scrollAreaClasses = {};
  let scrollAreaStyles = {};
  let scrollContentStyles = {};
  onMount(() => {
    $$invalidate(8, instance = new MDCTabScrollerFoundation({
      eventTargetMatchesSelector: (evtTarget, selector) => matches(evtTarget, selector),
      addClass,
      removeClass,
      addScrollAreaClass,
      setScrollAreaStyleProperty: addScrollAreaStyle,
      setScrollContentStyleProperty: addScrollContentStyle,
      getScrollContentStyleValue: getScrollContentStyle,
      setScrollAreaScrollLeft: (scrollX) => $$invalidate(9, scrollArea.scrollLeft = scrollX, scrollArea),
      getScrollAreaScrollLeft: () => scrollArea.scrollLeft,
      getScrollContentOffsetWidth: () => scrollContent.offsetWidth,
      getScrollAreaOffsetWidth: () => scrollArea.offsetWidth,
      computeScrollAreaClientRect: () => scrollArea.getBoundingClientRect(),
      computeScrollContentClientRect: () => scrollContent.getBoundingClientRect(),
      computeHorizontalScrollbarHeight: () => util_exports.computeHorizontalScrollbarHeight(document)
    }));
    instance.init();
    return () => {
      instance.destroy();
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(11, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(11, internalClasses[className2] = false, internalClasses);
    }
  }
  function addScrollAreaClass(className2) {
    if (!scrollAreaClasses[className2]) {
      $$invalidate(12, scrollAreaClasses[className2] = true, scrollAreaClasses);
    }
  }
  function addScrollAreaStyle(name, value) {
    if (scrollAreaStyles[name] != value) {
      if (value === "" || value == null) {
        delete scrollAreaStyles[name];
        $$invalidate(13, scrollAreaStyles);
      } else {
        $$invalidate(13, scrollAreaStyles[name] = value, scrollAreaStyles);
      }
    }
  }
  function addScrollContentStyle(name, value) {
    if (scrollContentStyles[name] != value) {
      if (value === "" || value == null) {
        delete scrollContentStyles[name];
        $$invalidate(14, scrollContentStyles);
      } else {
        $$invalidate(14, scrollContentStyles[name] = value, scrollContentStyles);
      }
    }
  }
  function getScrollContentStyle(name) {
    return name in scrollContentStyles ? scrollContentStyles[name] : getComputedStyle(scrollContent).getPropertyValue(name);
  }
  function getScrollPosition() {
    return instance.getScrollPosition();
  }
  function getScrollContentWidth() {
    return scrollContent.offsetWidth;
  }
  function incrementScroll(scrollXIncrement) {
    instance.incrementScroll(scrollXIncrement);
  }
  function scrollTo(scrollX) {
    instance.scrollTo(scrollX);
  }
  function getElement() {
    return element2;
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollContent = $$value;
      $$invalidate(10, scrollContent);
    });
  }
  const transitionend_handler = (event) => instance && instance.handleTransitionEnd(event);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollArea = $$value;
      $$invalidate(9, scrollArea);
    });
  }
  const wheel_handler = () => instance && instance.handleInteraction();
  const touchstart_handler = () => instance && instance.handleInteraction();
  const pointerdown_handler = () => instance && instance.handleInteraction();
  const mousedown_handler = () => instance && instance.handleInteraction();
  const keydown_handler = () => instance && instance.handleInteraction();
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(7, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(16, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("align" in $$new_props)
      $$invalidate(2, align = $$new_props.align);
    if ("scrollArea$use" in $$new_props)
      $$invalidate(3, scrollArea$use = $$new_props.scrollArea$use);
    if ("scrollArea$class" in $$new_props)
      $$invalidate(4, scrollArea$class = $$new_props.scrollArea$class);
    if ("scrollContent$use" in $$new_props)
      $$invalidate(5, scrollContent$use = $$new_props.scrollContent$use);
    if ("scrollContent$class" in $$new_props)
      $$invalidate(6, scrollContent$class = $$new_props.scrollContent$class);
    if ("$$scope" in $$new_props)
      $$invalidate(22, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCTabScrollerFoundation,
    util: util_exports,
    ponyfill: ponyfill_exports,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    matches,
    forwardEvents,
    use,
    className,
    align,
    scrollArea$use,
    scrollArea$class,
    scrollContent$use,
    scrollContent$class,
    element: element2,
    instance,
    scrollArea,
    scrollContent,
    internalClasses,
    scrollAreaClasses,
    scrollAreaStyles,
    scrollContentStyles,
    addClass,
    removeClass,
    addScrollAreaClass,
    addScrollAreaStyle,
    addScrollContentStyle,
    getScrollContentStyle,
    getScrollPosition,
    getScrollContentWidth,
    incrementScroll,
    scrollTo,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("align" in $$props)
      $$invalidate(2, align = $$new_props.align);
    if ("scrollArea$use" in $$props)
      $$invalidate(3, scrollArea$use = $$new_props.scrollArea$use);
    if ("scrollArea$class" in $$props)
      $$invalidate(4, scrollArea$class = $$new_props.scrollArea$class);
    if ("scrollContent$use" in $$props)
      $$invalidate(5, scrollContent$use = $$new_props.scrollContent$use);
    if ("scrollContent$class" in $$props)
      $$invalidate(6, scrollContent$class = $$new_props.scrollContent$class);
    if ("element" in $$props)
      $$invalidate(7, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(8, instance = $$new_props.instance);
    if ("scrollArea" in $$props)
      $$invalidate(9, scrollArea = $$new_props.scrollArea);
    if ("scrollContent" in $$props)
      $$invalidate(10, scrollContent = $$new_props.scrollContent);
    if ("internalClasses" in $$props)
      $$invalidate(11, internalClasses = $$new_props.internalClasses);
    if ("scrollAreaClasses" in $$props)
      $$invalidate(12, scrollAreaClasses = $$new_props.scrollAreaClasses);
    if ("scrollAreaStyles" in $$props)
      $$invalidate(13, scrollAreaStyles = $$new_props.scrollAreaStyles);
    if ("scrollContentStyles" in $$props)
      $$invalidate(14, scrollContentStyles = $$new_props.scrollContentStyles);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    align,
    scrollArea$use,
    scrollArea$class,
    scrollContent$use,
    scrollContent$class,
    element2,
    instance,
    scrollArea,
    scrollContent,
    internalClasses,
    scrollAreaClasses,
    scrollAreaStyles,
    scrollContentStyles,
    forwardEvents,
    $$restProps,
    getScrollPosition,
    getScrollContentWidth,
    incrementScroll,
    scrollTo,
    getElement,
    $$scope,
    slots,
    div0_binding,
    transitionend_handler,
    div1_binding,
    wheel_handler,
    touchstart_handler,
    pointerdown_handler,
    mousedown_handler,
    keydown_handler,
    div2_binding
  ];
}
var TabScroller = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        align: 2,
        scrollArea$use: 3,
        scrollArea$class: 4,
        scrollContent$use: 5,
        scrollContent$class: 6,
        getScrollPosition: 17,
        getScrollContentWidth: 18,
        incrementScroll: 19,
        scrollTo: 20,
        getElement: 21
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabScroller",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get align() {
    throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set align(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollArea$use() {
    throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollArea$use(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollArea$class() {
    throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollArea$class(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollContent$use() {
    throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollContent$use(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollContent$class() {
    throw new Error("<TabScroller>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set scrollContent$class(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getScrollPosition() {
    return this.$$.ctx[17];
  }
  set getScrollPosition(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getScrollContentWidth() {
    return this.$$.ctx[18];
  }
  set getScrollContentWidth(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get incrementScroll() {
    return this.$$.ctx[19];
  }
  set incrementScroll(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollTo() {
    return this.$$.ctx[20];
  }
  set scrollTo(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[21];
  }
  set getElement(value) {
    throw new Error("<TabScroller>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabScroller_default = TabScroller;

// node_modules/@smui/tab-scroller/dist/index.js
var dist_default = TabScroller_default;

// node_modules/@smui/tab-bar/dist/TabBar.svelte
var file2 = "node_modules/@smui/tab-bar/dist/TabBar.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[29] = list[i];
  return child_ctx;
}
var get_default_slot_changes = (dirty) => ({ tab: dirty[0] & /*tabs*/
4 });
var get_default_slot_context = (ctx) => ({ tab: (
  /*tab*/
  ctx[29]
) });
function create_each_block(key_2, ctx) {
  let first;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[21].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[24],
    get_default_slot_context
  );
  const block = {
    key: key_2,
    first: null,
    c: function create() {
      first = empty();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      first = empty();
      if (default_slot)
        default_slot.l(nodes);
      this.h();
    },
    h: function hydrate() {
      this.first = first;
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, first, anchor);
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty[0] & /*$$scope, tabs*/
        16777220)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[24],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[24]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[24],
              dirty,
              get_default_slot_changes
            ),
            get_default_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(first);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(22:4) {#each tabs as tab (key(tab))}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like_dev(
    /*tabs*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*key*/
    ctx2[3](
      /*tab*/
      ctx2[29]
    )
  );
  validate_each_keys(ctx, each_value, get_each_context, get_key);
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }
  const block = {
    c: function create() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    l: function claim(nodes) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(nodes);
      }
      each_1_anchor = empty();
    },
    m: function mount(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert_hydration_dev(target, each_1_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty[0] & /*$$scope, tabs, key*/
      16777228) {
        each_value = ensure_array_like_dev(
          /*tabs*/
          ctx2[2]
        );
        group_outros();
        validate_each_keys(ctx2, each_value, get_each_context, get_key);
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i: function intro(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(each_1_anchor);
      }
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d(detaching);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(18:2) <TabScroller     bind:this={tabScroller}     {...prefixFilter($$restProps, 'tabScroller$')}   >",
    ctx
  });
  return block;
}
function create_fragment2(ctx) {
  let div;
  let tabscroller;
  let div_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const tabscroller_spread_levels = [prefixFilter(
    /*$$restProps*/
    ctx[11],
    "tabScroller$"
  )];
  let tabscroller_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  for (let i = 0; i < tabscroller_spread_levels.length; i += 1) {
    tabscroller_props = assign(tabscroller_props, tabscroller_spread_levels[i]);
  }
  tabscroller = new dist_default({ props: tabscroller_props, $$inline: true });
  ctx[22](tabscroller);
  let div_levels = [
    {
      class: div_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-tab-bar": true
      })
    },
    { role: "tablist" },
    { tabindex: (
      /*tabindex*/
      ctx[4]
    ) },
    exclude(
      /*$$restProps*/
      ctx[11],
      ["tabScroller$"]
    )
  ];
  let div_data = {};
  for (let i = 0; i < div_levels.length; i += 1) {
    div_data = assign(div_data, div_levels[i]);
  }
  const block = {
    c: function create() {
      div = element("div");
      create_component(tabscroller.$$.fragment);
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true, role: true, tabindex: true });
      var div_nodes = children(div);
      claim_component(tabscroller.$$.fragment, div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(div, div_data);
      add_location(div, file2, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      mount_component(tabscroller, div, null);
      ctx[23](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[8].call(null, div)),
          listen_dev(
            div,
            "SMUITab:mount",
            /*handleTabMount*/
            ctx[9],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUITab:unmount",
            /*handleTabUnmount*/
            ctx[10],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "SMUITab:interacted",
            function() {
              if (is_function(
                /*instance*/
                ctx[5] && /*instance*/
                ctx[5].handleTabInteraction.bind(
                  /*instance*/
                  ctx[5]
                )
              ))
                /*instance*/
                (ctx[5] && /*instance*/
                ctx[5].handleTabInteraction.bind(
                  /*instance*/
                  ctx[5]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div,
            "keydown",
            function() {
              if (is_function(
                /*instance*/
                ctx[5] && /*instance*/
                ctx[5].handleKeyDown.bind(
                  /*instance*/
                  ctx[5]
                )
              ))
                /*instance*/
                (ctx[5] && /*instance*/
                ctx[5].handleKeyDown.bind(
                  /*instance*/
                  ctx[5]
                )).apply(this, arguments);
            },
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(new_ctx, dirty) {
      ctx = new_ctx;
      const tabscroller_changes = dirty[0] & /*$$restProps*/
      2048 ? get_spread_update(tabscroller_spread_levels, [get_spread_object(prefixFilter(
        /*$$restProps*/
        ctx[11],
        "tabScroller$"
      ))]) : {};
      if (dirty[0] & /*$$scope, tabs*/
      16777220) {
        tabscroller_changes.$$scope = { dirty, ctx };
      }
      tabscroller.$set(tabscroller_changes);
      set_attributes(div, div_data = get_spread_update(div_levels, [
        (!current || dirty[0] & /*className*/
        2 && div_class_value !== (div_class_value = classMap({
          [
            /*className*/
            ctx[1]
          ]: true,
          "mdc-tab-bar": true
        }))) && { class: div_class_value },
        { role: "tablist" },
        (!current || dirty[0] & /*tabindex*/
        16) && { tabindex: (
          /*tabindex*/
          ctx[4]
        ) },
        dirty[0] & /*$$restProps*/
        2048 && exclude(
          /*$$restProps*/
          ctx[11],
          ["tabScroller$"]
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(tabscroller.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(tabscroller.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      ctx[22](null);
      destroy_component(tabscroller);
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_12($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "tabs",
    "key",
    "focusOnActivate",
    "focusOnProgrammatic",
    "useAutomaticActivation",
    "active",
    "tabindex",
    "scrollIntoView",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("TabBar", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { tabs = [] } = $$props;
  let { key = (tab) => tab } = $$props;
  let { focusOnActivate = true } = $$props;
  let { focusOnProgrammatic = false } = $$props;
  let { useAutomaticActivation = true } = $$props;
  let { active = void 0 } = $$props;
  let { tabindex = 0 } = $$props;
  let element2;
  let instance;
  let tabScroller;
  let activeIndex = tabs.indexOf(active);
  let tabAccessorMap = {};
  let tabAccessorWeakMap = /* @__PURE__ */ new WeakMap();
  let skipFocus = false;
  setContext("SMUI:tab:focusOnActivate", focusOnActivate);
  setContext("SMUI:tab:initialActive", active);
  onMount(() => {
    $$invalidate(5, instance = new MDCTabBarFoundation({
      scrollTo: (scrollX) => tabScroller.scrollTo(scrollX),
      incrementScroll: (scrollXIncrement) => tabScroller.incrementScroll(scrollXIncrement),
      getScrollPosition: () => tabScroller.getScrollPosition(),
      getScrollContentWidth: () => tabScroller.getScrollContentWidth(),
      getOffsetWidth: () => getElement().offsetWidth,
      isRTL: () => getComputedStyle(getElement()).getPropertyValue("direction") === "rtl",
      setActiveTab: (index) => {
        $$invalidate(12, active = tabs[index]);
        $$invalidate(18, activeIndex = index);
        instance.activateTab(index);
      },
      activateTabAtIndex: (index, clientRect) => {
        var _a;
        return (_a = getAccessor(tabs[index])) === null || _a === void 0 ? void 0 : _a.activate(clientRect, skipFocus);
      },
      deactivateTabAtIndex: (index) => {
        var _a;
        return (_a = getAccessor(tabs[index])) === null || _a === void 0 ? void 0 : _a.deactivate();
      },
      focusTabAtIndex: (index) => {
        var _a;
        return (_a = getAccessor(tabs[index])) === null || _a === void 0 ? void 0 : _a.focus();
      },
      getTabIndicatorClientRectAtIndex: (index) => {
        var _a, _b;
        return (_b = (_a = getAccessor(tabs[index])) === null || _a === void 0 ? void 0 : _a.computeIndicatorClientRect()) !== null && _b !== void 0 ? _b : new DOMRect();
      },
      getTabDimensionsAtIndex: (index) => {
        var _a, _b;
        return (_b = (_a = getAccessor(tabs[index])) === null || _a === void 0 ? void 0 : _a.computeDimensions()) !== null && _b !== void 0 ? _b : {
          rootLeft: 0,
          rootRight: 0,
          contentLeft: 0,
          contentRight: 0
        };
      },
      getPreviousActiveTabIndex: () => {
        var _a;
        for (let i = 0; i < tabs.length; i++) {
          if ((_a = getAccessor(tabs[i])) === null || _a === void 0 ? void 0 : _a.active) {
            return i;
          }
        }
        return -1;
      },
      getFocusedTabIndex: () => {
        const tabElements = tabs.map((tab) => {
          var _a;
          return (_a = getAccessor(tab)) === null || _a === void 0 ? void 0 : _a.element;
        });
        const activeElement = document.activeElement;
        return tabElements.indexOf(activeElement);
      },
      getIndexOfTabById: (id) => tabs.indexOf(id),
      getTabListLength: () => tabs.length,
      notifyTabActivated: (index) => dispatch(getElement(), "SMUITabBar:activated", { index }, void 0, true)
    }));
    instance.init();
    return () => {
      instance.destroy();
    };
  });
  function handleTabMount(event) {
    const accessor = event.detail;
    addAccessor(accessor.tabId, accessor);
  }
  function handleTabUnmount(event) {
    const accessor = event.detail;
    removeAccessor(accessor.tabId);
  }
  function getAccessor(tabId) {
    return tabId instanceof Object ? tabAccessorWeakMap.get(tabId) : tabAccessorMap[tabId];
  }
  function addAccessor(tabId, accessor) {
    if (tabId instanceof Object) {
      tabAccessorWeakMap.set(tabId, accessor);
      $$invalidate(20, tabAccessorWeakMap);
    } else {
      $$invalidate(19, tabAccessorMap[tabId] = accessor, tabAccessorMap);
      $$invalidate(19, tabAccessorMap);
    }
  }
  function removeAccessor(tabId) {
    if (tabId instanceof Object) {
      tabAccessorWeakMap.delete(tabId);
      $$invalidate(20, tabAccessorWeakMap);
    } else {
      delete tabAccessorMap[tabId];
      $$invalidate(19, tabAccessorMap);
    }
  }
  function scrollIntoView(index) {
    instance.scrollIntoView(index);
  }
  function getElement() {
    return element2;
  }
  function tabscroller_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      tabScroller = $$value;
      $$invalidate(7, tabScroller);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(6, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("tabs" in $$new_props)
      $$invalidate(2, tabs = $$new_props.tabs);
    if ("key" in $$new_props)
      $$invalidate(3, key = $$new_props.key);
    if ("focusOnActivate" in $$new_props)
      $$invalidate(13, focusOnActivate = $$new_props.focusOnActivate);
    if ("focusOnProgrammatic" in $$new_props)
      $$invalidate(14, focusOnProgrammatic = $$new_props.focusOnProgrammatic);
    if ("useAutomaticActivation" in $$new_props)
      $$invalidate(15, useAutomaticActivation = $$new_props.useAutomaticActivation);
    if ("active" in $$new_props)
      $$invalidate(12, active = $$new_props.active);
    if ("tabindex" in $$new_props)
      $$invalidate(4, tabindex = $$new_props.tabindex);
    if ("$$scope" in $$new_props)
      $$invalidate(24, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCTabBarFoundation,
    onMount,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    TabScroller: dist_default,
    forwardEvents,
    use,
    className,
    tabs,
    key,
    focusOnActivate,
    focusOnProgrammatic,
    useAutomaticActivation,
    active,
    tabindex,
    element: element2,
    instance,
    tabScroller,
    activeIndex,
    tabAccessorMap,
    tabAccessorWeakMap,
    skipFocus,
    handleTabMount,
    handleTabUnmount,
    getAccessor,
    addAccessor,
    removeAccessor,
    scrollIntoView,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("tabs" in $$props)
      $$invalidate(2, tabs = $$new_props.tabs);
    if ("key" in $$props)
      $$invalidate(3, key = $$new_props.key);
    if ("focusOnActivate" in $$props)
      $$invalidate(13, focusOnActivate = $$new_props.focusOnActivate);
    if ("focusOnProgrammatic" in $$props)
      $$invalidate(14, focusOnProgrammatic = $$new_props.focusOnProgrammatic);
    if ("useAutomaticActivation" in $$props)
      $$invalidate(15, useAutomaticActivation = $$new_props.useAutomaticActivation);
    if ("active" in $$props)
      $$invalidate(12, active = $$new_props.active);
    if ("tabindex" in $$props)
      $$invalidate(4, tabindex = $$new_props.tabindex);
    if ("element" in $$props)
      $$invalidate(6, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(5, instance = $$new_props.instance);
    if ("tabScroller" in $$props)
      $$invalidate(7, tabScroller = $$new_props.tabScroller);
    if ("activeIndex" in $$props)
      $$invalidate(18, activeIndex = $$new_props.activeIndex);
    if ("tabAccessorMap" in $$props)
      $$invalidate(19, tabAccessorMap = $$new_props.tabAccessorMap);
    if ("tabAccessorWeakMap" in $$props)
      $$invalidate(20, tabAccessorWeakMap = $$new_props.tabAccessorWeakMap);
    if ("skipFocus" in $$props)
      skipFocus = $$new_props.skipFocus;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*active, tabs, activeIndex, instance, focusOnProgrammatic*/
    282660) {
      $:
        if (active !== tabs[activeIndex]) {
          $$invalidate(18, activeIndex = tabs.indexOf(active));
          if (instance) {
            skipFocus = !focusOnProgrammatic;
            instance.activateTab(activeIndex);
            skipFocus = false;
          }
        }
    }
    if ($$self.$$.dirty[0] & /*tabs, tabAccessorWeakMap, tabAccessorMap, activeIndex*/
    1835012) {
      $:
        if (tabs.length) {
          const accessor = tabs[0] instanceof Object ? tabAccessorWeakMap.get(tabs[0]) : tabAccessorMap[tabs[0]];
          if (accessor) {
            accessor.forceAccessible(activeIndex === -1);
          }
        }
    }
    if ($$self.$$.dirty[0] & /*instance, useAutomaticActivation*/
    32800) {
      $:
        if (instance) {
          instance.setUseAutomaticActivation(useAutomaticActivation);
        }
    }
  };
  return [
    use,
    className,
    tabs,
    key,
    tabindex,
    instance,
    element2,
    tabScroller,
    forwardEvents,
    handleTabMount,
    handleTabUnmount,
    $$restProps,
    active,
    focusOnActivate,
    focusOnProgrammatic,
    useAutomaticActivation,
    scrollIntoView,
    getElement,
    activeIndex,
    tabAccessorMap,
    tabAccessorWeakMap,
    slots,
    tabscroller_binding,
    div_binding,
    $$scope
  ];
}
var TabBar = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_12,
      create_fragment2,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        tabs: 2,
        key: 3,
        focusOnActivate: 13,
        focusOnProgrammatic: 14,
        useAutomaticActivation: 15,
        active: 12,
        tabindex: 4,
        scrollIntoView: 16,
        getElement: 17
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "TabBar",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabs() {
    throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabs(value) {
    throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get key() {
    throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set key(value) {
    throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focusOnActivate() {
    throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focusOnActivate(value) {
    throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get focusOnProgrammatic() {
    throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set focusOnProgrammatic(value) {
    throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get useAutomaticActivation() {
    throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set useAutomaticActivation(value) {
    throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get active() {
    throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set active(value) {
    throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get tabindex() {
    throw new Error("<TabBar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set tabindex(value) {
    throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get scrollIntoView() {
    return this.$$.ctx[16];
  }
  set scrollIntoView(value) {
    throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[17];
  }
  set getElement(value) {
    throw new Error("<TabBar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var TabBar_default = TabBar;

// node_modules/@smui/tab-bar/dist/index.js
var dist_default2 = TabBar_default;
export {
  dist_default2 as default
};
//# sourceMappingURL=@smui_tab-bar.js.map
