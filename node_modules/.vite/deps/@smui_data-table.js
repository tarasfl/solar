import {
  CommonLabel_default
} from "./chunk-DVQWFXPQ.js";
import {
  classMap,
  dispatch,
  exclude,
  forwardEventsBuilder,
  prefixFilter,
  useActions
} from "./chunk-DXJYLXNN.js";
import "./chunk-W4OU4FMO.js";
import "./chunk-Y3XZ6UIT.js";
import "./chunk-ZB6PEJPW.js";
import "./chunk-X7HCJ7ZS.js";
import {
  writable
} from "./chunk-FBWM3HWJ.js";
import {
  MDCDataTableFoundation,
  SortValue
} from "./chunk-Z6F26AGM.js";
import "./chunk-VZS2PTXG.js";
import "./chunk-OYKM6SV3.js";
import "./chunk-RFTMRRON.js";
import "./chunk-NQKK4KOY.js";
import {
  ponyfill_exports
} from "./chunk-BT6PLM7B.js";
import "./chunk-ODRA5LQH.js";
import "./chunk-X43LXICK.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  binding_callbacks,
  check_outros,
  children,
  claim_element,
  claim_space,
  claim_text,
  component_subscribe,
  compute_rest_props,
  compute_slots,
  create_slot,
  detach_dev,
  dispatch_dev,
  element,
  empty,
  exclude_internal_props,
  getContext,
  get_all_dirty_from_scope,
  get_current_component,
  get_slot_changes,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_hydration_dev,
  is_function,
  listen_dev,
  onDestroy,
  onMount,
  run_all,
  safe_not_equal,
  setContext,
  set_attributes,
  set_data_dev,
  set_store_value,
  space,
  text,
  transition_in,
  transition_out,
  update_slot_base,
  validate_slots,
  validate_store
} from "./chunk-NMMN3PC6.js";
import "./chunk-4DGM7FRE.js";
import "./chunk-7U33LM2Z.js";

// node_modules/@smui/data-table/dist/DataTable.svelte
var { Error: Error_1 } = globals;
var file = "node_modules/@smui/data-table/dist/DataTable.svelte";
var get_paginate_slot_changes = (dirty) => ({});
var get_paginate_slot_context = (ctx) => ({});
var get_progress_slot_changes = (dirty) => ({});
var get_progress_slot_context = (ctx) => ({});
function create_if_block(ctx) {
  let div1;
  let div0;
  let t;
  let div1_style_value;
  let current;
  const progress_slot_template = (
    /*#slots*/
    ctx[36].progress
  );
  const progress_slot = create_slot(
    progress_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    get_progress_slot_context
  );
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      if (progress_slot)
        progress_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true, style: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      children(div0).forEach(detach_dev);
      t = claim_space(div1_nodes);
      if (progress_slot)
        progress_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "mdc-data-table__scrim");
      add_location(div0, file, 50, 6, 1528);
      attr_dev(div1, "class", "mdc-data-table__progress-indicator");
      attr_dev(div1, "style", div1_style_value = Object.entries(
        /*progressIndicatorStyles*/
        ctx[13]
      ).map(func).join(" "));
      add_location(div1, file, 44, 4, 1335);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div1, t);
      if (progress_slot) {
        progress_slot.m(div1, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (progress_slot) {
        if (progress_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            progress_slot,
            progress_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              progress_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              get_progress_slot_changes
            ),
            get_progress_slot_context
          );
        }
      }
      if (!current || dirty[0] & /*progressIndicatorStyles*/
      8192 && div1_style_value !== (div1_style_value = Object.entries(
        /*progressIndicatorStyles*/
        ctx2[13]
      ).map(func).join(" "))) {
        attr_dev(div1, "style", div1_style_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(progress_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(progress_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (progress_slot)
        progress_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(44:2) {#if $$slots.progress}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div1;
  let div0;
  let table;
  let table_class_value;
  let useActions_action;
  let div0_class_value;
  let useActions_action_1;
  let t0;
  let t1;
  let div1_class_value;
  let useActions_action_2;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[36].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    null
  );
  let table_levels = [
    {
      class: table_class_value = classMap({
        [
          /*table$class*/
          ctx[6]
        ]: true,
        "mdc-data-table__table": true
      })
    },
    prefixFilter(
      /*$$restProps*/
      ctx[25],
      "table$"
    )
  ];
  let table_data = {};
  for (let i = 0; i < table_levels.length; i += 1) {
    table_data = assign(table_data, table_levels[i]);
  }
  let div0_levels = [
    {
      class: div0_class_value = classMap({
        [
          /*container$class*/
          ctx[4]
        ]: true,
        "mdc-data-table__table-container": true
      })
    },
    prefixFilter(
      /*$$restProps*/
      ctx[25],
      "container$"
    )
  ];
  let div_data = {};
  for (let i = 0; i < div0_levels.length; i += 1) {
    div_data = assign(div_data, div0_levels[i]);
  }
  let if_block = (
    /*$$slots*/
    ctx[24].progress && create_if_block(ctx)
  );
  const paginate_slot_template = (
    /*#slots*/
    ctx[36].paginate
  );
  const paginate_slot = create_slot(
    paginate_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    get_paginate_slot_context
  );
  let div1_levels = [
    {
      class: div1_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-data-table": true,
        "mdc-data-table--sticky-header": (
          /*stickyHeader*/
          ctx[2]
        ),
        .../*internalClasses*/
        ctx[12]
      })
    },
    exclude(
      /*$$restProps*/
      ctx[25],
      ["container$", "table$"]
    )
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  const block = {
    c: function create() {
      div1 = element("div");
      div0 = element("div");
      table = element("table");
      if (default_slot)
        default_slot.c();
      t0 = space();
      if (if_block)
        if_block.c();
      t1 = space();
      if (paginate_slot)
        paginate_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      table = claim_element(div0_nodes, "TABLE", { class: true });
      var table_nodes = children(table);
      if (default_slot)
        default_slot.l(table_nodes);
      table_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div1_nodes);
      if (if_block)
        if_block.l(div1_nodes);
      t1 = claim_space(div1_nodes);
      if (paginate_slot)
        paginate_slot.l(div1_nodes);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(table, table_data);
      add_location(table, file, 31, 4, 1073);
      set_attributes(div0, div_data);
      add_location(div0, file, 22, 2, 842);
      set_attributes(div1, div_data_1);
      add_location(div1, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, table);
      if (default_slot) {
        default_slot.m(table, null);
      }
      ctx[37](div0);
      append_hydration_dev(div1, t0);
      if (if_block)
        if_block.m(div1, null);
      append_hydration_dev(div1, t1);
      if (paginate_slot) {
        paginate_slot.m(div1, null);
      }
      ctx[38](div1);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            table,
            /*table$use*/
            ctx[5]
          )),
          action_destroyer(useActions_action_1 = useActions.call(
            null,
            div0,
            /*container$use*/
            ctx[3]
          )),
          action_destroyer(useActions_action_2 = useActions.call(
            null,
            div1,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[15].call(null, div1)),
          listen_dev(
            div1,
            "SMUICheckbox:mount",
            /*SMUICheckbox_mount_handler*/
            ctx[39],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "SMUIDataTableHeader:mount",
            /*handleHeaderMount*/
            ctx[19],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "SMUIDataTableHeader:unmount",
            /*SMUIDataTableHeader_unmount_handler*/
            ctx[40],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "SMUIDataTableBody:mount",
            /*handleBodyMount*/
            ctx[20],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "SMUIDataTableBody:unmount",
            /*SMUIDataTableBody_unmount_handler*/
            ctx[41],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "SMUIDataTableHeaderCheckbox:change",
            /*SMUIDataTableHeaderCheckbox_change_handler*/
            ctx[42],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "SMUIDataTableHeader:click",
            /*handleHeaderRowClick*/
            ctx[22],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "SMUIDataTableRow:click",
            /*handleRowClick*/
            ctx[23],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            div1,
            "SMUIDataTableBodyCheckbox:change",
            /*handleBodyCheckboxChange*/
            ctx[21],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(table, table_data = get_spread_update(table_levels, [
        (!current || dirty[0] & /*table$class*/
        64 && table_class_value !== (table_class_value = classMap({
          [
            /*table$class*/
            ctx2[6]
          ]: true,
          "mdc-data-table__table": true
        }))) && { class: table_class_value },
        dirty[0] & /*$$restProps*/
        33554432 && prefixFilter(
          /*$$restProps*/
          ctx2[25],
          "table$"
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty[0] & /*table$use*/
      32)
        useActions_action.update.call(
          null,
          /*table$use*/
          ctx2[5]
        );
      set_attributes(div0, div_data = get_spread_update(div0_levels, [
        (!current || dirty[0] & /*container$class*/
        16 && div0_class_value !== (div0_class_value = classMap({
          [
            /*container$class*/
            ctx2[4]
          ]: true,
          "mdc-data-table__table-container": true
        }))) && { class: div0_class_value },
        dirty[0] & /*$$restProps*/
        33554432 && prefixFilter(
          /*$$restProps*/
          ctx2[25],
          "container$"
        )
      ]));
      if (useActions_action_1 && is_function(useActions_action_1.update) && dirty[0] & /*container$use*/
      8)
        useActions_action_1.update.call(
          null,
          /*container$use*/
          ctx2[3]
        );
      if (
        /*$$slots*/
        ctx2[24].progress
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$$slots*/
          16777216) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div1, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (paginate_slot) {
        if (paginate_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            paginate_slot,
            paginate_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              paginate_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              get_paginate_slot_changes
            ),
            get_paginate_slot_context
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty[0] & /*className, stickyHeader, internalClasses*/
        4102 && div1_class_value !== (div1_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-data-table": true,
          "mdc-data-table--sticky-header": (
            /*stickyHeader*/
            ctx2[2]
          ),
          .../*internalClasses*/
          ctx2[12]
        }))) && { class: div1_class_value },
        dirty[0] & /*$$restProps*/
        33554432 && exclude(
          /*$$restProps*/
          ctx2[25],
          ["container$", "table$"]
        )
      ]));
      if (useActions_action_2 && is_function(useActions_action_2.update) && dirty[0] & /*use*/
      1)
        useActions_action_2.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      transition_in(if_block);
      transition_in(paginate_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      transition_out(if_block);
      transition_out(paginate_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[37](null);
      if (if_block)
        if_block.d();
      if (paginate_slot)
        paginate_slot.d(detaching);
      ctx[38](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var func = ([name, value]) => `${name}: ${value};`;
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = [
    "use",
    "class",
    "stickyHeader",
    "sortable",
    "sort",
    "sortDirection",
    "sortAscendingAriaLabel",
    "sortDescendingAriaLabel",
    "container$use",
    "container$class",
    "table$use",
    "table$class",
    "layout",
    "getElement"
  ];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $progressClosed;
  let $sortDirectionStore;
  let $sortStore;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("DataTable", slots, ["default", "progress", "paginate"]);
  const $$slots = compute_slots(slots);
  const { closest } = ponyfill_exports;
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { stickyHeader = false } = $$props;
  let { sortable = false } = $$props;
  let { sort = null } = $$props;
  let { sortDirection = "ascending" } = $$props;
  let { sortAscendingAriaLabel = "sorted, ascending" } = $$props;
  let { sortDescendingAriaLabel = "sorted, descending" } = $$props;
  let { container$use = [] } = $$props;
  let { container$class = "" } = $$props;
  let { table$use = [] } = $$props;
  let { table$class = "" } = $$props;
  let element2;
  let instance6;
  let container;
  let header = void 0;
  let body = void 0;
  let internalClasses = {};
  let progressIndicatorStyles = { height: "auto", top: "initial" };
  let addLayoutListener = getContext("SMUI:addLayoutListener");
  let removeLayoutListener;
  let postMount = false;
  let progressClosed = writable(false);
  validate_store(progressClosed, "progressClosed");
  component_subscribe($$self, progressClosed, (value) => $$invalidate(34, $progressClosed = value));
  let sortStore = writable(sort);
  validate_store(sortStore, "sortStore");
  component_subscribe($$self, sortStore, (value) => $$invalidate(45, $sortStore = value));
  let sortDirectionStore = writable(sortDirection);
  validate_store(sortDirectionStore, "sortDirectionStore");
  component_subscribe($$self, sortDirectionStore, (value) => $$invalidate(44, $sortDirectionStore = value));
  setContext("SMUI:checkbox:context", "data-table");
  setContext("SMUI:linear-progress:context", "data-table");
  setContext("SMUI:linear-progress:closed", progressClosed);
  setContext("SMUI:data-table:sortable", sortable);
  setContext("SMUI:data-table:sort", sortStore);
  setContext("SMUI:data-table:sortDirection", sortDirectionStore);
  setContext("SMUI:data-table:sortAscendingAriaLabel", sortAscendingAriaLabel);
  setContext("SMUI:data-table:sortDescendingAriaLabel", sortDescendingAriaLabel);
  if (addLayoutListener) {
    removeLayoutListener = addLayoutListener(layout);
  }
  let previousProgressClosed = void 0;
  onMount(() => {
    $$invalidate(7, instance6 = new MDCDataTableFoundation({
      addClass,
      removeClass,
      getHeaderCellElements: () => {
        var _a;
        return (_a = header === null || header === void 0 ? void 0 : header.cells.map((accessor) => accessor.element)) !== null && _a !== void 0 ? _a : [];
      },
      getHeaderCellCount: () => {
        var _a;
        return (_a = header === null || header === void 0 ? void 0 : header.cells.length) !== null && _a !== void 0 ? _a : 0;
      },
      getAttributeByHeaderCellIndex: (index, name) => {
        var _a;
        return (_a = header === null || header === void 0 ? void 0 : header.orderedCells[index].getAttr(name)) !== null && _a !== void 0 ? _a : null;
      },
      setAttributeByHeaderCellIndex: (index, name, value) => {
        header === null || header === void 0 ? void 0 : header.orderedCells[index].addAttr(name, value);
      },
      setClassNameByHeaderCellIndex: (index, className2) => {
        header === null || header === void 0 ? void 0 : header.orderedCells[index].addClass(className2);
      },
      removeClassNameByHeaderCellIndex: (index, className2) => {
        header === null || header === void 0 ? void 0 : header.orderedCells[index].removeClass(className2);
      },
      notifySortAction: (data) => {
        $$invalidate(26, sort = data.columnId);
        $$invalidate(27, sortDirection = data.sortValue);
        dispatch(getElement(), "SMUIDataTable:sorted", data, void 0, true);
      },
      getTableContainerHeight: () => container.getBoundingClientRect().height,
      getTableHeaderHeight: () => {
        const tableHeader = getElement().querySelector(".mdc-data-table__header-row");
        if (!tableHeader) {
          throw new Error("MDCDataTable: Table header element not found.");
        }
        return tableHeader.getBoundingClientRect().height;
      },
      setProgressIndicatorStyles: (styles) => {
        $$invalidate(13, progressIndicatorStyles = styles);
      },
      addClassAtRowIndex: (rowIndex, className2) => {
        body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].addClass(className2);
      },
      getRowCount: () => {
        var _a;
        return (_a = body === null || body === void 0 ? void 0 : body.rows.length) !== null && _a !== void 0 ? _a : 0;
      },
      getRowElements: () => {
        var _a;
        return (_a = body === null || body === void 0 ? void 0 : body.rows.map((accessor) => accessor.element)) !== null && _a !== void 0 ? _a : [];
      },
      getRowIdAtIndex: (rowIndex) => {
        var _a;
        return (_a = body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].rowId) !== null && _a !== void 0 ? _a : null;
      },
      getRowIndexByChildElement: (el) => {
        var _a;
        return (_a = body === null || body === void 0 ? void 0 : body.orderedRows.map((accessor) => accessor.element).indexOf(closest(el, ".mdc-data-table__row"))) !== null && _a !== void 0 ? _a : -1;
      },
      getSelectedRowCount: () => {
        var _a;
        return (_a = body === null || body === void 0 ? void 0 : body.rows.filter((accessor) => accessor.selected).length) !== null && _a !== void 0 ? _a : 0;
      },
      isCheckboxAtRowIndexChecked: (rowIndex) => {
        const checkbox = body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].checkbox;
        if (checkbox) {
          return checkbox.checked;
        }
        return false;
      },
      isHeaderRowCheckboxChecked: () => {
        const checkbox = header === null || header === void 0 ? void 0 : header.checkbox;
        if (checkbox) {
          return checkbox.checked;
        }
        return false;
      },
      isRowsSelectable: () => !!getElement().querySelector(".mdc-data-table__row-checkbox") || !!getElement().querySelector(".mdc-data-table__header-row-checkbox"),
      notifyRowSelectionChanged: (data) => {
        const row = body === null || body === void 0 ? void 0 : body.orderedRows[data.rowIndex];
        if (row) {
          dispatch(
            getElement(),
            "SMUIDataTable:rowSelectionChanged",
            {
              row: row.element,
              rowId: row.rowId,
              rowIndex: data.rowIndex,
              selected: data.selected
            },
            void 0,
            true
          );
        }
      },
      notifySelectedAll: () => {
        setHeaderRowCheckboxIndeterminate(false);
        dispatch(getElement(), "SMUIDataTable:selectedAll", void 0, void 0, true);
      },
      notifyUnselectedAll: () => {
        setHeaderRowCheckboxIndeterminate(false);
        dispatch(getElement(), "SMUIDataTable:unselectedAll", void 0, void 0, true);
      },
      notifyRowClick: (detail) => {
        dispatch(getElement(), "SMUIDataTable:rowClick", detail, void 0, true);
      },
      registerHeaderRowCheckbox: () => {
      },
      // Handled automatically.
      registerRowCheckboxes: () => {
      },
      // Handled automatically.
      removeClassAtRowIndex: (rowIndex, className2) => {
        body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].removeClass(className2);
      },
      setAttributeAtRowIndex: (rowIndex, name, value) => {
        body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].addAttr(name, value);
      },
      setHeaderRowCheckboxChecked: (checked) => {
        const checkbox = header === null || header === void 0 ? void 0 : header.checkbox;
        if (checkbox) {
          checkbox.checked = checked;
        }
      },
      setHeaderRowCheckboxIndeterminate,
      setRowCheckboxCheckedAtIndex: (rowIndex, checked) => {
        const checkbox = body === null || body === void 0 ? void 0 : body.orderedRows[rowIndex].checkbox;
        if (checkbox) {
          checkbox.checked = checked;
        }
      },
      setSortStatusLabelByHeaderCellIndex: (_columnIndex, _sortValue) => {
      }
      // Handled automatically.
    }));
    instance6.init();
    instance6.layout();
    $$invalidate(14, postMount = true);
    return () => {
      instance6.destroy();
    };
  });
  onDestroy(() => {
    if (removeLayoutListener) {
      removeLayoutListener();
    }
  });
  function handleHeaderMount(event) {
    $$invalidate(10, header = event.detail);
  }
  function handleBodyMount(event) {
    $$invalidate(11, body = event.detail);
  }
  function handleBodyCheckboxChange(event) {
    if (instance6) {
      instance6.handleRowCheckboxChange(event);
    }
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(12, internalClasses[className2] = false, internalClasses);
    }
  }
  function setHeaderRowCheckboxIndeterminate(indeterminate) {
    const checkbox = header === null || header === void 0 ? void 0 : header.checkbox;
    if (checkbox) {
      checkbox.indeterminate = indeterminate;
    }
  }
  function handleHeaderRowClick(event) {
    if (!instance6 || !event.detail.target) {
      return;
    }
    const headerCell = closest(event.detail.target, ".mdc-data-table__header-cell--with-sort");
    if (headerCell) {
      handleSortAction(headerCell);
    }
  }
  function handleRowClick(event) {
    if (!instance6 || !event.detail.target) {
      return;
    }
    const row = closest(event.detail.target, ".mdc-data-table__row");
    if (row && instance6) {
      instance6.handleRowClick({ rowId: event.detail.rowId, row });
    }
  }
  function handleSortAction(headerCell) {
    var _a, _b;
    const orderedCells = (_a = header === null || header === void 0 ? void 0 : header.orderedCells) !== null && _a !== void 0 ? _a : [];
    const columnIndex = orderedCells.map((accessor) => accessor.element).indexOf(headerCell);
    if (columnIndex === -1) {
      return;
    }
    const columnId = (_b = orderedCells[columnIndex].columnId) !== null && _b !== void 0 ? _b : null;
    instance6.handleSortAction({ columnId, columnIndex, headerCell });
  }
  function layout() {
    return instance6.layout();
  }
  function getElement() {
    return element2;
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(9, container);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(8, element2);
    });
  }
  const SMUICheckbox_mount_handler = () => instance6 && postMount && instance6.layout();
  const SMUIDataTableHeader_unmount_handler = () => $$invalidate(10, header = void 0);
  const SMUIDataTableBody_unmount_handler = () => $$invalidate(11, body = void 0);
  const SMUIDataTableHeaderCheckbox_change_handler = () => instance6 && instance6.handleHeaderRowCheckboxChange();
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(25, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("stickyHeader" in $$new_props)
      $$invalidate(2, stickyHeader = $$new_props.stickyHeader);
    if ("sortable" in $$new_props)
      $$invalidate(28, sortable = $$new_props.sortable);
    if ("sort" in $$new_props)
      $$invalidate(26, sort = $$new_props.sort);
    if ("sortDirection" in $$new_props)
      $$invalidate(27, sortDirection = $$new_props.sortDirection);
    if ("sortAscendingAriaLabel" in $$new_props)
      $$invalidate(29, sortAscendingAriaLabel = $$new_props.sortAscendingAriaLabel);
    if ("sortDescendingAriaLabel" in $$new_props)
      $$invalidate(30, sortDescendingAriaLabel = $$new_props.sortDescendingAriaLabel);
    if ("container$use" in $$new_props)
      $$invalidate(3, container$use = $$new_props.container$use);
    if ("container$class" in $$new_props)
      $$invalidate(4, container$class = $$new_props.container$class);
    if ("table$use" in $$new_props)
      $$invalidate(5, table$use = $$new_props.table$use);
    if ("table$class" in $$new_props)
      $$invalidate(6, table$class = $$new_props.table$class);
    if ("$$scope" in $$new_props)
      $$invalidate(35, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    MDCDataTableFoundation,
    ponyfill: ponyfill_exports,
    onMount,
    onDestroy,
    getContext,
    setContext,
    writable,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    dispatch,
    closest,
    forwardEvents,
    use,
    className,
    stickyHeader,
    sortable,
    sort,
    sortDirection,
    sortAscendingAriaLabel,
    sortDescendingAriaLabel,
    container$use,
    container$class,
    table$use,
    table$class,
    element: element2,
    instance: instance6,
    container,
    header,
    body,
    internalClasses,
    progressIndicatorStyles,
    addLayoutListener,
    removeLayoutListener,
    postMount,
    progressClosed,
    sortStore,
    sortDirectionStore,
    previousProgressClosed,
    handleHeaderMount,
    handleBodyMount,
    handleBodyCheckboxChange,
    addClass,
    removeClass,
    setHeaderRowCheckboxIndeterminate,
    handleHeaderRowClick,
    handleRowClick,
    handleSortAction,
    layout,
    getElement,
    $progressClosed,
    $sortDirectionStore,
    $sortStore
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("stickyHeader" in $$props)
      $$invalidate(2, stickyHeader = $$new_props.stickyHeader);
    if ("sortable" in $$props)
      $$invalidate(28, sortable = $$new_props.sortable);
    if ("sort" in $$props)
      $$invalidate(26, sort = $$new_props.sort);
    if ("sortDirection" in $$props)
      $$invalidate(27, sortDirection = $$new_props.sortDirection);
    if ("sortAscendingAriaLabel" in $$props)
      $$invalidate(29, sortAscendingAriaLabel = $$new_props.sortAscendingAriaLabel);
    if ("sortDescendingAriaLabel" in $$props)
      $$invalidate(30, sortDescendingAriaLabel = $$new_props.sortDescendingAriaLabel);
    if ("container$use" in $$props)
      $$invalidate(3, container$use = $$new_props.container$use);
    if ("container$class" in $$props)
      $$invalidate(4, container$class = $$new_props.container$class);
    if ("table$use" in $$props)
      $$invalidate(5, table$use = $$new_props.table$use);
    if ("table$class" in $$props)
      $$invalidate(6, table$class = $$new_props.table$class);
    if ("element" in $$props)
      $$invalidate(8, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(7, instance6 = $$new_props.instance);
    if ("container" in $$props)
      $$invalidate(9, container = $$new_props.container);
    if ("header" in $$props)
      $$invalidate(10, header = $$new_props.header);
    if ("body" in $$props)
      $$invalidate(11, body = $$new_props.body);
    if ("internalClasses" in $$props)
      $$invalidate(12, internalClasses = $$new_props.internalClasses);
    if ("progressIndicatorStyles" in $$props)
      $$invalidate(13, progressIndicatorStyles = $$new_props.progressIndicatorStyles);
    if ("addLayoutListener" in $$props)
      addLayoutListener = $$new_props.addLayoutListener;
    if ("removeLayoutListener" in $$props)
      removeLayoutListener = $$new_props.removeLayoutListener;
    if ("postMount" in $$props)
      $$invalidate(14, postMount = $$new_props.postMount);
    if ("progressClosed" in $$props)
      $$invalidate(16, progressClosed = $$new_props.progressClosed);
    if ("sortStore" in $$props)
      $$invalidate(17, sortStore = $$new_props.sortStore);
    if ("sortDirectionStore" in $$props)
      $$invalidate(18, sortDirectionStore = $$new_props.sortDirectionStore);
    if ("previousProgressClosed" in $$props)
      $$invalidate(33, previousProgressClosed = $$new_props.previousProgressClosed);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*sort*/
    67108864) {
      $:
        set_store_value(sortStore, $sortStore = sort, $sortStore);
    }
    if ($$self.$$.dirty[0] & /*sortDirection*/
    134217728) {
      $:
        set_store_value(sortDirectionStore, $sortDirectionStore = sortDirection, $sortDirectionStore);
    }
    if ($$self.$$.dirty[0] & /*instance*/
    128 | $$self.$$.dirty[1] & /*previousProgressClosed, $progressClosed*/
    12) {
      $:
        if ($$slots.progress && instance6 && previousProgressClosed !== $progressClosed) {
          $$invalidate(33, previousProgressClosed = $progressClosed);
          if ($progressClosed) {
            instance6.hideProgress();
          } else {
            instance6.showProgress();
          }
        }
    }
  };
  return [
    use,
    className,
    stickyHeader,
    container$use,
    container$class,
    table$use,
    table$class,
    instance6,
    element2,
    container,
    header,
    body,
    internalClasses,
    progressIndicatorStyles,
    postMount,
    forwardEvents,
    progressClosed,
    sortStore,
    sortDirectionStore,
    handleHeaderMount,
    handleBodyMount,
    handleBodyCheckboxChange,
    handleHeaderRowClick,
    handleRowClick,
    $$slots,
    $$restProps,
    sort,
    sortDirection,
    sortable,
    sortAscendingAriaLabel,
    sortDescendingAriaLabel,
    layout,
    getElement,
    previousProgressClosed,
    $progressClosed,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    SMUICheckbox_mount_handler,
    SMUIDataTableHeader_unmount_handler,
    SMUIDataTableBody_unmount_handler,
    SMUIDataTableHeaderCheckbox_change_handler
  ];
}
var DataTable = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(
      this,
      options,
      instance_1,
      create_fragment,
      safe_not_equal,
      {
        use: 0,
        class: 1,
        stickyHeader: 2,
        sortable: 28,
        sort: 26,
        sortDirection: 27,
        sortAscendingAriaLabel: 29,
        sortDescendingAriaLabel: 30,
        container$use: 3,
        container$class: 4,
        table$use: 5,
        table$class: 6,
        layout: 31,
        getElement: 32
      },
      null,
      [-1, -1]
    );
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "DataTable",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get stickyHeader() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set stickyHeader(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sort() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sort(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortDirection() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortDirection(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortAscendingAriaLabel() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortAscendingAriaLabel(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortDescendingAriaLabel() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortDescendingAriaLabel(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container$use() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container$use(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get container$class() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set container$class(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get table$use() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set table$use(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get table$class() {
    throw new Error_1("<DataTable>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set table$class(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get layout() {
    return this.$$.ctx[31];
  }
  set layout(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[32];
  }
  set getElement(value) {
    throw new Error_1("<DataTable>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var DataTable_default = DataTable;

// node_modules/@smui/data-table/dist/Head.svelte
var file2 = "node_modules/@smui/data-table/dist/Head.svelte";
function create_fragment2(ctx) {
  let thead;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let thead_levels = [
    /*$$restProps*/
    ctx[7]
  ];
  let thead_data = {};
  for (let i = 0; i < thead_levels.length; i += 1) {
    thead_data = assign(thead_data, thead_levels[i]);
  }
  const block = {
    c: function create() {
      thead = element("thead");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      thead = claim_element(nodes, "THEAD", {});
      var thead_nodes = children(thead);
      if (default_slot)
        default_slot.l(thead_nodes);
      thead_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(thead, thead_data);
      add_location(thead, file2, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, thead, anchor);
      if (default_slot) {
        default_slot.m(thead, null);
      }
      ctx[11](thead);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            thead,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[3].call(null, thead)),
          listen_dev(
            thead,
            "SMUICheckbox:mount",
            /*handleCheckboxMount*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            thead,
            "SMUICheckbox:unmount",
            /*SMUICheckbox_unmount_handler*/
            ctx[12],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            thead,
            "SMUIDataTableCell:mount",
            /*handleCellMount*/
            ctx[5],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            thead,
            "SMUIDataTableCell:unmount",
            /*handleCellUnmount*/
            ctx[6],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(thead, thead_data = get_spread_update(thead_levels, [dirty & /*$$restProps*/
      128 && /*$$restProps*/
      ctx2[7]]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(thead);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Head", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let element2;
  let checkbox = void 0;
  let cells = [];
  const cellAccessorMap = /* @__PURE__ */ new WeakMap();
  setContext("SMUI:data-table:row:header", true);
  onMount(() => {
    const accessor = {
      get cells() {
        return cells;
      },
      get orderedCells() {
        return getOrderedCells();
      },
      get checkbox() {
        return checkbox;
      }
    };
    dispatch(getElement(), "SMUIDataTableHeader:mount", accessor);
    return () => {
      dispatch(getElement(), "SMUIDataTableHeader:unmount", accessor);
    };
  });
  function handleCheckboxMount(event) {
    $$invalidate(2, checkbox = event.detail);
  }
  function handleCellMount(event) {
    cells.push(event.detail);
    cellAccessorMap.set(event.detail.element, event.detail);
    event.stopPropagation();
  }
  function handleCellUnmount(event) {
    const idx = cells.indexOf(event.detail);
    if (idx !== -1) {
      cells.splice(idx, 1);
      cells = cells;
    }
    cellAccessorMap.delete(event.detail.element);
    event.stopPropagation();
  }
  function getOrderedCells() {
    return [...getElement().querySelectorAll(".mdc-data-table__header-cell")].map((element3) => cellAccessorMap.get(element3)).filter((accessor) => accessor && accessor._smui_data_table_header_cell_accessor);
  }
  function getElement() {
    return element2;
  }
  function thead_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(1, element2);
    });
  }
  const SMUICheckbox_unmount_handler = () => $$invalidate(2, checkbox = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(7, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    useActions,
    dispatch,
    forwardEvents,
    use,
    element: element2,
    checkbox,
    cells,
    cellAccessorMap,
    handleCheckboxMount,
    handleCellMount,
    handleCellUnmount,
    getOrderedCells,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("element" in $$props)
      $$invalidate(1, element2 = $$new_props.element);
    if ("checkbox" in $$props)
      $$invalidate(2, checkbox = $$new_props.checkbox);
    if ("cells" in $$props)
      cells = $$new_props.cells;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    element2,
    checkbox,
    forwardEvents,
    handleCheckboxMount,
    handleCellMount,
    handleCellUnmount,
    $$restProps,
    getElement,
    $$scope,
    slots,
    thead_binding,
    SMUICheckbox_unmount_handler
  ];
}
var Head = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment2, safe_not_equal, { use: 0, getElement: 8 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Head",
      options,
      id: create_fragment2.name
    });
  }
  get use() {
    throw new Error("<Head>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[8];
  }
  set getElement(value) {
    throw new Error("<Head>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Head_default = Head;

// node_modules/@smui/data-table/dist/Body.svelte
var file3 = "node_modules/@smui/data-table/dist/Body.svelte";
function create_fragment3(ctx) {
  let tbody;
  let tbody_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let tbody_levels = [
    {
      class: tbody_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-data-table__content": true
      })
    },
    /*$$restProps*/
    ctx[6]
  ];
  let tbody_data = {};
  for (let i = 0; i < tbody_levels.length; i += 1) {
    tbody_data = assign(tbody_data, tbody_levels[i]);
  }
  const block = {
    c: function create() {
      tbody = element("tbody");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      tbody = claim_element(nodes, "TBODY", { class: true });
      var tbody_nodes = children(tbody);
      if (default_slot)
        default_slot.l(tbody_nodes);
      tbody_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(tbody, tbody_data);
      add_location(tbody, file3, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tbody, anchor);
      if (default_slot) {
        default_slot.m(tbody, null);
      }
      ctx[10](tbody);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            tbody,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[3].call(null, tbody)),
          listen_dev(
            tbody,
            "SMUIDataTableRow:mount",
            /*handleRowMount*/
            ctx[4],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            tbody,
            "SMUIDataTableRow:unmount",
            /*handleRowUnmount*/
            ctx[5],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(tbody, tbody_data = get_spread_update(tbody_levels, [
        (!current || dirty & /*className*/
        2 && tbody_class_value !== (tbody_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-data-table__content": true
        }))) && { class: tbody_class_value },
        dirty & /*$$restProps*/
        64 && /*$$restProps*/
        ctx2[6]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tbody);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment3.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance2($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Body", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let element2;
  let rows = [];
  const rowAccessorMap = /* @__PURE__ */ new WeakMap();
  setContext("SMUI:data-table:row:header", false);
  onMount(() => {
    const accessor = {
      get rows() {
        return rows;
      },
      get orderedRows() {
        return getOrderedRows();
      }
    };
    dispatch(getElement(), "SMUIDataTableBody:mount", accessor);
    return () => {
      dispatch(getElement(), "SMUIDataTableBody:unmount", accessor);
    };
  });
  function handleRowMount(event) {
    rows.push(event.detail);
    rowAccessorMap.set(event.detail.element, event.detail);
    event.stopPropagation();
  }
  function handleRowUnmount(event) {
    const idx = rows.indexOf(event.detail);
    if (idx !== -1) {
      rows.splice(idx, 1);
      rows = rows;
    }
    rowAccessorMap.delete(event.detail.element);
    event.stopPropagation();
  }
  function getOrderedRows() {
    return [...getElement().querySelectorAll(".mdc-data-table__row")].map((element3) => rowAccessorMap.get(element3)).filter((accessor) => accessor && accessor._smui_data_table_row_accessor);
  }
  function getElement() {
    return element2;
  }
  function tbody_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("$$scope" in $$new_props)
      $$invalidate(8, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    onMount,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    forwardEvents,
    use,
    className,
    element: element2,
    rows,
    rowAccessorMap,
    handleRowMount,
    handleRowUnmount,
    getOrderedRows,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("rows" in $$props)
      rows = $$new_props.rows;
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    forwardEvents,
    handleRowMount,
    handleRowUnmount,
    $$restProps,
    getElement,
    $$scope,
    slots,
    tbody_binding
  ];
}
var Body = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance2, create_fragment3, safe_not_equal, { use: 0, class: 1, getElement: 7 });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Body",
      options,
      id: create_fragment3.name
    });
  }
  get use() {
    throw new Error("<Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Body>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[7];
  }
  set getElement(value) {
    throw new Error("<Body>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Body_default = Body;

// node_modules/@smui/data-table/dist/Row.svelte
var file4 = "node_modules/@smui/data-table/dist/Row.svelte";
function create_fragment4(ctx) {
  let tr;
  let tr_class_value;
  let tr_aria_selected_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[15].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[14],
    null
  );
  let tr_levels = [
    {
      class: tr_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-data-table__header-row": (
          /*header*/
          ctx[7]
        ),
        "mdc-data-table__row": !/*header*/
        ctx[7],
        "mdc-data-table__row--selected": !/*header*/
        ctx[7] && /*checkbox*/
        ctx[3] && /*checkbox*/
        ctx[3].checked,
        .../*internalClasses*/
        ctx[4]
      })
    },
    {
      "aria-selected": tr_aria_selected_value = /*checkbox*/
      ctx[3] ? (
        /*checkbox*/
        ctx[3].checked ? "true" : "false"
      ) : void 0
    },
    /*internalAttrs*/
    ctx[5],
    /*$$restProps*/
    ctx[11]
  ];
  let tr_data = {};
  for (let i = 0; i < tr_levels.length; i += 1) {
    tr_data = assign(tr_data, tr_levels[i]);
  }
  const block = {
    c: function create() {
      tr = element("tr");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      tr = claim_element(nodes, "TR", { class: true, "aria-selected": true });
      var tr_nodes = children(tr);
      if (default_slot)
        default_slot.l(tr_nodes);
      tr_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(tr, tr_data);
      add_location(tr, file4, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, tr, anchor);
      if (default_slot) {
        default_slot.m(tr, null);
      }
      ctx[16](tr);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            tr,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[6].call(null, tr)),
          listen_dev(
            tr,
            "click",
            /*click_handler*/
            ctx[17],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            tr,
            "SMUICheckbox:mount",
            /*handleCheckboxMount*/
            ctx[8],
            false,
            false,
            false,
            false
          ),
          listen_dev(
            tr,
            "SMUICheckbox:unmount",
            /*SMUICheckbox_unmount_handler*/
            ctx[18],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        16384)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[14],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[14]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[14],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(tr, tr_data = get_spread_update(tr_levels, [
        (!current || dirty & /*className, checkbox, internalClasses*/
        26 && tr_class_value !== (tr_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-data-table__header-row": (
            /*header*/
            ctx2[7]
          ),
          "mdc-data-table__row": !/*header*/
          ctx2[7],
          "mdc-data-table__row--selected": !/*header*/
          ctx2[7] && /*checkbox*/
          ctx2[3] && /*checkbox*/
          ctx2[3].checked,
          .../*internalClasses*/
          ctx2[4]
        }))) && { class: tr_class_value },
        (!current || dirty & /*checkbox*/
        8 && tr_aria_selected_value !== (tr_aria_selected_value = /*checkbox*/
        ctx2[3] ? (
          /*checkbox*/
          ctx2[3].checked ? "true" : "false"
        ) : void 0)) && { "aria-selected": tr_aria_selected_value },
        dirty & /*internalAttrs*/
        32 && /*internalAttrs*/
        ctx2[5],
        dirty & /*$$restProps*/
        2048 && /*$$restProps*/
        ctx2[11]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(tr);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment4.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var counter = 0;
function instance3($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "rowId", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Row", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { rowId = "SMUI-data-table-row-" + counter++ } = $$props;
  let element2;
  let checkbox = void 0;
  let internalClasses = {};
  let internalAttrs = {};
  let header = getContext("SMUI:data-table:row:header");
  onMount(() => {
    const accessor = header ? {
      _smui_data_table_row_accessor: false,
      get element() {
        return getElement();
      },
      get checkbox() {
        return checkbox;
      },
      get rowId() {
        return void 0;
      },
      get selected() {
        var _a;
        return (_a = checkbox && checkbox.checked) !== null && _a !== void 0 ? _a : false;
      },
      addClass,
      removeClass,
      getAttr,
      addAttr
    } : {
      _smui_data_table_row_accessor: true,
      get element() {
        return getElement();
      },
      get checkbox() {
        return checkbox;
      },
      get rowId() {
        return rowId;
      },
      get selected() {
        var _a;
        return (_a = checkbox && checkbox.checked) !== null && _a !== void 0 ? _a : false;
      },
      addClass,
      removeClass,
      getAttr,
      addAttr
    };
    dispatch(getElement(), "SMUIDataTableRow:mount", accessor);
    return () => {
      dispatch(getElement(), "SMUIDataTableRow:unmount", accessor);
    };
  });
  function handleCheckboxMount(event) {
    $$invalidate(3, checkbox = event.detail);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(4, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(4, internalClasses[className2] = false, internalClasses);
    }
  }
  function getAttr(name) {
    var _a;
    return name in internalAttrs ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(5, internalAttrs[name] = value, internalAttrs);
    }
  }
  function notifyHeaderClick(event) {
    dispatch(getElement(), "SMUIDataTableHeader:click", event);
  }
  function notifyRowClick(event) {
    dispatch(getElement(), "SMUIDataTableRow:click", { rowId, target: event.target });
  }
  function getElement() {
    return element2;
  }
  function tr_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(2, element2);
    });
  }
  const click_handler = (event) => header ? notifyHeaderClick(event) : notifyRowClick(event);
  const SMUICheckbox_unmount_handler = () => $$invalidate(3, checkbox = void 0);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(11, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("rowId" in $$new_props)
      $$invalidate(12, rowId = $$new_props.rowId);
    if ("$$scope" in $$new_props)
      $$invalidate(14, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    counter,
    onMount,
    getContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    forwardEvents,
    use,
    className,
    rowId,
    element: element2,
    checkbox,
    internalClasses,
    internalAttrs,
    header,
    handleCheckboxMount,
    addClass,
    removeClass,
    getAttr,
    addAttr,
    notifyHeaderClick,
    notifyRowClick,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("rowId" in $$props)
      $$invalidate(12, rowId = $$new_props.rowId);
    if ("element" in $$props)
      $$invalidate(2, element2 = $$new_props.element);
    if ("checkbox" in $$props)
      $$invalidate(3, checkbox = $$new_props.checkbox);
    if ("internalClasses" in $$props)
      $$invalidate(4, internalClasses = $$new_props.internalClasses);
    if ("internalAttrs" in $$props)
      $$invalidate(5, internalAttrs = $$new_props.internalAttrs);
    if ("header" in $$props)
      $$invalidate(7, header = $$new_props.header);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    element2,
    checkbox,
    internalClasses,
    internalAttrs,
    forwardEvents,
    header,
    handleCheckboxMount,
    notifyHeaderClick,
    notifyRowClick,
    $$restProps,
    rowId,
    getElement,
    $$scope,
    slots,
    tr_binding,
    click_handler,
    SMUICheckbox_unmount_handler
  ];
}
var Row = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance3, create_fragment4, safe_not_equal, {
      use: 0,
      class: 1,
      rowId: 12,
      getElement: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Row",
      options,
      id: create_fragment4.name
    });
  }
  get use() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get rowId() {
    throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set rowId(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[13];
  }
  set getElement(value) {
    throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Row_default = Row;

// node_modules/@smui/data-table/dist/Cell.svelte
var file5 = "node_modules/@smui/data-table/dist/Cell.svelte";
function create_else_block_1(ctx) {
  let td;
  let td_class_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  let td_levels = [
    {
      class: td_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-data-table__cell": true,
        "mdc-data-table__cell--numeric": (
          /*numeric*/
          ctx[2]
        ),
        "mdc-data-table__cell--checkbox": (
          /*checkbox*/
          ctx[3]
        ),
        .../*internalClasses*/
        ctx[7]
      })
    },
    /*internalAttrs*/
    ctx[8],
    /*$$restProps*/
    ctx[19]
  ];
  let td_data = {};
  for (let i = 0; i < td_levels.length; i += 1) {
    td_data = assign(td_data, td_levels[i]);
  }
  const block = {
    c: function create() {
      td = element("td");
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      td = claim_element(nodes, "TD", { class: true });
      var td_nodes = children(td);
      if (default_slot)
        default_slot.l(td_nodes);
      td_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(td, td_data);
      add_location(td, file5, 43, 2, 1231);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, td, anchor);
      if (default_slot) {
        default_slot.m(td, null);
      }
      ctx[25](td);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            td,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[11].call(null, td)),
          listen_dev(
            td,
            "change",
            /*change_handler_1*/
            ctx[26],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(td, td_data = get_spread_update(td_levels, [
        (!current || dirty & /*className, numeric, checkbox, internalClasses*/
        142 && td_class_value !== (td_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-data-table__cell": true,
          "mdc-data-table__cell--numeric": (
            /*numeric*/
            ctx2[2]
          ),
          "mdc-data-table__cell--checkbox": (
            /*checkbox*/
            ctx2[3]
          ),
          .../*internalClasses*/
          ctx2[7]
        }))) && { class: td_class_value },
        dirty & /*internalAttrs*/
        256 && /*internalAttrs*/
        ctx2[8],
        dirty & /*$$restProps*/
        524288 && /*$$restProps*/
        ctx2[19]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(td);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[25](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block_1.name,
    type: "else",
    source: "(43:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block2(ctx) {
  let th;
  let current_block_type_index;
  let if_block;
  let th_class_value;
  let th_aria_sort_value;
  let useActions_action;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block_1, create_else_block];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*sortable*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  let th_levels = [
    {
      class: th_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-data-table__header-cell": true,
        "mdc-data-table__header-cell--numeric": (
          /*numeric*/
          ctx[2]
        ),
        "mdc-data-table__header-cell--checkbox": (
          /*checkbox*/
          ctx[3]
        ),
        "mdc-data-table__header-cell--with-sort": (
          /*sortable*/
          ctx[5]
        ),
        "mdc-data-table__header-cell--sorted": (
          /*sortable*/
          ctx[5] && /*$sort*/
          ctx[9] === /*columnId*/
          ctx[4]
        ),
        .../*internalClasses*/
        ctx[7]
      })
    },
    { role: "columnheader" },
    { scope: "col" },
    { "data-column-id": (
      /*columnId*/
      ctx[4]
    ) },
    {
      "aria-sort": th_aria_sort_value = /*sortable*/
      ctx[5] ? (
        /*$sort*/
        ctx[9] === /*columnId*/
        ctx[4] ? (
          /*$sortDirection*/
          ctx[10]
        ) : "none"
      ) : void 0
    },
    /*internalAttrs*/
    ctx[8],
    /*$$restProps*/
    ctx[19]
  ];
  let th_data = {};
  for (let i = 0; i < th_levels.length; i += 1) {
    th_data = assign(th_data, th_levels[i]);
  }
  const block = {
    c: function create() {
      th = element("th");
      if_block.c();
      this.h();
    },
    l: function claim(nodes) {
      th = claim_element(nodes, "TH", {
        class: true,
        role: true,
        scope: true,
        "data-column-id": true,
        "aria-sort": true
      });
      var th_nodes = children(th);
      if_block.l(th_nodes);
      th_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      set_attributes(th, th_data);
      add_location(th, file5, 1, 2, 15);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, th, anchor);
      if_blocks[current_block_type_index].m(th, null);
      ctx[23](th);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            th,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[11].call(null, th)),
          listen_dev(
            th,
            "change",
            /*change_handler*/
            ctx[24],
            false,
            false,
            false,
            false
          )
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(th, null);
      }
      set_attributes(th, th_data = get_spread_update(th_levels, [
        (!current || dirty & /*className, numeric, checkbox, sortable, $sort, columnId, internalClasses*/
        702 && th_class_value !== (th_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-data-table__header-cell": true,
          "mdc-data-table__header-cell--numeric": (
            /*numeric*/
            ctx2[2]
          ),
          "mdc-data-table__header-cell--checkbox": (
            /*checkbox*/
            ctx2[3]
          ),
          "mdc-data-table__header-cell--with-sort": (
            /*sortable*/
            ctx2[5]
          ),
          "mdc-data-table__header-cell--sorted": (
            /*sortable*/
            ctx2[5] && /*$sort*/
            ctx2[9] === /*columnId*/
            ctx2[4]
          ),
          .../*internalClasses*/
          ctx2[7]
        }))) && { class: th_class_value },
        { role: "columnheader" },
        { scope: "col" },
        (!current || dirty & /*columnId*/
        16) && { "data-column-id": (
          /*columnId*/
          ctx2[4]
        ) },
        (!current || dirty & /*sortable, $sort, columnId, $sortDirection*/
        1584 && th_aria_sort_value !== (th_aria_sort_value = /*sortable*/
        ctx2[5] ? (
          /*$sort*/
          ctx2[9] === /*columnId*/
          ctx2[4] ? (
            /*$sortDirection*/
            ctx2[10]
          ) : "none"
        ) : void 0)) && { "aria-sort": th_aria_sort_value },
        dirty & /*internalAttrs*/
        256 && /*internalAttrs*/
        ctx2[8],
        dirty & /*$$restProps*/
        524288 && /*$$restProps*/
        ctx2[19]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(th);
      }
      if_blocks[current_block_type_index].d();
      ctx[23](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block2.name,
    type: "if",
    source: "(1:0) {#if header}",
    ctx
  });
  return block;
}
function create_else_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create() {
      if (default_slot)
        default_slot.c();
    },
    l: function claim(nodes) {
      if (default_slot)
        default_slot.l(nodes);
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(41:4) {:else}",
    ctx
  });
  return block;
}
function create_if_block_1(ctx) {
  let div1;
  let t0;
  let div0;
  let t1_value = (
    /*$sort*/
    (ctx[9] === /*columnId*/
    ctx[4] ? (
      /*$sortDirection*/
      ctx[10] === "ascending" ? (
        /*sortAscendingAriaLabel*/
        ctx[15]
      ) : (
        /*sortDescendingAriaLabel*/
        ctx[16]
      )
    ) : "") + ""
  );
  let t1;
  let div0_id_value;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[22].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[21],
    null
  );
  const block = {
    c: function create() {
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      t0 = space();
      div0 = element("div");
      t1 = text(t1_value);
      this.h();
    },
    l: function claim(nodes) {
      div1 = claim_element(nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (default_slot)
        default_slot.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", {
        class: true,
        "aria-hidden": true,
        id: true
      });
      var div0_nodes = children(div0);
      t1 = claim_text(div0_nodes, t1_value);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "mdc-data-table__sort-status-label");
      attr_dev(div0, "aria-hidden", "true");
      attr_dev(div0, "id", div0_id_value = /*columnId*/
      ctx[4] + "-status-label");
      add_location(div0, file5, 28, 8, 853);
      attr_dev(div1, "class", "mdc-data-table__header-cell-wrapper");
      add_location(div1, file5, 26, 6, 778);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div1, anchor);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      append_hydration_dev(div0, t1);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2097152)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[21],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[21]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[21],
              dirty,
              null
            ),
            null
          );
        }
      }
      if ((!current || dirty & /*$sort, columnId, $sortDirection*/
      1552) && t1_value !== (t1_value = /*$sort*/
      (ctx2[9] === /*columnId*/
      ctx2[4] ? (
        /*$sortDirection*/
        ctx2[10] === "ascending" ? (
          /*sortAscendingAriaLabel*/
          ctx2[15]
        ) : (
          /*sortDescendingAriaLabel*/
          ctx2[16]
        )
      ) : "") + ""))
        set_data_dev(t1, t1_value);
      if (!current || dirty & /*columnId*/
      16 && div0_id_value !== (div0_id_value = /*columnId*/
      ctx2[4] + "-status-label")) {
        attr_dev(div0, "id", div0_id_value);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div1);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_1.name,
    type: "if",
    source: "(26:5) {#if sortable}",
    ctx
  });
  return block;
}
function create_fragment5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*header*/
      ctx2[12]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      if_block.l(nodes);
      if_block_anchor = empty();
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_hydration_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      if_block.p(ctx2, dirty);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment5.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
var counter2 = 0;
function instance4($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "numeric", "checkbox", "columnId", "sortable", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let $sort;
  let $sortDirection;
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Cell", slots, ["default"]);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let header = getContext("SMUI:data-table:row:header");
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { numeric = false } = $$props;
  let { checkbox = false } = $$props;
  let { columnId = header ? "SMUI-data-table-column-" + counter2++ : "SMUI-data-table-unused" } = $$props;
  let { sortable = getContext("SMUI:data-table:sortable") } = $$props;
  let element2;
  let internalClasses = {};
  let internalAttrs = {};
  let sort = getContext("SMUI:data-table:sort");
  validate_store(sort, "sort");
  component_subscribe($$self, sort, (value) => $$invalidate(9, $sort = value));
  let sortDirection = getContext("SMUI:data-table:sortDirection");
  validate_store(sortDirection, "sortDirection");
  component_subscribe($$self, sortDirection, (value) => $$invalidate(10, $sortDirection = value));
  let sortAscendingAriaLabel = getContext("SMUI:data-table:sortAscendingAriaLabel");
  let sortDescendingAriaLabel = getContext("SMUI:data-table:sortDescendingAriaLabel");
  if (sortable) {
    setContext("SMUI:label:context", "data-table:sortable-header-cell");
    setContext("SMUI:icon-button:context", "data-table:sortable-header-cell");
    setContext("SMUI:icon-button:aria-describedby", columnId + "-status-label");
  }
  onMount(() => {
    const accessor = header ? {
      _smui_data_table_header_cell_accessor: true,
      get element() {
        return getElement();
      },
      get columnId() {
        return columnId;
      },
      addClass,
      removeClass,
      getAttr,
      addAttr
    } : {
      _smui_data_table_header_cell_accessor: false,
      get element() {
        return getElement();
      },
      get columnId() {
        return void 0;
      },
      addClass,
      removeClass,
      getAttr,
      addAttr
    };
    dispatch(getElement(), "SMUIDataTableCell:mount", accessor);
    return () => {
      dispatch(getElement(), "SMUIDataTableCell:unmount", accessor);
    };
  });
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(7, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(7, internalClasses[className2] = false, internalClasses);
    }
  }
  function getAttr(name) {
    var _a;
    return name in internalAttrs ? (_a = internalAttrs[name]) !== null && _a !== void 0 ? _a : null : getElement().getAttribute(name);
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(8, internalAttrs[name] = value, internalAttrs);
    }
  }
  function notifyHeaderChange(event) {
    dispatch(getElement(), "SMUIDataTableHeaderCheckbox:change", event);
  }
  function notifyBodyChange(event) {
    dispatch(getElement(), "SMUIDataTableBodyCheckbox:change", event);
  }
  function getElement() {
    return element2;
  }
  function th_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(6, element2);
    });
  }
  const change_handler = (event) => checkbox && notifyHeaderChange(event);
  function td_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(6, element2);
    });
  }
  const change_handler_1 = (event) => checkbox && notifyBodyChange(event);
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(19, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("numeric" in $$new_props)
      $$invalidate(2, numeric = $$new_props.numeric);
    if ("checkbox" in $$new_props)
      $$invalidate(3, checkbox = $$new_props.checkbox);
    if ("columnId" in $$new_props)
      $$invalidate(4, columnId = $$new_props.columnId);
    if ("sortable" in $$new_props)
      $$invalidate(5, sortable = $$new_props.sortable);
    if ("$$scope" in $$new_props)
      $$invalidate(21, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    counter: counter2,
    onMount,
    getContext,
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    dispatch,
    forwardEvents,
    header,
    use,
    className,
    numeric,
    checkbox,
    columnId,
    sortable,
    element: element2,
    internalClasses,
    internalAttrs,
    sort,
    sortDirection,
    sortAscendingAriaLabel,
    sortDescendingAriaLabel,
    addClass,
    removeClass,
    getAttr,
    addAttr,
    notifyHeaderChange,
    notifyBodyChange,
    getElement,
    $sort,
    $sortDirection
  });
  $$self.$inject_state = ($$new_props) => {
    if ("header" in $$props)
      $$invalidate(12, header = $$new_props.header);
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("numeric" in $$props)
      $$invalidate(2, numeric = $$new_props.numeric);
    if ("checkbox" in $$props)
      $$invalidate(3, checkbox = $$new_props.checkbox);
    if ("columnId" in $$props)
      $$invalidate(4, columnId = $$new_props.columnId);
    if ("sortable" in $$props)
      $$invalidate(5, sortable = $$new_props.sortable);
    if ("element" in $$props)
      $$invalidate(6, element2 = $$new_props.element);
    if ("internalClasses" in $$props)
      $$invalidate(7, internalClasses = $$new_props.internalClasses);
    if ("internalAttrs" in $$props)
      $$invalidate(8, internalAttrs = $$new_props.internalAttrs);
    if ("sort" in $$props)
      $$invalidate(13, sort = $$new_props.sort);
    if ("sortDirection" in $$props)
      $$invalidate(14, sortDirection = $$new_props.sortDirection);
    if ("sortAscendingAriaLabel" in $$props)
      $$invalidate(15, sortAscendingAriaLabel = $$new_props.sortAscendingAriaLabel);
    if ("sortDescendingAriaLabel" in $$props)
      $$invalidate(16, sortDescendingAriaLabel = $$new_props.sortDescendingAriaLabel);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    numeric,
    checkbox,
    columnId,
    sortable,
    element2,
    internalClasses,
    internalAttrs,
    $sort,
    $sortDirection,
    forwardEvents,
    header,
    sort,
    sortDirection,
    sortAscendingAriaLabel,
    sortDescendingAriaLabel,
    notifyHeaderChange,
    notifyBodyChange,
    $$restProps,
    getElement,
    $$scope,
    slots,
    th_binding,
    change_handler,
    td_binding,
    change_handler_1
  ];
}
var Cell = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance4, create_fragment5, safe_not_equal, {
      use: 0,
      class: 1,
      numeric: 2,
      checkbox: 3,
      columnId: 4,
      sortable: 5,
      getElement: 20
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Cell",
      options,
      id: create_fragment5.name
    });
  }
  get use() {
    throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get numeric() {
    throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set numeric(value) {
    throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get checkbox() {
    throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set checkbox(value) {
    throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get columnId() {
    throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set columnId(value) {
    throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get sortable() {
    throw new Error("<Cell>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set sortable(value) {
    throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[20];
  }
  set getElement(value) {
    throw new Error("<Cell>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Cell_default = Cell;

// node_modules/@smui/data-table/dist/Pagination.svelte
var file6 = "node_modules/@smui/data-table/dist/Pagination.svelte";
var get_total_slot_changes = (dirty) => ({});
var get_total_slot_context = (ctx) => ({});
var get_rowsPerPage_slot_changes = (dirty) => ({});
var get_rowsPerPage_slot_context = (ctx) => ({});
function create_if_block_12(ctx) {
  let div;
  let current;
  const rowsPerPage_slot_template = (
    /*#slots*/
    ctx[10].rowsPerPage
  );
  const rowsPerPage_slot = create_slot(
    rowsPerPage_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_rowsPerPage_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (rowsPerPage_slot)
        rowsPerPage_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (rowsPerPage_slot)
        rowsPerPage_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "mdc-data-table__pagination-rows-per-page");
      add_location(div, file6, 19, 6, 444);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (rowsPerPage_slot) {
        rowsPerPage_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (rowsPerPage_slot) {
        if (rowsPerPage_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            rowsPerPage_slot,
            rowsPerPage_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              rowsPerPage_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_rowsPerPage_slot_changes
            ),
            get_rowsPerPage_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(rowsPerPage_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(rowsPerPage_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (rowsPerPage_slot)
        rowsPerPage_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block_12.name,
    type: "if",
    source: "(19:4) {#if $$slots.rowsPerPage}",
    ctx
  });
  return block;
}
function create_if_block3(ctx) {
  let div;
  let current;
  const total_slot_template = (
    /*#slots*/
    ctx[10].total
  );
  const total_slot = create_slot(
    total_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    get_total_slot_context
  );
  const block = {
    c: function create() {
      div = element("div");
      if (total_slot)
        total_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div = claim_element(nodes, "DIV", { class: true });
      var div_nodes = children(div);
      if (total_slot)
        total_slot.l(div_nodes);
      div_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div, "class", "mdc-data-table__pagination-total");
      add_location(div, file6, 26, 8, 649);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div, anchor);
      if (total_slot) {
        total_slot.m(div, null);
      }
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (total_slot) {
        if (total_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            total_slot,
            total_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              total_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              get_total_slot_changes
            ),
            get_total_slot_context
          );
        }
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(total_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(total_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div);
      }
      if (total_slot)
        total_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block3.name,
    type: "if",
    source: "(26:6) {#if $$slots.total}",
    ctx
  });
  return block;
}
function create_fragment6(ctx) {
  let div2;
  let div1;
  let t0;
  let div0;
  let t1;
  let div1_class_value;
  let useActions_action;
  let div2_class_value;
  let useActions_action_1;
  let forwardEvents_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[7].rowsPerPage && create_if_block_12(ctx)
  );
  let if_block1 = (
    /*$$slots*/
    ctx[7].total && create_if_block3(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[10].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[9],
    null
  );
  let div1_levels = [
    {
      class: div1_class_value = classMap({
        [
          /*trailing$class*/
          ctx[3]
        ]: true,
        "mdc-data-table__pagination-trailing": true
      })
    },
    prefixFilter(
      /*$$restProps*/
      ctx[6],
      "trailing$"
    )
  ];
  let div_data_1 = {};
  for (let i = 0; i < div1_levels.length; i += 1) {
    div_data_1 = assign(div_data_1, div1_levels[i]);
  }
  let div2_levels = [
    {
      class: div2_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-data-table__pagination": true
      })
    },
    exclude(
      /*$$restProps*/
      ctx[6],
      ["trailing$"]
    )
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      div0 = element("div");
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (default_slot)
        default_slot.c();
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      if (if_block0)
        if_block0.l(div1_nodes);
      t0 = claim_space(div1_nodes);
      div0 = claim_element(div1_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      if (if_block1)
        if_block1.l(div0_nodes);
      t1 = claim_space(div0_nodes);
      if (default_slot)
        default_slot.l(div0_nodes);
      div0_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(div0, "class", "mdc-data-table__pagination-navigation");
      add_location(div0, file6, 24, 4, 563);
      set_attributes(div1, div_data_1);
      add_location(div1, file6, 10, 2, 206);
      set_attributes(div2, div_data_2);
      add_location(div2, file6, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append_hydration_dev(div1, t0);
      append_hydration_dev(div1, div0);
      if (if_block1)
        if_block1.m(div0, null);
      append_hydration_dev(div0, t1);
      if (default_slot) {
        default_slot.m(div0, null);
      }
      ctx[11](div2);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div1,
            /*trailing$use*/
            ctx[2]
          )),
          action_destroyer(useActions_action_1 = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[5].call(null, div2))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      if (
        /*$$slots*/
        ctx2[7].rowsPerPage
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_12(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*$$slots*/
        ctx2[7].total
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*$$slots*/
          128) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block3(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        512)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[9],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[9]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[9],
              dirty,
              null
            ),
            null
          );
        }
      }
      set_attributes(div1, div_data_1 = get_spread_update(div1_levels, [
        (!current || dirty & /*trailing$class*/
        8 && div1_class_value !== (div1_class_value = classMap({
          [
            /*trailing$class*/
            ctx2[3]
          ]: true,
          "mdc-data-table__pagination-trailing": true
        }))) && { class: div1_class_value },
        dirty & /*$$restProps*/
        64 && prefixFilter(
          /*$$restProps*/
          ctx2[6],
          "trailing$"
        )
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*trailing$use*/
      4)
        useActions_action.update.call(
          null,
          /*trailing$use*/
          ctx2[2]
        );
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        (!current || dirty & /*className*/
        2 && div2_class_value !== (div2_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-data-table__pagination": true
        }))) && { class: div2_class_value },
        dirty & /*$$restProps*/
        64 && exclude(
          /*$$restProps*/
          ctx2[6],
          ["trailing$"]
        )
      ]));
      if (useActions_action_1 && is_function(useActions_action_1.update) && dirty & /*use*/
      1)
        useActions_action_1.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (default_slot)
        default_slot.d(detaching);
      ctx[11](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment6.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance5($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "trailing$use", "trailing$class", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("Pagination", slots, ["rowsPerPage", "total", "default"]);
  const $$slots = compute_slots(slots);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { trailing$use = [] } = $$props;
  let { trailing$class = "" } = $$props;
  let element2;
  setContext("SMUI:label:context", "data-table:pagination");
  setContext("SMUI:select:context", "data-table:pagination");
  setContext("SMUI:icon-button:context", "data-table:pagination");
  function getElement() {
    return element2;
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(4, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(6, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("trailing$use" in $$new_props)
      $$invalidate(2, trailing$use = $$new_props.trailing$use);
    if ("trailing$class" in $$new_props)
      $$invalidate(3, trailing$class = $$new_props.trailing$class);
    if ("$$scope" in $$new_props)
      $$invalidate(9, $$scope = $$new_props.$$scope);
  };
  $$self.$capture_state = () => ({
    setContext,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    exclude,
    prefixFilter,
    useActions,
    forwardEvents,
    use,
    className,
    trailing$use,
    trailing$class,
    element: element2,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("trailing$use" in $$props)
      $$invalidate(2, trailing$use = $$new_props.trailing$use);
    if ("trailing$class" in $$props)
      $$invalidate(3, trailing$class = $$new_props.trailing$class);
    if ("element" in $$props)
      $$invalidate(4, element2 = $$new_props.element);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    use,
    className,
    trailing$use,
    trailing$class,
    element2,
    forwardEvents,
    $$restProps,
    $$slots,
    getElement,
    $$scope,
    slots,
    div2_binding
  ];
}
var Pagination = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance5, create_fragment6, safe_not_equal, {
      use: 0,
      class: 1,
      trailing$use: 2,
      trailing$class: 3,
      getElement: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Pagination",
      options,
      id: create_fragment6.name
    });
  }
  get use() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trailing$use() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trailing$use(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get trailing$class() {
    throw new Error("<Pagination>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set trailing$class(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[8];
  }
  set getElement(value) {
    throw new Error("<Pagination>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var Pagination_default = Pagination;

// node_modules/@smui/data-table/dist/index.js
var dist_default = DataTable_default;
export {
  Body_default as Body,
  Cell_default as Cell,
  Head_default as Head,
  CommonLabel_default as Label,
  Pagination_default as Pagination,
  Row_default as Row,
  SortValue,
  dist_default as default
};
//# sourceMappingURL=@smui_data-table.js.map
