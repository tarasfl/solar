import {
  classMap,
  forwardEventsBuilder,
  useActions
} from "./chunk-DXJYLXNN.js";
import {
  MDCCircularProgressFoundation
} from "./chunk-4WQRQSIZ.js";
import "./chunk-ZB6PEJPW.js";
import "./chunk-X7HCJ7ZS.js";
import "./chunk-ODRA5LQH.js";
import "./chunk-X43LXICK.js";
import {
  SvelteComponentDev,
  action_destroyer,
  add_location,
  append_hydration_dev,
  assign,
  attr_dev,
  binding_callbacks,
  children,
  claim_element,
  claim_space,
  claim_svg_element,
  compute_rest_props,
  destroy_each,
  detach_dev,
  dispatch_dev,
  element,
  ensure_array_like_dev,
  exclude_internal_props,
  get_current_component,
  get_spread_update,
  init,
  insert_hydration_dev,
  is_function,
  noop,
  onMount,
  run_all,
  safe_not_equal,
  set_attributes,
  set_svg_attributes,
  space,
  svg_element,
  validate_slots
} from "./chunk-NMMN3PC6.js";
import "./chunk-4DGM7FRE.js";
import "./chunk-7U33LM2Z.js";

// node_modules/@smui/circular-progress/dist/CircularProgress.svelte
var file = "node_modules/@smui/circular-progress/dist/CircularProgress.svelte";
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let div3;
  let div0;
  let svg0;
  let circle0;
  let t0;
  let div1;
  let svg1;
  let circle1;
  let t1;
  let div2;
  let svg2;
  let circle2;
  let t2;
  let div3_class_value;
  const block = {
    c: function create() {
      div3 = element("div");
      div0 = element("div");
      svg0 = svg_element("svg");
      circle0 = svg_element("circle");
      t0 = space();
      div1 = element("div");
      svg1 = svg_element("svg");
      circle1 = svg_element("circle");
      t1 = space();
      div2 = element("div");
      svg2 = svg_element("svg");
      circle2 = svg_element("circle");
      t2 = space();
      this.h();
    },
    l: function claim(nodes) {
      div3 = claim_element(nodes, "DIV", { class: true });
      var div3_nodes = children(div3);
      div0 = claim_element(div3_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      svg0 = claim_svg_element(div0_nodes, "svg", { class: true, viewBox: true, xmlns: true });
      var svg0_nodes = children(svg0);
      circle0 = claim_svg_element(svg0_nodes, "circle", {
        cx: true,
        cy: true,
        r: true,
        "stroke-dasharray": true,
        "stroke-dashoffset": true,
        "stroke-width": true
      });
      children(circle0).forEach(detach_dev);
      svg0_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t0 = claim_space(div3_nodes);
      div1 = claim_element(div3_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      svg1 = claim_svg_element(div1_nodes, "svg", { class: true, viewBox: true, xmlns: true });
      var svg1_nodes = children(svg1);
      circle1 = claim_svg_element(svg1_nodes, "circle", {
        cx: true,
        cy: true,
        r: true,
        "stroke-dasharray": true,
        "stroke-dashoffset": true,
        "stroke-width": true
      });
      children(circle1).forEach(detach_dev);
      svg1_nodes.forEach(detach_dev);
      div1_nodes.forEach(detach_dev);
      t1 = claim_space(div3_nodes);
      div2 = claim_element(div3_nodes, "DIV", { class: true });
      var div2_nodes = children(div2);
      svg2 = claim_svg_element(div2_nodes, "svg", { class: true, viewBox: true, xmlns: true });
      var svg2_nodes = children(svg2);
      circle2 = claim_svg_element(svg2_nodes, "circle", {
        cx: true,
        cy: true,
        r: true,
        "stroke-dasharray": true,
        "stroke-dashoffset": true,
        "stroke-width": true
      });
      children(circle2).forEach(detach_dev);
      svg2_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      t2 = claim_space(div3_nodes);
      div3_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "cx", "24");
      attr_dev(circle0, "cy", "24");
      attr_dev(circle0, "r", "18");
      attr_dev(circle0, "stroke-dasharray", "113.097");
      attr_dev(circle0, "stroke-dashoffset", "56.549");
      attr_dev(circle0, "stroke-width", "4");
      add_location(circle0, file, 61, 12, 1742);
      attr_dev(svg0, "class", "mdc-circular-progress__indeterminate-circle-graphic");
      attr_dev(svg0, "viewBox", "0 0 48 48");
      attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg0, file, 56, 10, 1562);
      attr_dev(div0, "class", "mdc-circular-progress__circle-clipper mdc-circular-progress__circle-left");
      add_location(div0, file, 53, 8, 1446);
      attr_dev(circle1, "cx", "24");
      attr_dev(circle1, "cy", "24");
      attr_dev(circle1, "r", "18");
      attr_dev(circle1, "stroke-dasharray", "113.097");
      attr_dev(circle1, "stroke-dashoffset", "56.549");
      attr_dev(circle1, "stroke-width", "3.2");
      add_location(circle1, file, 77, 12, 2220);
      attr_dev(svg1, "class", "mdc-circular-progress__indeterminate-circle-graphic");
      attr_dev(svg1, "viewBox", "0 0 48 48");
      attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg1, file, 72, 10, 2040);
      attr_dev(div1, "class", "mdc-circular-progress__gap-patch");
      add_location(div1, file, 71, 8, 1983);
      attr_dev(circle2, "cx", "24");
      attr_dev(circle2, "cy", "24");
      attr_dev(circle2, "r", "18");
      attr_dev(circle2, "stroke-dasharray", "113.097");
      attr_dev(circle2, "stroke-dashoffset", "56.549");
      attr_dev(circle2, "stroke-width", "4");
      add_location(circle2, file, 95, 12, 2760);
      attr_dev(svg2, "class", "mdc-circular-progress__indeterminate-circle-graphic");
      attr_dev(svg2, "viewBox", "0 0 48 48");
      attr_dev(svg2, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg2, file, 90, 10, 2580);
      attr_dev(div2, "class", "mdc-circular-progress__circle-clipper mdc-circular-progress__circle-right");
      add_location(div2, file, 87, 8, 2463);
      attr_dev(div3, "class", div3_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-circular-progress__spinner-layer": true,
        ["mdc-circular-progress__color-" + /*color*/
        ctx[24]]: (
          /*fourColor*/
          ctx[5]
        )
      }));
      add_location(div3, file, 46, 6, 1238);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div3, anchor);
      append_hydration_dev(div3, div0);
      append_hydration_dev(div0, svg0);
      append_hydration_dev(svg0, circle0);
      append_hydration_dev(div3, t0);
      append_hydration_dev(div3, div1);
      append_hydration_dev(div1, svg1);
      append_hydration_dev(svg1, circle1);
      append_hydration_dev(div3, t1);
      append_hydration_dev(div3, div2);
      append_hydration_dev(div2, svg2);
      append_hydration_dev(svg2, circle2);
      append_hydration_dev(div3, t2);
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*className, fourColor*/
      34 && div3_class_value !== (div3_class_value = classMap({
        [
          /*className*/
          ctx2[1]
        ]: true,
        "mdc-circular-progress__spinner-layer": true,
        ["mdc-circular-progress__color-" + /*color*/
        ctx2[24]]: (
          /*fourColor*/
          ctx2[5]
        )
      }))) {
        attr_dev(div3, "class", div3_class_value);
      }
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div3);
      }
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(46:4) {#each fourColor ? [1, 2, 3, 4] : [1] as color}",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let div2;
  let div0;
  let svg;
  let circle0;
  let circle1;
  let t;
  let div1;
  let div2_class_value;
  let div2_aria_valuemin_value;
  let div2_aria_valuemax_value;
  let div2_aria_valuenow_value;
  let useActions_action;
  let forwardEvents_action;
  let mounted;
  let dispose;
  let circle1_levels = [
    {
      class: "mdc-circular-progress__determinate-circle"
    },
    { cx: "24" },
    { cy: "24" },
    { r: "18" },
    { "stroke-dasharray": "113.097" },
    { "stroke-dashoffset": "113.097" },
    { "stroke-width": "4" },
    /*determinateCircleAttrs*/
    ctx[9]
  ];
  let circle_data = {};
  for (let i = 0; i < circle1_levels.length; i += 1) {
    circle_data = assign(circle_data, circle1_levels[i]);
  }
  let each_value = ensure_array_like_dev(
    /*fourColor*/
    ctx[5] ? [1, 2, 3, 4] : [1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let div2_levels = [
    {
      class: div2_class_value = classMap({
        [
          /*className*/
          ctx[1]
        ]: true,
        "mdc-circular-progress": true,
        "mdc-circular-progress--indeterminate": (
          /*indeterminate*/
          ctx[2]
        ),
        "mdc-circular-progress--closed": (
          /*closed*/
          ctx[3]
        ),
        .../*internalClasses*/
        ctx[7]
      })
    },
    { role: "progressbar" },
    {
      "aria-valuemin": div2_aria_valuemin_value = 0
    },
    {
      "aria-valuemax": div2_aria_valuemax_value = 1
    },
    {
      "aria-valuenow": div2_aria_valuenow_value = /*indeterminate*/
      ctx[2] ? void 0 : (
        /*progress*/
        ctx[4]
      )
    },
    /*internalAttrs*/
    ctx[8],
    /*$$restProps*/
    ctx[12]
  ];
  let div_data_2 = {};
  for (let i = 0; i < div2_levels.length; i += 1) {
    div_data_2 = assign(div_data_2, div2_levels[i]);
  }
  const block = {
    c: function create() {
      div2 = element("div");
      div0 = element("div");
      svg = svg_element("svg");
      circle0 = svg_element("circle");
      circle1 = svg_element("circle");
      t = space();
      div1 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      this.h();
    },
    l: function claim(nodes) {
      div2 = claim_element(nodes, "DIV", {
        class: true,
        role: true,
        "aria-valuemin": true,
        "aria-valuemax": true,
        "aria-valuenow": true
      });
      var div2_nodes = children(div2);
      div0 = claim_element(div2_nodes, "DIV", { class: true });
      var div0_nodes = children(div0);
      svg = claim_svg_element(div0_nodes, "svg", { class: true, viewBox: true, xmlns: true });
      var svg_nodes = children(svg);
      circle0 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        cx: true,
        cy: true,
        r: true,
        "stroke-width": true
      });
      children(circle0).forEach(detach_dev);
      circle1 = claim_svg_element(svg_nodes, "circle", {
        class: true,
        cx: true,
        cy: true,
        r: true,
        "stroke-dasharray": true,
        "stroke-dashoffset": true,
        "stroke-width": true
      });
      children(circle1).forEach(detach_dev);
      svg_nodes.forEach(detach_dev);
      div0_nodes.forEach(detach_dev);
      t = claim_space(div2_nodes);
      div1 = claim_element(div2_nodes, "DIV", { class: true });
      var div1_nodes = children(div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].l(div1_nodes);
      }
      div1_nodes.forEach(detach_dev);
      div2_nodes.forEach(detach_dev);
      this.h();
    },
    h: function hydrate() {
      attr_dev(circle0, "class", "mdc-circular-progress__determinate-track");
      attr_dev(circle0, "cx", "24");
      attr_dev(circle0, "cy", "24");
      attr_dev(circle0, "r", "18");
      attr_dev(circle0, "stroke-width", "4");
      add_location(circle0, file, 24, 6, 653);
      set_svg_attributes(circle1, circle_data);
      add_location(circle1, file, 31, 6, 805);
      attr_dev(svg, "class", "mdc-circular-progress__determinate-circle-graphic");
      attr_dev(svg, "viewBox", "0 0 48 48");
      attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
      add_location(svg, file, 19, 4, 505);
      attr_dev(div0, "class", "mdc-circular-progress__determinate-container");
      add_location(div0, file, 18, 2, 442);
      attr_dev(div1, "class", "mdc-circular-progress__indeterminate-container");
      add_location(div1, file, 44, 2, 1119);
      set_attributes(div2, div_data_2);
      add_location(div2, file, 0, 0, 0);
    },
    m: function mount(target, anchor) {
      insert_hydration_dev(target, div2, anchor);
      append_hydration_dev(div2, div0);
      append_hydration_dev(div0, svg);
      append_hydration_dev(svg, circle0);
      append_hydration_dev(svg, circle1);
      ctx[15](circle1);
      append_hydration_dev(div2, t);
      append_hydration_dev(div2, div1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      ctx[16](div2);
      if (!mounted) {
        dispose = [
          action_destroyer(useActions_action = useActions.call(
            null,
            div2,
            /*use*/
            ctx[0]
          )),
          action_destroyer(forwardEvents_action = /*forwardEvents*/
          ctx[11].call(null, div2))
        ];
        mounted = true;
      }
    },
    p: function update(ctx2, [dirty]) {
      set_svg_attributes(circle1, circle_data = get_spread_update(circle1_levels, [
        {
          class: "mdc-circular-progress__determinate-circle"
        },
        { cx: "24" },
        { cy: "24" },
        { r: "18" },
        { "stroke-dasharray": "113.097" },
        { "stroke-dashoffset": "113.097" },
        { "stroke-width": "4" },
        dirty & /*determinateCircleAttrs*/
        512 && /*determinateCircleAttrs*/
        ctx2[9]
      ]));
      if (dirty & /*className, fourColor*/
      34) {
        each_value = ensure_array_like_dev(
          /*fourColor*/
          ctx2[5] ? [1, 2, 3, 4] : [1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      set_attributes(div2, div_data_2 = get_spread_update(div2_levels, [
        dirty & /*className, indeterminate, closed, internalClasses*/
        142 && div2_class_value !== (div2_class_value = classMap({
          [
            /*className*/
            ctx2[1]
          ]: true,
          "mdc-circular-progress": true,
          "mdc-circular-progress--indeterminate": (
            /*indeterminate*/
            ctx2[2]
          ),
          "mdc-circular-progress--closed": (
            /*closed*/
            ctx2[3]
          ),
          .../*internalClasses*/
          ctx2[7]
        })) && { class: div2_class_value },
        { role: "progressbar" },
        {
          "aria-valuemin": div2_aria_valuemin_value
        },
        {
          "aria-valuemax": div2_aria_valuemax_value
        },
        dirty & /*indeterminate, progress*/
        20 && div2_aria_valuenow_value !== (div2_aria_valuenow_value = /*indeterminate*/
        ctx2[2] ? void 0 : (
          /*progress*/
          ctx2[4]
        )) && {
          "aria-valuenow": div2_aria_valuenow_value
        },
        dirty & /*internalAttrs*/
        256 && /*internalAttrs*/
        ctx2[8],
        dirty & /*$$restProps*/
        4096 && /*$$restProps*/
        ctx2[12]
      ]));
      if (useActions_action && is_function(useActions_action.update) && dirty & /*use*/
      1)
        useActions_action.update.call(
          null,
          /*use*/
          ctx2[0]
        );
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(div2);
      }
      ctx[15](null);
      destroy_each(each_blocks, detaching);
      ctx[16](null);
      mounted = false;
      run_all(dispose);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  const omit_props_names = ["use", "class", "indeterminate", "closed", "progress", "fourColor", "getElement"];
  let $$restProps = compute_rest_props($$props, omit_props_names);
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("CircularProgress", slots, []);
  const forwardEvents = forwardEventsBuilder(get_current_component());
  let { use = [] } = $$props;
  let { class: className = "" } = $$props;
  let { indeterminate = false } = $$props;
  let { closed = false } = $$props;
  let { progress = 0 } = $$props;
  let { fourColor = false } = $$props;
  let element2;
  let instance;
  let internalClasses = {};
  let internalAttrs = {};
  let determinateCircleAttrs = {};
  let determinateCircle;
  onMount(() => {
    $$invalidate(14, instance = new MDCCircularProgressFoundation({
      addClass,
      getDeterminateCircleAttribute: getDeterminateCircleAttr,
      hasClass,
      removeClass,
      removeAttribute: removeAttr,
      setAttribute: addAttr,
      setDeterminateCircleAttribute: addDeterminateCircleAttr
    }));
    instance.init();
    return () => {
      instance.destroy();
    };
  });
  function hasClass(className2) {
    return className2 in internalClasses ? internalClasses[className2] : getElement().classList.contains(className2);
  }
  function addClass(className2) {
    if (!internalClasses[className2]) {
      $$invalidate(7, internalClasses[className2] = true, internalClasses);
    }
  }
  function removeClass(className2) {
    if (!(className2 in internalClasses) || internalClasses[className2]) {
      $$invalidate(7, internalClasses[className2] = false, internalClasses);
    }
  }
  function addAttr(name, value) {
    if (internalAttrs[name] !== value) {
      $$invalidate(8, internalAttrs[name] = value, internalAttrs);
    }
  }
  function removeAttr(name) {
    if (!(name in internalAttrs) || internalAttrs[name] != null) {
      $$invalidate(8, internalAttrs[name] = void 0, internalAttrs);
    }
  }
  function getDeterminateCircleAttr(name) {
    var _a;
    return name in determinateCircleAttrs ? (_a = determinateCircleAttrs[name]) !== null && _a !== void 0 ? _a : null : determinateCircle.getAttribute(name);
  }
  function addDeterminateCircleAttr(name, value) {
    if (determinateCircleAttrs[name] !== value) {
      $$invalidate(9, determinateCircleAttrs[name] = value, determinateCircleAttrs);
    }
  }
  function getElement() {
    return element2;
  }
  function circle1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      determinateCircle = $$value;
      $$invalidate(10, determinateCircle);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(6, element2);
    });
  }
  $$self.$$set = ($$new_props) => {
    $$props = assign(assign({}, $$props), exclude_internal_props($$new_props));
    $$invalidate(12, $$restProps = compute_rest_props($$props, omit_props_names));
    if ("use" in $$new_props)
      $$invalidate(0, use = $$new_props.use);
    if ("class" in $$new_props)
      $$invalidate(1, className = $$new_props.class);
    if ("indeterminate" in $$new_props)
      $$invalidate(2, indeterminate = $$new_props.indeterminate);
    if ("closed" in $$new_props)
      $$invalidate(3, closed = $$new_props.closed);
    if ("progress" in $$new_props)
      $$invalidate(4, progress = $$new_props.progress);
    if ("fourColor" in $$new_props)
      $$invalidate(5, fourColor = $$new_props.fourColor);
  };
  $$self.$capture_state = () => ({
    MDCCircularProgressFoundation,
    onMount,
    get_current_component,
    forwardEventsBuilder,
    classMap,
    useActions,
    forwardEvents,
    use,
    className,
    indeterminate,
    closed,
    progress,
    fourColor,
    element: element2,
    instance,
    internalClasses,
    internalAttrs,
    determinateCircleAttrs,
    determinateCircle,
    hasClass,
    addClass,
    removeClass,
    addAttr,
    removeAttr,
    getDeterminateCircleAttr,
    addDeterminateCircleAttr,
    getElement
  });
  $$self.$inject_state = ($$new_props) => {
    if ("use" in $$props)
      $$invalidate(0, use = $$new_props.use);
    if ("className" in $$props)
      $$invalidate(1, className = $$new_props.className);
    if ("indeterminate" in $$props)
      $$invalidate(2, indeterminate = $$new_props.indeterminate);
    if ("closed" in $$props)
      $$invalidate(3, closed = $$new_props.closed);
    if ("progress" in $$props)
      $$invalidate(4, progress = $$new_props.progress);
    if ("fourColor" in $$props)
      $$invalidate(5, fourColor = $$new_props.fourColor);
    if ("element" in $$props)
      $$invalidate(6, element2 = $$new_props.element);
    if ("instance" in $$props)
      $$invalidate(14, instance = $$new_props.instance);
    if ("internalClasses" in $$props)
      $$invalidate(7, internalClasses = $$new_props.internalClasses);
    if ("internalAttrs" in $$props)
      $$invalidate(8, internalAttrs = $$new_props.internalAttrs);
    if ("determinateCircleAttrs" in $$props)
      $$invalidate(9, determinateCircleAttrs = $$new_props.determinateCircleAttrs);
    if ("determinateCircle" in $$props)
      $$invalidate(10, determinateCircle = $$new_props.determinateCircle);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*instance, indeterminate*/
    16388) {
      $:
        if (instance && instance.isDeterminate() !== !indeterminate) {
          instance.setDeterminate(!indeterminate);
        }
    }
    if ($$self.$$.dirty & /*instance, progress*/
    16400) {
      $:
        if (instance && instance.getProgress() !== progress) {
          instance.setProgress(progress);
        }
    }
    if ($$self.$$.dirty & /*instance, closed*/
    16392) {
      $:
        if (instance) {
          if (closed) {
            instance.close();
          } else {
            instance.open();
          }
        }
    }
  };
  return [
    use,
    className,
    indeterminate,
    closed,
    progress,
    fourColor,
    element2,
    internalClasses,
    internalAttrs,
    determinateCircleAttrs,
    determinateCircle,
    forwardEvents,
    $$restProps,
    getElement,
    instance,
    circle1_binding,
    div2_binding
  ];
}
var CircularProgress = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment, safe_not_equal, {
      use: 0,
      class: 1,
      indeterminate: 2,
      closed: 3,
      progress: 4,
      fourColor: 5,
      getElement: 13
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "CircularProgress",
      options,
      id: create_fragment.name
    });
  }
  get use() {
    throw new Error("<CircularProgress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set use(value) {
    throw new Error("<CircularProgress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get class() {
    throw new Error("<CircularProgress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set class(value) {
    throw new Error("<CircularProgress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get indeterminate() {
    throw new Error("<CircularProgress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set indeterminate(value) {
    throw new Error("<CircularProgress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get closed() {
    throw new Error("<CircularProgress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set closed(value) {
    throw new Error("<CircularProgress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get progress() {
    throw new Error("<CircularProgress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set progress(value) {
    throw new Error("<CircularProgress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get fourColor() {
    throw new Error("<CircularProgress>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set fourColor(value) {
    throw new Error("<CircularProgress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get getElement() {
    return this.$$.ctx[13];
  }
  set getElement(value) {
    throw new Error("<CircularProgress>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var CircularProgress_default = CircularProgress;

// node_modules/@smui/circular-progress/dist/index.js
var dist_default = CircularProgress_default;
export {
  dist_default as default
};
//# sourceMappingURL=@smui_circular-progress.js.map
